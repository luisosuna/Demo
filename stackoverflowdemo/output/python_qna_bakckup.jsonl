{"question": "How do I split the definition of a long string over multiple lines?", "tags": ["python", "string", "multiline", "multilinestring"], "link": "https://stackoverflow.com/questions/10660435/how-do-i-split-the-definition-of-a-long-string-over-multiple-lines", "answer_count": 31, "answers": {"id": 24331604, "body": "Breaking lines by \n\\\n works for me.  Here is an example:\n\n\nlongStr = \"This is a very long string \" \\\n        \"that I wrote to help somebody \" \\\n        \"who had a question about \" \\\n        \"writing long strings in Python\"\n\n\n", "score": 199}}
{"question": "How to prettyprint a JSON file?", "tags": ["python", "json", "formatting", "pretty-print"], "link": "https://stackoverflow.com/questions/12943819/how-to-prettyprint-a-json-file", "answer_count": 15, "answers": {"id": 48111364, "body": "After reading the data with the \njson\n standard library module, use the \npprint\n standard library module to display the parsed data. Example:\n\n\nimport json\nimport pprint\n\njson_data = None\nwith open('file_name.txt', 'r') as f:\n    data = f.read()\n    json_data = json.loads(data)\n\n# print json to screen with human-friendly formatting\npprint.pprint(json_data, compact=True)\n\n# write json to file with human-friendly formatting\npretty_json_str = pprint.pformat(json_data, compact=True).replace(\"'\",'\"')\n\nwith open('file_name.json', 'w') as f:\n    f.write(pretty_json_str)\n\n\n\n\nThe default \nindent\n is 1, so you may want to specify your own.\n\n\nBy default, pprint will output lists like this:\n\n\n'not compact': ['pprint',\n                'will',\n                'output',\n                'lists',\n                'like',\n                'this'],\n\n\n\nAnd that is no better than \njson.dump()\n or \njson.dumps()\n with an \nindent\n specified.\n\n\nWith\n \ncompact=True\n, pprint will output lists something like this:\n\n\n'compact': ['pprint', 'with compact=True', 'will', 'output',\n            'lists', 'like', 'this'],\n\n\n\nNote that you can specify where it will wrap with the \nwidth\n argument.\n\n\nIt is necessary to replace 'single quotes' with 'double quotes' in the string returned by pprint.pformat(), because single quotes are not valid json. When you look at the file in your text editor, it may be unable to highlight the json properly.\n\n\nIn any case, you may want to save it as valid json, so that you can as a human can simply read your json files comfortably, if it is not more important that they are formatted without spacing so they can be computer-processed with blinding speed.\n\n\nUltimately, the output will look like this:\n\n\n{'address': {'city': 'New York',\n             'postalCode': '10021-3100',\n             'state': 'NY',\n             'streetAddress': '21 2nd Street'},\n 'age': 27,\n 'children': [],\n 'firstName': 'John',\n 'isAlive': True,\n 'lastName': 'Smith'}\n\n\n", "score": 160}}
{"question": "How to read a file line-by-line into a list?", "tags": ["python", "string", "file", "readlines"], "link": "https://stackoverflow.com/questions/3277503/how-to-read-a-file-line-by-line-into-a-list", "answer_count": 28, "answers": {"id": 3277512, "body": "This is more explicit than necessary, but does what you want.\n\n\nwith open(\"file.txt\") as file_in:\n    lines = []\n    for line in file_in:\n        lines.append(line)\n\n\n", "score": 724}}
{"question": "Getting the class name of an instance", "tags": ["python", "introspection", "instanceof", "python-datamodel"], "link": "https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance", "answer_count": 12, "answers": {"id": 510988, "body": "type()\n ?\n\n\n>>> class A:\n...     def whoami(self):\n...         print(type(self).__name__)\n...\n>>>\n>>> class B(A):\n...     pass\n...\n>>>\n>>>\n>>> o = B()\n>>> o.whoami()\n'B'\n>>>\n\n\n", "score": 192}}
{"question": "How do I check if a string represents a number (float or int)?", "tags": ["python", "casting", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-represents-a-number-float-or-int", "answer_count": 41, "answers": {"id": 23639915, "body": "TL;DR\n The best solution is \ns.replace('.','',1).isdigit()\n\n\nI did some \nbenchmarks\n comparing the different approaches\n\n\ndef is_number_tryexcept(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n       \nimport re    \ndef is_number_regex(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    if re.match(\"^\\d+?\\.\\d+?$\", s) is None:\n        return s.isdigit()\n    return True\n\n\ndef is_number_repl_isdigit(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    return s.replace('.','',1).isdigit()\n\n\n\nIf the string is not a number, the except-block is quite slow. But more importantly, the try-except method is the only approach that handles scientific notations correctly.\n\n\nfuncs = [\n          is_number_tryexcept, \n          is_number_regex,\n          is_number_repl_isdigit\n          ]\n\na_float = '.1234'\n\nprint('Float notation \".1234\" is not supported by:')\nfor f in funcs:\n    if not f(a_float):\n        print('\\t -', f.__name__)\n\n\n\nFloat notation \".1234\" is not supported by:\n\n\n\n\nis_number_regex\n\n\nscientific1 = '1.000000e+50'\nscientific2 = '1e50'\n\n\nprint('Scientific notation \"1.000000e+50\" is not supported by:')\nfor f in funcs:\nif not f(scientific1):\nprint('\\t -', f.\nname\n)\n\n\nprint('Scientific notation \"1e50\" is not supported by:')\nfor f in funcs:\nif not f(scientific2):\nprint('\\t -', f.\nname\n)\n\n\n\n\n\n\nScientific notation \"1.000000e+50\" is not supported by:\n\n\n\n\nis_number_regex\n\n\nis_number_repl_isdigit\n\nScientific notation \"1e50\" is not supported by:\n\n\nis_number_regex\n\n\nis_number_repl_isdigit\n\n\n\n\nEDIT: The benchmark results\n\n\nimport timeit\n\ntest_cases = ['1.12345', '1.12.345', 'abc12345', '12345']\ntimes_n = {f.__name__:[] for f in funcs}\n\nfor t in test_cases:\n    for f in funcs:\n        f = f.__name__\n        times_n[f].append(min(timeit.Timer('%s(t)' %f, \n                      'from __main__ import %s, t' %f)\n                              .repeat(repeat=3, number=1000000)))\n\n\n\nwhere the following functions were tested\n\n\nfrom re import match as re_match\nfrom re import compile as re_compile\n\ndef is_number_tryexcept(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False\n\ndef is_number_regex(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    if re_match(\"^\\d+?\\.\\d+?$\", s) is None:\n        return s.isdigit()\n    return True\n\n\ncomp = re_compile(\"^\\d+?\\.\\d+?$\")    \n\ndef compiled_regex(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    if comp.match(s) is None:\n        return s.isdigit()\n    return True\n\n\ndef is_number_repl_isdigit(s):\n    \"\"\" Returns True if string is a number. \"\"\"\n    return s.replace('.','',1).isdigit()\n\n\n\n\n", "score": 342}}
{"question": "How do I get the row count of a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe"], "link": "https://stackoverflow.com/questions/15943769/how-do-i-get-the-row-count-of-a-pandas-dataframe", "answer_count": 20, "answers": {"id": 18317067, "body": "Use \nlen(df)\n :-).\n\n\n__len__()\n is documented with \"Returns length of index\".\n\n\nTiming info, set up the same way as in \nroot's answer\n:\n\n\nIn [7]: timeit len(df.index)\n1000000 loops, best of 3: 248 ns per loop\n\nIn [8]: timeit len(df)\n1000000 loops, best of 3: 573 ns per loop\n\n\n\nDue to one additional function call, it is of course correct to say that it is a bit slower than calling \nlen(df.index)\n directly. But this should not matter in most cases. I find \nlen(df)\n to be quite readable.\n\n", "score": 285}}
{"question": "Meaning of @classmethod and @staticmethod for beginner", "tags": ["python", "oop", "static-methods", "class-method"], "link": "https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner", "answer_count": 12, "answers": {"id": 12179325, "body": "@classmethod\n means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.\n\n\n@staticmethod\n means:  when this method is called, we don't pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can't access the instance of that class (this is useful when your method does not use the instance).\n\n", "score": 307}}
{"question": "What&#39;s the canonical way to check for type in Python?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/152580/whats-the-canonical-way-to-check-for-type-in-python", "answer_count": 19, "answers": {"id": 152592, "body": "isinstance(o, str)\n will return \nTrue\n if \no\n is an \nstr\n or is of a type that inherits from \nstr\n.\n\n\ntype(o) is str\n will return \nTrue\n if and only if \no\n is a \nstr\n. It will return \nFalse\n if \no\n is of a type that inherits from \nstr\n.\n\n", "score": 86}}
{"question": "How can I install packages using pip according to the requirements.txt file from a local directory?", "tags": ["python", "virtualenv", "pip"], "link": "https://stackoverflow.com/questions/7225900/how-can-i-install-packages-using-pip-according-to-the-requirements-txt-file-from", "answer_count": 18, "answers": {"id": 22046133, "body": "For virtualenv to install all files in the \nrequirements.txt\n file.\n\n\n\n\ncd to the directory where \nrequirements.txt\n is located\n\n\nactivate your virtualenv\n\n\nrun:  \npip install -r requirements.txt\n in your shell\n\n\n\n", "score": 202}}
{"question": "Proper way to declare custom exceptions in modern Python?", "tags": ["python", "python-3.x", "exception", "python-dataclasses"], "link": "https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python", "answer_count": 17, "answers": {"id": 26938914, "body": "\n\n\"What is the proper way to declare custom exceptions in modern Python?\"\n\n\n\n\nThis is fine unless your exception is really a type of a more specific exception:\n\n\nclass MyException(Exception):\n    pass\n\n\n\nOr better (maybe perfect), instead of \npass\n give a docstring:\n\n\nclass MyException(Exception):\n    \"\"\"Raise for my specific kind of exception\"\"\"\n\n\n\nSubclassing Exception Subclasses\n\n\nFrom the \ndocs\n\n\n\n\nException\n\n\nAll built-in, non-system-exiting exceptions are derived from this class.\nAll user-defined exceptions should also be derived from this\nclass.\n\n\n\n\nThat means that \nif\n your exception is a type of a more specific exception, subclass that exception instead of the generic \nException\n (and the result will be that you still derive from \nException\n as the docs recommend). Also, you can at least provide a docstring (and not be forced to use the \npass\n keyword):\n\n\nclass MyAppValueError(ValueError):\n    '''Raise when my specific value is wrong'''\n\n\n\nSet attributes you create yourself with a custom \n__init__\n. Avoid passing a dict as a positional argument, future users of your code will thank you. If you use the deprecated message attribute, assigning it yourself will avoid a \nDeprecationWarning\n:\n\n\nclass MyAppValueError(ValueError):\n    '''Raise when a specific subset of values in context of app is wrong'''\n    def __init__(self, message, foo, *args):\n        self.message = message # without this you may get DeprecationWarning\n        # Special attribute you desire with your Error, \n        # perhaps the value that caused the error?:\n        self.foo = foo         \n        # allow users initialize misc. arguments as any other builtin Error\n        super(MyAppValueError, self).__init__(message, foo, *args) \n\n\n\nThere's really no need to write your own \n__str__\n or \n__repr__\n. The built-in ones are very nice, and your \ncooperative inheritance\n ensures that you use them.\n\n\nCritique of the top answer\n\n\n\n\nMaybe I missed the question, but why not:\n\n\nclass MyException(Exception):\n    pass\n\n\n\n\n\nAgain, the problem with the above is that in order to catch it, you'll either have to name it specifically (importing it if created elsewhere) or catch Exception, (but you're probably not prepared to handle all types of Exceptions, and you should only catch exceptions you are prepared to handle). Similar criticism to the below, but additionally that's not the way to initialize via \nsuper\n, and you'll get a \nDeprecationWarning\n if you access the message attribute:\n\n\n\n\nEdit: to override something (or pass extra args), do this:\n\n\nclass ValidationError(Exception):\n    def __init__(self, message, errors):\n\n        # Call the base class constructor with the parameters it needs\n        super(ValidationError, self).__init__(message)\n\n        # Now for your custom code...\n        self.errors = errors\n\n\n\nThat way you could pass dict of error messages to the second param, and get to it later with \ne.errors\n.\n\n\n\n\nIt also requires exactly two arguments to be passed in (aside from the \nself\n.) No more, no less. That's an interesting constraint that future users may not appreciate.\n\n\nTo be direct - it violates \nLiskov substitutability\n.\n\n\nI'll demonstrate both errors:\n\n\n>>> ValidationError('foo', 'bar', 'baz').message\n\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\n    ValidationError('foo', 'bar', 'baz').message\nTypeError: __init__() takes exactly 3 arguments (4 given)\n\n>>> ValidationError('foo', 'bar').message\n__main__:1: DeprecationWarning: BaseException.message has been deprecated as of Python 2.6\n'foo'\n\n\n\nCompared to:\n\n\n>>> MyAppValueError('foo', 'FOO', 'bar').message\n'foo'\n\n\n", "score": 327}}
{"question": "Generate random integers between 0 and 9", "tags": ["python", "random", "integer"], "link": "https://stackoverflow.com/questions/3996904/generate-random-integers-between-0-and-9", "answer_count": 24, "answers": {"id": 3996919, "body": "Try this:\n\n\nfrom random import randrange, uniform\n\n# randrange gives you an integral value\nirand = randrange(0, 10)\n\n# uniform gives you a floating-point value\nfrand = uniform(0, 10)\n\n\n", "score": 196}}
{"question": "fatal error: Python.h: No such file or directory", "tags": ["python", "gcc", "python-c-api"], "link": "https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory", "answer_count": 37, "answers": {"id": 57698471, "body": "For \nPython 3.7\n and \nUbuntu\n in particular, I needed\n\n\nsudo apt install libpython3.7-dev\n\n\n.\nI think at some point names were changed from \npythonm.n-dev\n to this.\n\n\nfor Python 3.6, 3.8 through 3.10 (and counting\u2026) similarly:\n\n\nsudo apt install libpython3.6-dev\n\u2007\n\n\nsudo apt install libpython3.8-dev\n\u2007\n\n\nsudo apt install libpython3.9-dev\n\n\nsudo apt install libpython3.10-dev\n\n\nsudo apt install libpython3.11-dev\n\n\nsudo apt install libpython3.12-dev\n\n", "score": 443}}
{"question": "What is the meaning of single and double underscore before an object name?", "tags": ["python", "oop", "naming-conventions", "identifier"], "link": "https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name", "answer_count": 19, "answers": {"id": 1301557, "body": "Excellent answers so far but some tidbits are missing. A single leading underscore isn't exactly \njust\n a convention: if you use \nfrom foobar import *\n, and module \nfoobar\n does not define an \n__all__\n list, the names imported from the module \ndo not\n include those with a leading underscore. Let's say it's \nmostly\n a convention, since this case is a pretty obscure corner;-).\n\n\nThe leading-underscore convention is widely used not just for \nprivate\n names, but also for what C++ would call \nprotected\n ones -- for example, names of methods that are fully intended to be overridden by subclasses (even ones that \nhave\n to be overridden since in the base class they \nraise NotImplementedError\n!-) are often single-leading-underscore names to indicate to code \nusing\n instances of that class (or subclasses) that said methods are not meant to be called directly.\n\n\nFor example, to make a thread-safe queue with a different queueing discipline than FIFO, one imports Queue, subclasses Queue.Queue, and overrides such methods as \n_get\n and \n_put\n; \"client code\" never calls those (\"hook\") methods, but rather the (\"organizing\") public methods such as \nput\n and \nget\n (this is known as the \nTemplate Method\n design pattern -- see e.g. \nhere\n for an interesting presentation based on a video of a talk of mine on the subject, with the addition of synopses of the transcript).\n\n\nEdit: The video links in the description of the talks are now broken. You can find the first two videos \nhere\n and \nhere\n.\n\n", "score": 389}}
{"question": "Relative imports for the billionth time", "tags": ["python", "python-import", "relative-path", "python-packaging", "relative-import"], "link": "https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time", "answer_count": 17, "answers": {"id": 65589847, "body": "There are too many long answers in a foreign language. So, I'll try to make it short.\n\n\nIf you write \nfrom . import module\n, opposite to what you think, \nmodule\n will not be imported from current directory, but from the top level of your package! If you run \n.py\n file as a script, it simply doesn't know where the top level is and thus refuses to work.\n\n\nIf you start it like this \npy -m package.module\n from the directory above \npackage\n, then Python knows where the top level is. That's very similar to Java: \njava -cp bin_directory package.class\n\n", "score": 79}}
{"question": "Extracting extension from filename", "tags": ["python", "filenames", "file-extension"], "link": "https://stackoverflow.com/questions/541390/extracting-extension-from-filename", "answer_count": 33, "answers": {"id": 541408, "body": "import os.path\nextension = os.path.splitext(filename)[1]\n\n\n", "score": 501}}
{"question": "How do I write JSON data to a file?", "tags": ["python", "json"], "link": "https://stackoverflow.com/questions/12309269/how-do-i-write-json-data-to-a-file", "answer_count": 19, "answers": {"id": 20776329, "body": "I would answer with slight modification with aforementioned answers and that is to write a prettified JSON file which human eyes can read better. For this, pass \nsort_keys\n as \nTrue\n and \nindent\n with 4 space characters and you are good to go. Also take care of ensuring that the ascii codes will not be written in your JSON file:\n\n\nwith open('data.txt', 'w') as out_file:\n     json.dump(json_data, out_file, sort_keys = True, indent = 4,\n               ensure_ascii = False)\n\n\n", "score": 200}}
{"question": "How can I import a module dynamically given the full path?", "tags": ["python", "python-import", "python-module"], "link": "https://stackoverflow.com/questions/67631/how-can-i-import-a-module-dynamically-given-the-full-path", "answer_count": 38, "answers": {"id": 53311583, "body": "To import your module, you need to add its directory to the environment variable, either temporarily or permanently.\n\n\nTemporarily\n\n\nimport sys\nsys.path.append(\"/path/to/my/modules/\")\nimport my_module\n\n\n\nPermanently\n\n\nAdding the following line to your \n.bashrc\n (or alternative) file in Linux\nand excecute \nsource ~/.bashrc\n (or alternative) in the terminal:\n\n\nexport PYTHONPATH=\"${PYTHONPATH}:/path/to/my/modules/\"\n\n\n\nCredit/Source: \nsaarrrr\n, \nanother Stack\u00a0Exchange question\n\n", "score": 152}}
{"question": "How can I import a module dynamically given the full path?", "tags": ["python", "python-import", "python-module"], "link": "https://stackoverflow.com/questions/67631/how-can-i-import-a-module-dynamically-given-the-full-path", "answer_count": 38, "answers": {"id": 129374, "body": "The advantage of adding a path to sys.path (over using imp) is that it simplifies things when importing more than one module from a single package.  For example:\n\n\nimport sys\n# the mock-0.3.1 dir contains testcase.py, testutils.py & mock.py\nsys.path.append('/foo/bar/mock-0.3.1')\n\nfrom testcase import TestCase\nfrom testutils import RunTests\nfrom mock import Mock, sentinel, patch\n\n\n", "score": 598}}
{"question": "How can I import a module dynamically given the full path?", "tags": ["python", "python-import", "python-module"], "link": "https://stackoverflow.com/questions/67631/how-can-i-import-a-module-dynamically-given-the-full-path", "answer_count": 38, "answers": {"id": 67692, "body": "Let's have \nMyClass\n in \nmodule.name\n module defined at \n/path/to/file.py\n. Below is how we import \nMyClass\n from this module\n\n\nFor Python 3.5+ use (\ndocs\n):\n\n\nimport importlib.util\nimport sys\nspec = importlib.util.spec_from_file_location(\"module.name\", \"/path/to/file.py\")\nfoo = importlib.util.module_from_spec(spec)\nsys.modules[\"module.name\"] = foo\nspec.loader.exec_module(foo)\nfoo.MyClass()\n\n\n\nFor Python 3.3 and 3.4 use:\n\n\nfrom importlib.machinery import SourceFileLoader\n\nfoo = SourceFileLoader(\"module.name\", \"/path/to/file.py\").load_module()\nfoo.MyClass()\n\n\n\n(Although this has been deprecated in Python 3.4.)\n\n\nFor Python 2 use:\n\n\nimport imp\n\nfoo = imp.load_source('module.name', '/path/to/file.py')\nfoo.MyClass()\n\n\n\nThere are equivalent convenience functions for compiled Python files and DLLs.\n\n\nSee also \nhttp://bugs.python.org/issue21436\n.\n\n", "score": 1808}}
{"question": "How do I write JSON data to a file?", "tags": ["python", "json"], "link": "https://stackoverflow.com/questions/12309269/how-do-i-write-json-data-to-a-file", "answer_count": 19, "answers": {"id": 14870531, "body": "To get \nutf8\n-encoded\n file as opposed to \nascii\n-encoded\n in the accepted answer for Python 2 use:\n\n\nimport io, json\nwith io.open('data.txt', 'w', encoding='utf-8') as f:\n  f.write(json.dumps(data, ensure_ascii=False))\n\n\n\nThe code is simpler in Python 3:\n\n\nimport json\nwith open('data.txt', 'w') as f:\n  json.dump(data, f, ensure_ascii=False)\n\n\n\nOn Windows, the \nencoding='utf-8'\n argument to \nopen\n is still necessary.\n\n\nTo avoid storing an encoded copy of the data in memory (result of \ndumps\n) and to output \nutf8-encoded\n bytestrings in both Python 2 and 3, use:\n\n\nimport json, codecs\nwith open('data.txt', 'wb') as f:\n    json.dump(data, codecs.getwriter('utf-8')(f), ensure_ascii=False)\n\n\n\nThe \ncodecs.getwriter\n call is redundant in Python 3 but required for Python 2\n\n\n\n\nReadability and size:\n\n\nThe use of \nensure_ascii=False\n gives better readability and smaller size:\n\n\n>>> json.dumps({'price': '\u20ac10'})\n'{\"price\": \"\\\\u20ac10\"}'\n>>> json.dumps({'price': '\u20ac10'}, ensure_ascii=False)\n'{\"price\": \"\u20ac10\"}'\n\n>>> len(json.dumps({'\u0430\u0431\u0432\u0433\u0434': 1}))\n37\n>>> len(json.dumps({'\u0430\u0431\u0432\u0433\u0434': 1}, ensure_ascii=False).encode('utf8'))\n17\n\n\n\nFurther improve readability by adding flags \nindent=4, sort_keys=True\n (as suggested by \ndinos66\n) to arguments of \ndump\n or \ndumps\n. This way you'll get a nicely indented sorted structure in the json file at the cost of a slightly larger file size.\n\n", "score": 344}}
{"question": "How do I write JSON data to a file?", "tags": ["python", "json"], "link": "https://stackoverflow.com/questions/12309269/how-do-i-write-json-data-to-a-file", "answer_count": 19, "answers": {"id": 12309296, "body": "data\n is a Python dictionary. It needs to be encoded as JSON before writing.\n\n\nUse this for maximum compatibility (Python 2 and 3):\n\n\nimport json\nwith open('data.json', 'w') as f:\n    json.dump(data, f)\n\n\n\nOn a modern system (i.e. Python 3 and UTF-8 support), you can write a nicer file using:\n\n\nimport json\nwith open('data.json', 'w', encoding='utf-8') as f:\n    json.dump(data, f, ensure_ascii=False, indent=4)\n\n\n\nSee \njson\n documentation.\n\n", "score": 3315}}
{"question": "Extracting extension from filename", "tags": ["python", "filenames", "file-extension"], "link": "https://stackoverflow.com/questions/541390/extracting-extension-from-filename", "answer_count": 33, "answers": {"id": 35188296, "body": "New in version 3.4.\n\n\nimport pathlib\n\nprint(pathlib.Path('/foo/bar.txt').suffix)  \n# Outputs: .txt\n\nprint(pathlib.Path('/foo/bar.txt').stem)  \n# Outputs: bar\n\nprint(pathlib.Path(\"hello/foo.bar.tar.gz\").suffixes)  \n# Outputs: ['.bar', '.tar', '.gz']\n\nprint(''.join(pathlib.Path(\"hello/foo.bar.tar.gz\").suffixes))\n# Outputs: .bar.tar.gz\n\nprint(pathlib.Path(\"hello/foo.bar.tar.gz\").stem)  \n# Outputs: foo.bar.tar\n\n\n\nI'm surprised no one has mentioned \npathlib\n yet, \npathlib\n IS awesome!\n\n", "score": 735}}
{"question": "Extracting extension from filename", "tags": ["python", "filenames", "file-extension"], "link": "https://stackoverflow.com/questions/541390/extracting-extension-from-filename", "answer_count": 33, "answers": {"id": 541394, "body": "Use \nos.path.splitext\n:\n\n\n>>> import os\n>>> filename, file_extension = os.path.splitext('/path/to/somefile.ext')\n>>> filename\n'/path/to/somefile'\n>>> file_extension\n'.ext'\n\n\n\nUnlike most manual string-splitting attempts, \nos.path.splitext\n will correctly treat \n/a/b.c/d\n as having no extension instead of having extension \n.c/d\n, and it will treat \n.bashrc\n as having no extension instead of having extension \n.bashrc\n:\n\n\n>>> os.path.splitext('/a/b.c/d')\n('/a/b.c/d', '')\n>>> os.path.splitext('.bashrc')\n('.bashrc', '')\n\n\n", "score": 2668}}
{"question": "Relative imports for the billionth time", "tags": ["python", "python-import", "relative-path", "python-packaging", "relative-import"], "link": "https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time", "answer_count": 17, "answers": {"id": 49480246, "body": "This is really a problem within python. \nThe origin of confusion is that people mistakenly take the relative import as path relative which is not.\n\n\nFor example when you write in \nfaa.py\n:\n\n\nfrom .. import foo\n\n\n\nThis has a meaning only if \nfaa.py\n was \nidentified and loaded\n by python, during execution, as a part of a package. In that case, the \nmodule's name\n\nfor \nfaa.py\n would be for example \nsome_packagename.faa\n. If the file was loaded just because it is in the current directory, when python is run, then its name would not refer to any package and eventually relative import would fail.\n\n\nA simple solution to refer modules in the current directory, is to use this:\n\n\nif __package__ is None or __package__ == '':\n    # uses current directory visibility\n    import foo\nelse:\n    # uses current package visibility\n    from . import foo\n\n\n", "score": 116}}
{"question": "Relative imports for the billionth time", "tags": ["python", "python-import", "relative-path", "python-packaging", "relative-import"], "link": "https://stackoverflow.com/questions/14132789/relative-imports-for-the-billionth-time", "answer_count": 17, "answers": {"id": 14132912, "body": "Script vs. Module\n\n\nHere's an explanation.  The short version is that there is a big difference between directly running a Python file, and importing that file from somewhere else.  \nJust knowing what directory a file is in does not determine what package Python thinks it is in.\n  That depends, additionally, on how you load the file into Python (by running or by importing).\n\n\nThere are two ways to load a Python file: as the top-level script, or as a\nmodule.  A file is loaded as the top-level script if you execute it directly, for instance by typing \npython myfile.py\n on the command line.  It is loaded as a module when an \nimport\n statement is encountered inside some other file.  There can only be one top-level script at a time; the top-level script is the Python file you ran to start things off.\n\n\nNaming\n\n\nWhen a file is loaded, it is given a name (which is stored in its \n__name__\n attribute).  If it was loaded as the top-level script, its name is \n__main__\n.  If it was loaded as a module, its name is the filename, preceded by the names of any packages/subpackages of which it is a part, separated by dots.\n\n\nSo for instance in your example:\n\n\npackage/\n    __init__.py\n    subpackage1/\n        __init__.py\n        moduleX.py\n    moduleA.py\n\n\n\nif you imported \nmoduleX\n (note: \nimported\n, not directly executed), its name would be \npackage.subpackage1.moduleX\n.  If you imported \nmoduleA\n, its name would be \npackage.moduleA\n.  However, if you \ndirectly run\n \nmoduleX\n from the command line, its name will instead be \n__main__\n, and if you directly run \nmoduleA\n from the command line, its name will be \n__main__\n.  When a module is run as the top-level script, it loses its normal name and its name is instead \n__main__\n.\n\n\nAccessing a module NOT through its containing package\n\n\nThere is an additional wrinkle: the module's name depends on whether it was imported \"directly\" from the directory it is in or imported via a package.  This only makes a difference if you run Python in a directory, and try to import a file in that same directory (or a subdirectory of it).  For instance, if you start the Python interpreter in the directory \npackage/subpackage1\n and then do \nimport moduleX\n, the name of \nmoduleX\n will just be \nmoduleX\n, and not \npackage.subpackage1.moduleX\n.  This is because Python adds the current directory to its search path when the interpreter is entered interactively; if it finds the to-be-imported module in the current directory, it will not know that that directory is part of a package, and the package information will not become part of the module's name.\n\n\nA special case is if you run the interpreter interactively (e.g., just type \npython\n and start entering Python code on the fly).  In this case, the name of that interactive session is \n__main__\n.\n\n\nNow here is the crucial thing for your error message: \nif a module's name has no dots, it is not considered to be part of a package\n.  It doesn't matter where the file actually is on disk.  All that matters is what its name is, and its name depends on how you loaded it.\n\n\nNow look at the quote you included in your question:\n\n\n\n\nRelative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top-level module, regardless of where the module is actually located on the file system.\n\n\n\n\nRelative imports...\n\n\nRelative imports use the module's \nname\n to determine where it is in a package.  When you use a relative import like \nfrom .. import foo\n, the dots indicate to step up some number of levels in the package hierarchy.  For instance, if your current module's name is \npackage.subpackage1.moduleX\n, then \n..moduleA\n would mean \npackage.moduleA\n.  For a \nfrom .. import\n to work, the module's name must have at least as many dots as there are in the \nimport\n statement.\n\n\n... are only relative in a package\n\n\nHowever, if your module's name is \n__main__\n, it is not considered to be in a package.  Its name has no dots, and therefore you cannot use \nfrom .. import\n statements inside it.  If you try to do so, you will get the \"relative-import in non-package\" error.\n\n\nScripts can't import relative\n\n\nWhat you probably did is you tried to run \nmoduleX\n or the like from the command line.  When you did this, its name was set to \n__main__\n, which means that relative imports within it will fail, because its name does not reveal that it is in a package. Note that this will also happen if you run Python from the same directory where a module is, and then try to import that module, because, as described above, Python will find the module in the current directory \"too early\" without realizing it is part of a package.\n\n\nAlso remember that when you run the interactive interpreter, the \"name\" of that interactive session is always \n__main__\n.  Thus \nyou cannot do relative imports directly from an interactive session\n.  Relative imports are only for use within module files.\n\n\nTwo solutions:\n\n\n\n\nIf you really do want to run \nmoduleX\n directly, but you still want it to be considered part of a package, you can do \npython -m package.subpackage1.moduleX\n.  The \n-m\n tells Python to load it as a module, not as the top-level script.\n\n\n\n\nOr perhaps you don't actually want to \nrun\n \nmoduleX\n, you just want to run some other script, say \nmyfile.py\n, that \nuses\n functions inside \nmoduleX\n.  If that is the case, put \nmyfile.py\n \nsomewhere else\n \u2013 \nnot\n inside the \npackage\n directory \u2013 and run it.  If inside \nmyfile.py\n you do things like \nfrom package.moduleA import spam\n, it will work fine.\n\n\n\n\n\n\nNotes\n\n\n\n\nFor either of these solutions, the package directory (\npackage\n in your example) must be accessible from the Python module search path (\nsys.path\n).  If it is not, you will not be able to use anything in the package reliably at all.\n\n\n\n\nSince Python 2.6, the module's \"name\" for package-resolution purposes is determined not just by its \n__name__\n attributes but also by the \n__package__\n attribute.  That's why I'm avoiding using the explicit symbol \n__name__\n to refer to the module's \"name\".  Since Python 2.6 a module's \"name\" is effectively \n__package__ + '.' + __name__\n, or just \n__name__\n if \n__package__\n is \nNone\n.)\n\n\n\n\n\n", "score": 2392}}
{"question": "What is the meaning of single and double underscore before an object name?", "tags": ["python", "oop", "naming-conventions", "identifier"], "link": "https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name", "answer_count": 19, "answers": {"id": 1301409, "body": "\n\n_foo\n: Only a convention. A way for the programmer to indicate that the variable is private (whatever that means in Python).\n\n\n\n\n__foo\n: This has real meaning. The interpreter replaces this name with \n_classname__foo\n as a way to ensure that the name will not overlap with a similar name in another class.\n\n\n\n\n__foo__\n: Only a convention. A way for the Python system to use names that won't conflict with user names.\n\n\n\n\n\n\nNo other form of underscores have meaning in the Python world. Also, there's no difference between class, variable, global, etc in these conventions.\n\n", "score": 578}}
{"question": "What is the meaning of single and double underscore before an object name?", "tags": ["python", "oop", "naming-conventions", "identifier"], "link": "https://stackoverflow.com/questions/1301346/what-is-the-meaning-of-single-and-double-underscore-before-an-object-name", "answer_count": 19, "answers": {"id": 1301369, "body": "Single Underscore\n\n\nIn a class, names with a leading underscore indicate to other programmers that the attribute or method is intended to be be used inside that class. However, privacy is not \nenforced\n in any way.\nUsing leading underscores for functions in a module indicates it should not be imported from somewhere else.\n\n\nFrom the \nPEP-8\n style guide:\n\n\n\n\n_single_leading_underscore\n: weak \"internal use\" indicator. E.g. \nfrom M import *\n does not import objects whose name starts with an underscore.\n\n\n\n\nDouble Underscore (Name Mangling)\n\n\nFrom \nthe Python docs\n:\n\n\n\n\nAny identifier of the form \n__spam\n (at least two leading underscores, at most one trailing underscore) is textually replaced with \n_classname__spam\n, where \nclassname\n is the current class name with leading underscore(s) stripped. This mangling is done without regard to the syntactic position of the identifier, so it can be used to define class-private instance and class variables, methods, variables stored in globals, and even variables stored in instances. private to this class on instances of other classes.\n\n\n\n\nAnd a warning from the same page:\n\n\n\n\nName mangling is intended to give classes an easy way to define \u201cprivate\u201d instance variables and methods, without having to worry about instance variables defined by derived classes, or mucking with instance variables by code outside the class. Note that the mangling rules are designed mostly to avoid accidents; \nit still is possible for a determined soul to access or modify a variable that is considered private.\n\n\n\n\nExample\n\n\n>>> class MyClass():\n...     def __init__(self):\n...             self.__superprivate = \"Hello\"\n...             self._semiprivate = \", world!\"\n...\n>>> mc = MyClass()\n>>> print mc.__superprivate\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nAttributeError: myClass instance has no attribute '__superprivate'\n>>> print mc._semiprivate\n, world!\n>>> print mc.__dict__\n{'_MyClass__superprivate': 'Hello', '_semiprivate': ', world!'}\n\n\n", "score": 1666}}
{"question": "fatal error: Python.h: No such file or directory", "tags": ["python", "gcc", "python-c-api"], "link": "https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory", "answer_count": 37, "answers": {"id": 22077790, "body": "On Ubuntu, I was running Python 3 and I had to install \n\n\nsudo apt-get install python3-dev\n\n\n\nIf you want to use a version of Python that is not linked to python3, install the associated python3.x-dev package.  For example:\n\n\nsudo apt-get install python3.5-dev\n\n\n", "score": 575}}
{"question": "fatal error: Python.h: No such file or directory", "tags": ["python", "gcc", "python-c-api"], "link": "https://stackoverflow.com/questions/21530577/fatal-error-python-h-no-such-file-or-directory", "answer_count": 37, "answers": {"id": 21530768, "body": "\n\nLooks like you haven't properly installed the header files and static libraries for python dev.  Use your package manager to install them system-wide.\n\n\nFor \napt\n (\nUbuntu, Debian...\n):\n\n\nsudo apt-get install python-dev   # for python2.x installs\nsudo apt-get install python3-dev  # for python3.x installs\n\n\n\nFor \nyum\n (\nCentOS, RHEL...\n):\n\n\nsudo yum install python-devel    # for python2.x installs\nsudo yum install python3-devel   # for python3.x installs\n\n\n\nFor \ndnf\n (\nFedora...\n):\n\n\nsudo dnf install python2-devel  # for python2.x installs\nsudo dnf install python3-devel  # for python3.x installs\n\n\n\nFor \nzypper\n (\nopenSUSE...\n):\n\n\nsudo zypper in python-devel   # for python2.x installs\nsudo zypper in python3-devel  # for python3.x installs\n\n\n\nFor \napk\n (\nAlpine...\n):\n\n\n# This is a departure from the normal Alpine naming\n# scheme, which uses py2- and py3- prefixes\nsudo apk add python2-dev  # for python2.x installs\nsudo apk add python3-dev  # for python3.x installs\n\n\n\nFor \napt-cyg\n (\nCygwin...\n):\n\n\napt-cyg install python-devel   # for python2.x installs\napt-cyg install python3-devel  # for python3.x installs\n\n\n\nImportant Note\n:\n python3-dev/devel does not automatically cover all minor versions of python3.\n\nE.g If you are using python 3.11 you may need to install \npython3.11-dev\n / \npython3.11-devel\n.\n\n", "score": 3585}}
{"question": "Generate random integers between 0 and 9", "tags": ["python", "random", "integer"], "link": "https://stackoverflow.com/questions/3996904/generate-random-integers-between-0-and-9", "answer_count": 24, "answers": {"id": 16376904, "body": "Try \nrandom.randint\n:\n\n\nimport random\nprint(random.randint(0, 9))\n\n\n\n\n\nDocs state:\n\n\n\n\nrandom.randint(a, b)\n\n\n\nReturn a random integer \nN\n such that \na <= N <= b\n. Alias for \nrandrange(a, b+1)\n.\n\n\n\n", "score": 832}}
{"question": "Generate random integers between 0 and 9", "tags": ["python", "random", "integer"], "link": "https://stackoverflow.com/questions/3996904/generate-random-integers-between-0-and-9", "answer_count": 24, "answers": {"id": 3996930, "body": "Try \nrandom.randrange\n:\n\n\nfrom random import randrange\nprint(randrange(10))\n\n\n", "score": 2643}}
{"question": "Proper way to declare custom exceptions in modern Python?", "tags": ["python", "python-3.x", "exception", "python-dataclasses"], "link": "https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python", "answer_count": 17, "answers": {"id": 10270732, "body": "With modern Python Exceptions, you don't need to abuse \n.message\n, or override \n.__str__()\n or \n.__repr__()\n or any of it. If all you want is an informative message when your exception is raised, do this:\n\n\nclass MyException(Exception):\n    pass\n\nraise MyException(\"My hovercraft is full of eels\")\n\n\n\nThat will give a traceback ending with \nMyException: My hovercraft is full of eels\n.\n\n\nIf you want more flexibility from the exception, you could pass a dictionary as the argument:\n\n\nraise MyException({\"message\":\"My hovercraft is full of animals\", \"animal\":\"eels\"})\n\n\n\nHowever, to get at those details in an \nexcept\n block is a bit more complicated. The details are stored in the \nargs\n attribute, which is a list. You would need to do something like this:\n\n\ntry:\n    raise MyException({\"message\":\"My hovercraft is full of animals\", \"animal\":\"eels\"})\nexcept MyException as e:\n    details = e.args[0]\n    print(details[\"animal\"])\n\n\n\nIt is still possible to pass in multiple items to the exception and access them via tuple indexes, but this is \nhighly discouraged\n (and was even intended for deprecation a while back). If you do need more than a single piece of information and the above method is not sufficient for you, then you should subclass \nException\n as described in the \ntutorial\n.\n\n\nclass MyError(Exception):\n    def __init__(self, message, animal):\n        self.message = message\n        self.animal = animal\n    def __str__(self):\n        return self.message\n\n\n", "score": 748}}
{"question": "Proper way to declare custom exceptions in modern Python?", "tags": ["python", "python-3.x", "exception", "python-dataclasses"], "link": "https://stackoverflow.com/questions/1319615/proper-way-to-declare-custom-exceptions-in-modern-python", "answer_count": 17, "answers": {"id": 1319675, "body": "Maybe I missed the question, but why not:\n\n\nclass MyException(Exception):\n    pass\n\n\n\nTo override something (or pass extra args), do this:\n\n\nclass ValidationError(Exception):\n    def __init__(self, message, errors):            \n        # Call the base class constructor with the parameters it needs\n        super().__init__(message)\n            \n        # Now for your custom code...\n        self.errors = errors\n\n\n\nThat way you could pass dict of error messages to the second param, and get to it later with \ne.errors\n.\n\n\nIn Python 2, you have to use this slightly more complex form of \nsuper()\n:\n\n\nsuper(ValidationError, self).__init__(message)\n\n\n", "score": 2039}}
{"question": "How can I install packages using pip according to the requirements.txt file from a local directory?", "tags": ["python", "virtualenv", "pip"], "link": "https://stackoverflow.com/questions/7225900/how-can-i-install-packages-using-pip-according-to-the-requirements-txt-file-from", "answer_count": 18, "answers": {"id": 10429168, "body": "This works for me:\n\n\n$ pip install -r requirements.txt --no-index --find-links file:///tmp/packages\n\n\n\n--no-index\n - Ignore package index (only look at \n--find-links\n URLs instead).\n\n\n-f, --find-links \n - If \n is a URL or a path to an HTML file, then parse for links to archives. If \n is a local path or a \nfile://\n URL that's a directory, then look for archives in the directory listing.\n\n", "score": 1167}}
{"question": "How can I install packages using pip according to the requirements.txt file from a local directory?", "tags": ["python", "virtualenv", "pip"], "link": "https://stackoverflow.com/questions/7225900/how-can-i-install-packages-using-pip-according-to-the-requirements-txt-file-from", "answer_count": 18, "answers": {"id": 15593865, "body": "This works for everyone:\n\n\npip install -r /path/to/requirements.txt\n\n\n\nExplanation:\n\n\n\n\n-r, --requirement < filename >\n\n\n\n\nInstall from the given requirements file. This option can be used multiple times.\n\n", "score": 2571}}
{"question": "What&#39;s the canonical way to check for type in Python?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/152580/whats-the-canonical-way-to-check-for-type-in-python", "answer_count": 19, "answers": {"id": 154156, "body": "The \nmost\n Pythonic way to check the type of an object is... not to check it.\n\n\nSince Python encourages \nDuck Typing\n, you should just \ntry...except\n to use the object's methods the way you want to use them.  So if your function is looking for a writable file object, \ndon't\n check that it's a subclass of \nfile\n, just try to use its \n.write()\n method!\n\n\nOf course, sometimes these nice abstractions break down and \nisinstance(obj, cls)\n is what you need.  But use sparingly.\n\n", "score": 273}}
{"question": "What&#39;s the canonical way to check for type in Python?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/152580/whats-the-canonical-way-to-check-for-type-in-python", "answer_count": 19, "answers": {"id": 152596, "body": "Use \nisinstance\n to check if \no\n is an instance of \nstr\n or any subclass of \nstr\n:\n\n\nif isinstance(o, str):\n\n\n\nTo check if the type of \no\n is exactly \nstr\n, \nexcluding subclasses of \nstr\n:\n\n\nif type(o) is str:\n\n\n\nSee \nBuilt-in Functions\n in the Python Library Reference for relevant information.\n\n\n\n\nChecking for strings in Python 2\n\n\nFor Python 2, this is a better way to check if \no\n is a string:\n\n\nif isinstance(o, basestring):\n\n\n\nbecause this will also catch Unicode strings. \nunicode\n is not a subclass of \nstr\n; both \nstr\n and \nunicode\n are subclasses of \nbasestring\n. In Python 3, \nbasestring\n no longer exists since there's \na strict separation\n of strings (\nstr\n) and binary data (\nbytes\n).\n\n\nAlternatively, \nisinstance\n accepts a tuple of classes. This will return \nTrue\n if \no\n is an instance of any subclass of any of \n(str, unicode)\n:\n\n\nif isinstance(o, (str, unicode)):\n\n\n", "score": 2332}}
{"question": "Meaning of @classmethod and @staticmethod for beginner", "tags": ["python", "oop", "static-methods", "class-method"], "link": "https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner", "answer_count": 12, "answers": {"id": 14605349, "body": "Rostyslav Dzinko's answer is very appropriate. I thought I could highlight one other reason you should choose \n@classmethod\n over \n@staticmethod\n when you are creating an additional constructor.\n\n\nIn the \nexample\n, Rostyslav used the \n@classmethod\n \nfrom_string\n as a Factory to create \nDate\n objects from otherwise unacceptable parameters. The same can be done with \n@staticmethod\n as is shown in the code below:\n\n\nclass Date:\n  def __init__(self, month, day, year):\n    self.month = month\n    self.day   = day\n    self.year  = year\n\n\n  def display(self):\n    return \"{0}-{1}-{2}\".format(self.month, self.day, self.year)\n\n\n  @staticmethod\n  def millenium(month, day):\n    return Date(month, day, 2000)\n\nnew_year = Date(1, 1, 2013)               # Creates a new Date object\nmillenium_new_year = Date.millenium(1, 1) # also creates a Date object. \n\n# Proof:\nnew_year.display()           # \"1-1-2013\"\nmillenium_new_year.display() # \"1-1-2000\"\n\nisinstance(new_year, Date) # True\nisinstance(millenium_new_year, Date) # True\n\n\n\nThus both \nnew_year\n and \nmillenium_new_year\n are instances of the \nDate\n class.\n\n\nBut, if you observe closely, the Factory process is hard-coded to create \nDate\n objects no matter what. What this means is that even if the \nDate\n class is subclassed, the subclasses will still create plain \nDate\n objects (without any properties of the subclass). See that in the example below:\n\n\nclass DateTime(Date):\n  def display(self):\n      return \"{0}-{1}-{2} - 00:00:00PM\".format(self.month, self.day, self.year)\n\n\ndatetime1 = DateTime(10, 10, 1990)\ndatetime2 = DateTime.millenium(10, 10)\n\nisinstance(datetime1, DateTime) # True\nisinstance(datetime2, DateTime) # False\n\ndatetime1.display() # returns \"10-10-1990 - 00:00:00PM\"\ndatetime2.display() # returns \"10-10-2000\" because it's not a DateTime object but a Date object. Check the implementation of the millenium method on the Date class for more details.\n\n\n\ndatetime2\n is not an instance of \nDateTime\n? WTF? Well, that's because of the \n@staticmethod\n decorator used.\n\n\nIn most cases, this is undesired. If what you want is a Factory method that is aware of the class that called it, then \n@classmethod\n is what you need.\n\n\nRewriting \nDate.millenium\n as (that's the only part of the above code that changes):\n\n\n@classmethod\ndef millenium(cls, month, day):\n    return cls(month, day, 2000)\n\n\n\nensures that the \nclass\n is not hard-coded but rather learnt. \ncls\n can be any subclass. The resulting \nobject\n will rightly be an instance of \ncls\n.\n\nLet's test that out:\n\n\ndatetime1 = DateTime(10, 10, 1990)\ndatetime2 = DateTime.millenium(10, 10)\n\nisinstance(datetime1, DateTime) # True\nisinstance(datetime2, DateTime) # True\n\n\ndatetime1.display() # \"10-10-1990 - 00:00:00PM\"\ndatetime2.display() # \"10-10-2000 - 00:00:00PM\"\n\n\n\nThe reason is, as you know by now, that \n@classmethod\n was used instead of \n@staticmethod\n\n", "score": 1026}}
{"question": "Meaning of @classmethod and @staticmethod for beginner", "tags": ["python", "oop", "static-methods", "class-method"], "link": "https://stackoverflow.com/questions/12179271/meaning-of-classmethod-and-staticmethod-for-beginner", "answer_count": 12, "answers": {"id": 12179752, "body": "Though \nclassmethod\n and \nstaticmethod\n are quite similar, there's a slight difference in usage for both entities: \nclassmethod\n must have a reference to a class object as the first parameter, whereas \nstaticmethod\n can have no parameters at all.\n\n\nExample\n\n\nclass Date(object):\n    \n    def __init__(self, day=0, month=0, year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n\n    @classmethod\n    def from_string(cls, date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        date1 = cls(day, month, year)\n        return date1\n\n    @staticmethod\n    def is_date_valid(date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        return day <= 31 and month <= 12 and year <= 3999\n\ndate2 = Date.from_string('11-09-2012')\nis_date = Date.is_date_valid('11-09-2012')\n\n\n\nExplanation\n\n\nLet's assume an example of a class, dealing with date information (this will be our boilerplate):\n\n\nclass Date(object):\n    \n    def __init__(self, day=0, month=0, year=0):\n        self.day = day\n        self.month = month\n        self.year = year\n\n\n\nThis class obviously could be used to store information about certain dates (without timezone information; let's assume all dates are presented in UTC).\n\n\nHere we have \n__init__\n, a typical initializer of Python class instances, which receives arguments as a typical instance method, having the first non-optional argument (\nself\n) that holds a reference to a newly created instance.\n\n\nClass Method\n\n\nWe have some tasks that can be nicely done using \nclassmethod\ns.\n\n\nLet's assume that we want to create a lot of \nDate\n class instances having date information coming from an outer source encoded as a string with format 'dd-mm-yyyy'. Suppose we have to do this in different places in the source code of our project.\n\n\nSo what we must do here is:\n\n\n\n\nParse a string to receive day, month and year as three integer variables or a 3-item tuple consisting of that variable.\n\n\nInstantiate \nDate\n by passing those values to the initialization call.\n\n\n\n\nThis will look like:\n\n\nday, month, year = map(int, string_date.split('-'))\ndate1 = Date(day, month, year)\n\n\n\nFor this purpose, C++ can implement such a feature with overloading, but Python lacks this overloading. Instead, we can use \nclassmethod\n. Let's create another \nconstructor\n.\n\n\n    @classmethod\n    def from_string(cls, date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        date1 = cls(day, month, year)\n        return date1\n\ndate2 = Date.from_string('11-09-2012')\n\n\n\nLet's look more carefully at the above implementation, and review what advantages we have here:\n\n\n\n\nWe've implemented date string parsing in one place and it's reusable now.\n\n\nEncapsulation works fine here (if you think that you could implement string parsing as a single function elsewhere, this solution fits the OOP paradigm far better).\n\n\ncls\n is the \nclass itself\n, not an instance of the class. It's pretty cool because if we inherit our \nDate\n class, all children will have \nfrom_string\n defined also.\n\n\n\n\nStatic method\n\n\nWhat about \nstaticmethod\n? It's pretty similar to \nclassmethod\n but doesn't take any obligatory parameters (like a class method or instance method does).\n\n\nLet's look at the next use case.\n\n\nWe have a date string that we want to validate somehow. This task is also logically bound to the \nDate\n class we've used so far, but doesn't require instantiation of it.\n\n\nHere is where \nstaticmethod\n can be useful. Let's look at the next piece of code:\n\n\n    @staticmethod\n    def is_date_valid(date_as_string):\n        day, month, year = map(int, date_as_string.split('-'))\n        return day <= 31 and month <= 12 and year <= 3999\n\n# usage:\nis_date = Date.is_date_valid('11-09-2012')\n\n\n\nSo, as we can see from usage of \nstaticmethod\n, we don't have any access to what the class is---it's basically just a function,  called syntactically like a method, but without access to the object and its internals (fields and other methods), which \nclassmethod\n does have.\n\n", "score": 3038}}
{"question": "How do I get the row count of a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe"], "link": "https://stackoverflow.com/questions/15943769/how-do-i-get-the-row-count-of-a-pandas-dataframe", "answer_count": 20, "answers": {"id": 35523946, "body": "Suppose \ndf\n is your dataframe then:\n\n\ncount_row = df.shape[0]  # Gives number of rows\ncount_col = df.shape[1]  # Gives number of columns\n\n\n\nOr, more succinctly,\n\n\nr, c = df.shape\n\n\n", "score": 496}}
{"question": "How do I get the row count of a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe"], "link": "https://stackoverflow.com/questions/15943769/how-do-i-get-the-row-count-of-a-pandas-dataframe", "answer_count": 20, "answers": {"id": 15943975, "body": "For a dataframe \ndf\n, one can use any of the following:\n\n\n\n\nlen(df.index)\n\n\ndf.shape[0]\n\n\ndf[df.columns[0]].count()\n (== \nnumber of non-NaN values\n in first column)\n\n\n\n\n\n\n\n\nCode to reproduce the plot:\n\n\nimport numpy as np\nimport pandas as pd\nimport perfplot\n\nperfplot.save(\n    \"out.png\",\n    setup=lambda n: pd.DataFrame(np.arange(n * 3).reshape(n, 3)),\n    n_range=[2**k for k in range(25)],\n    kernels=[\n        lambda df: len(df.index),\n        lambda df: df.shape[0],\n        lambda df: df[df.columns[0]].count(),\n    ],\n    labels=[\"len(df.index)\", \"df.shape[0]\", \"df[df.columns[0]].count()\"],\n    xlabel=\"Number of rows\",\n)\n\n\n", "score": 2979}}
{"question": "How do I check if a string represents a number (float or int)?", "tags": ["python", "casting", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-represents-a-number-float-or-int", "answer_count": 41, "answers": {"id": 354130, "body": "\n\nWhich, not only is ugly and slow\n\n\n\n\nI'd dispute both.\n\n\nA regex or other string parsing method would be uglier and slower.  \n\n\nI'm not sure that anything much could be faster than the above.  It calls the function and returns.  Try/Catch doesn't introduce much overhead because the most common exception is caught without an extensive search of stack frames.\n\n\nThe issue is that any numeric conversion function has two kinds of results\n\n\n\n\nA number, if the number is valid\n\n\nA status code (e.g., via errno) or exception to show that no valid number could be parsed.\n\n\n\n\nC (as an example) hacks around this a number of ways.  Python lays it out clearly and explicitly.\n\n\nI think your code for doing this is perfect.\n\n", "score": 787}}
{"question": "How do I check if a string represents a number (float or int)?", "tags": ["python", "casting", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/354038/how-do-i-check-if-a-string-represents-a-number-float-or-int", "answer_count": 41, "answers": {"id": 354073, "body": "For non-negative (unsigned) integers only, use \nisdigit()\n:\n\n\n>>> a = \"03523\"\n>>> a.isdigit()\nTrue\n>>> b = \"963spam\"\n>>> b.isdigit()\nFalse\n\n\n\n\n\nDocumentation for \nisdigit()\n: \nPython2\n, \nPython3\n\n\nFor Python 2 Unicode strings:\n\nisnumeric()\n.\n\n", "score": 1798}}
{"question": "Getting the class name of an instance", "tags": ["python", "introspection", "instanceof", "python-datamodel"], "link": "https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance", "answer_count": 12, "answers": {"id": 511060, "body": "Do you want the name of the class as a string?\n\n\ninstance.__class__.__name__\n\n\n", "score": 572}}
{"question": "Getting the class name of an instance", "tags": ["python", "introspection", "instanceof", "python-datamodel"], "link": "https://stackoverflow.com/questions/510972/getting-the-class-name-of-an-instance", "answer_count": 12, "answers": {"id": 511059, "body": "Have you tried the \n__name__\n attribute\n of the class? ie \ntype(x).__name__\n will give you the name of the class, which I think is what you want.\n\n\n>>> import itertools\n>>> x = itertools.count(0)\n>>> type(x).__name__\n'count'\n\n\n\nIf you're still using Python 2, note that the above method works with \nnew-style classes\n only (in Python 3+ all classes are \"new-style\" classes). Your code might use some old-style classes. The following works for both:\n\n\nx.__class__.__name__\n\n\n", "score": 2620}}
{"question": "How to read a file line-by-line into a list?", "tags": ["python", "string", "file", "readlines"], "link": "https://stackoverflow.com/questions/3277503/how-to-read-a-file-line-by-line-into-a-list", "answer_count": 28, "answers": {"id": 3277515, "body": "See \nInput and Ouput\n:\n\n\nwith open('filename') as f:\n    lines = f.readlines()\n\n\n\nor with stripping the newline character:\n\n\nwith open('filename') as f:\n    lines = [line.rstrip('\\n') for line in f]\n\n\n", "score": 1238}}
{"question": "How to read a file line-by-line into a list?", "tags": ["python", "string", "file", "readlines"], "link": "https://stackoverflow.com/questions/3277503/how-to-read-a-file-line-by-line-into-a-list", "answer_count": 28, "answers": {"id": 3277516, "body": "This code will read the entire file into memory and remove all whitespace characters (newlines and spaces) from the end of each line:\n\n\nwith open(filename) as file:\n    lines = [line.rstrip() for line in file]\n\n\n\nIf you're working with a large file, then you should instead read and process it line-by-line:\n\n\nwith open(filename) as file:\n    for line in file:\n        print(line.rstrip())\n\n\n\nIn Python 3.8 and up you can use a while loop with the \nwalrus operator\n like so:\n\n\nwith open(filename) as file:\n    while line := file.readline():\n        print(line.rstrip())\n\n\n\nDepending on what you plan to do with your file and how it was encoded, you may also want to manually set the \naccess mode\n and character encoding:\n\n\nwith open(filename, 'r', encoding='UTF-8') as file:\n    while line := file.readline():\n        print(line.rstrip())\n\n\n", "score": 3040}}
{"question": "How to prettyprint a JSON file?", "tags": ["python", "json", "formatting", "pretty-print"], "link": "https://stackoverflow.com/questions/12943819/how-to-prettyprint-a-json-file", "answer_count": 15, "answers": {"id": 32228333, "body": "You can do this on the command line:\n\n\npython3 -m json.tool some.json\n\n\n\n(as already mentioned in the commentaries to the question, thanks to @Kai Petzke for the python3 suggestion).\n\n\nActually python is not my favourite tool as far as json processing on the command line is concerned. For simple pretty printing is ok, but if you want to manipulate the json it can become overcomplicated. You'd soon need to write a separate script-file, you could end up with maps whose keys are u\"some-key\" (python unicode), which makes selecting fields more difficult and doesn't really go in the direction of pretty-printing.\n\n\nYou can also use \njq\n:\n\n\njq . some.json\n\n\n\nand you get colors as a bonus (and way easier extendability).\n\n\nAddendum: There is some confusion in the comments about using jq to process large JSON files on the one hand, and having a very large jq program on the other.  For pretty-printing a file consisting of a single large JSON entity, the practical limitation is RAM.  For pretty-printing a 2GB file consisting of a single array of real-world data, the \"maximum resident set size\" required for pretty-printing was 5GB (whether using jq 1.5 or 1.6). Note also that jq can be used from within python after \npip install jq\n.\n\n", "score": 494}}
{"question": "How to prettyprint a JSON file?", "tags": ["python", "json", "formatting", "pretty-print"], "link": "https://stackoverflow.com/questions/12943819/how-to-prettyprint-a-json-file", "answer_count": 15, "answers": {"id": 12944035, "body": "Use the \nindent=\n parameter of \njson.dump()\n or \njson.dumps()\n to specify how many spaces to indent by:\n\n\n>>> import json\n>>> your_json = '[\"foo\", {\"bar\": [\"baz\", null, 1.0, 2]}]'\n>>> parsed = json.loads(your_json)\n>>> print(json.dumps(parsed, indent=4))\n[\n    \"foo\",\n    {\n        \"bar\": [\n            \"baz\",\n            null,\n            1.0,\n            2\n        ]\n    }\n]\n\n\n\nTo parse a file, use \njson.load()\n:\n\n\nwith open('filename.txt', 'r') as handle:\n    parsed = json.load(handle)\n\n\n", "score": 3062}}
{"question": "How do I split the definition of a long string over multiple lines?", "tags": ["python", "string", "multiline", "multilinestring"], "link": "https://stackoverflow.com/questions/10660435/how-do-i-split-the-definition-of-a-long-string-over-multiple-lines", "answer_count": 31, "answers": {"id": 10660477, "body": "If you don't want a multiline string, but just have a long single line string, you can use parentheses. Just make sure you don't include commas between the string segments (then it will be a tuple).\n\n\nquery = ('SELECT   action.descr as \"action\", '\n         'role.id as role_id,'\n         'role.descr as role'\n         ' FROM '\n         'public.role_action_def,'\n         'public.role,'\n         'public.record_def, '\n         'public.action'\n         ' WHERE role.id = role_action_def.role_id AND'\n         ' record_def.id = role_action_def.def_id AND'\n         ' action.id = role_action_def.action_id AND'\n         ' role_action_def.account_id = '+account_id+' AND'\n         ' record_def.account_id='+account_id+' AND'\n         ' def_id='+def_id)\n\n\n\nIn a SQL statement like what you're constructing, multiline strings would also be fine. But if the extra white space a multiline string would contain would be a problem, then this would be a good way to achieve what you want.\n\n\nAs noted in the comments, \nconcatenating SQL queries in this way is a SQL injection security risk waiting to happen\n, so use your database's parameterized queries feature to prevent this. However, I'm leaving the answer as-is otherwise as it directly answers the question asked.\n\n", "score": 345}}
{"question": "How do I split the definition of a long string over multiple lines?", "tags": ["python", "string", "multiline", "multilinestring"], "link": "https://stackoverflow.com/questions/10660435/how-do-i-split-the-definition-of-a-long-string-over-multiple-lines", "answer_count": 31, "answers": {"id": 10660443, "body": "Are you talking about multi-line strings? Easy, use triple quotes to start and end them.\n\n\ns = \"\"\" this is a very\n        long string if I had the\n        energy to type more and more ...\"\"\"\n\n\n\nYou can use single quotes too (3 of them of course at start and end) and treat the resulting string \ns\n just like any other string.\n\n\nNOTE\n: Just as with any string, anything between the starting and ending quotes becomes part of the string, so this example has a leading blank (as pointed out by @root45). This string will also contain both blanks and newlines.\n\n\nI.e.,:\n\n\n' this is a very\\n        long string if I had the\\n        energy to type more and more ...'\n\n\n\nFinally, one can also construct long lines in Python like this:\n\n\n s = (\"this is a very\"\n      \"long string too\"\n      \"for sure ...\"\n     )\n\n\n\nwhich will \nnot\n include any extra blanks or newlines (this is a deliberate example showing what the effect of skipping blanks will result in):\n\n\n'this is a verylong string toofor sure ...'\n\n\n\nNo commas required, simply place the strings to be joined together into a pair of parenthesis and be sure to account for any needed blanks and newlines.\n\n", "score": 3246}}
{"question": "Installing specific package version with pip", "tags": ["python", "mysql", "pip", "pypi", "mysql-python"], "link": "https://stackoverflow.com/questions/5226311/installing-specific-package-version-with-pip", "answer_count": 12, "answers": {"id": 36399566, "body": "One way, as suggested in \nthis post\n, is to mention version in \npip\n as:\n\n\npip install -Iv MySQL_python==1.2.2\n\n\n\ni.e. Use \n==\n and mention the version number to install only that version. \n-I, --ignore-installed\n ignores already installed packages.\n\n", "score": 211}}
{"question": "Installing specific package version with pip", "tags": ["python", "mysql", "pip", "pypi", "mysql-python"], "link": "https://stackoverflow.com/questions/5226311/installing-specific-package-version-with-pip", "answer_count": 12, "answers": {"id": 33812968, "body": "You can even use a version range with \npip install\n command. Something like this:\n\n\npip install 'stevedore>=1.3.0,<1.4.0'\n\n\n\nAnd if the package is already installed and you want to downgrade it add \n--force-reinstall\n like this:\n\n\npip install 'stevedore>=1.3.0,<1.4.0' --force-reinstall\n\n\n", "score": 767}}
{"question": "Installing specific package version with pip", "tags": ["python", "mysql", "pip", "pypi", "mysql-python"], "link": "https://stackoverflow.com/questions/5226311/installing-specific-package-version-with-pip", "answer_count": 12, "answers": {"id": 5226504, "body": "TL;DR\n:\n\n\nUpdate as of 2022-12-28\n:\n\n\npip install --force-reinstall -v\n\n\nFor example: \npip install --force-reinstall -v \"MySQL_python==1.2.2\"\n\n\nWhat these options mean:\n\n\n\n\n--force-reinstall\n is an option to reinstall all packages even if they are already up-to-date.\n\n\n-v\n is for verbose. You can combine for even more verbosity (i.e. \n-vv\n) up to 3 times (e.g. \n--force-reinstall -vvv\n).\n\n\n\n\nThanks to \n@Peter\n for highlighting this (and it seems that the context of the question has broadened given the time when the question was first asked!), \nthe documentation for Python\n discusses a caveat with using \n-I\n, in that it can break your installation if it was installed with a different package manager or if if your package is/was a different version.\n\n\n\n\nOriginal answer:\n\n\n\n\npip install -Iv\n (i.e. \npip install -Iv MySQL_python==1.2.2\n)\n\n\n\n\n\n\nWhat these options mean:\n\n\n\n\n-I\n stands for \n--ignore-installed\n which will ignore the installed packages, overwriting them.\n\n\n-v\n is for verbose. You can combine for even more verbosity (i.e. \n-vv\n) up to 3 times (e.g. \n-Ivvv\n).\n\n\n\n\nFor more information, see \npip install --help\n\n\nFirst, I see two issues with what you're trying to do. Since you already have an installed version, you should either uninstall the current existing driver or use \npip install -I MySQL_python==1.2.2\n\n\nHowever, you'll soon find out that this doesn't work. If you look at pip's installation log, or if you do a \npip install -Iv MySQL_python==1.2.2\n you'll find that the PyPI URL link does not work for MySQL_python v1.2.2. You can verify this here: \nhttp://pypi.python.org/pypi/MySQL-python/1.2.2\n\n\nThe download link 404s and the fallback URL links are re-directing infinitely due to sourceforge.net's recent upgrade and PyPI's stale URL.\n\n\nSo to properly install the driver, you can follow these steps:\n\n\npip uninstall MySQL_python\npip install -Iv http://sourceforge.net/projects/mysql-python/files/mysql-python/1.2.2/MySQL-python-1.2.2.tar.gz/download\n\n\n", "score": 1591}}
{"question": "Static methods in Python?", "tags": ["python", "static-methods"], "link": "https://stackoverflow.com/questions/735975/static-methods-in-python", "answer_count": 12, "answers": {"id": 735976, "body": "Yes, check out the \nstaticmethod\n decorator:\n\n\n>>> class C:\n...     @staticmethod\n...     def hello():\n...             print \"Hello World\"\n...\n>>> C.hello()\nHello World\n\n\n", "score": 93}}
{"question": "Static methods in Python?", "tags": ["python", "static-methods"], "link": "https://stackoverflow.com/questions/735975/static-methods-in-python", "answer_count": 12, "answers": {"id": 10206355, "body": "I think that \nSteven is actually right\n. To answer the original question, then, in order to set up a class method, simply assume that the first argument is not going to be a calling instance, and then make sure that you only call the method from the class.\n\n\n(Note that this answer refers to Python 3.x. In Python 2.x you'll get a \nTypeError\n for calling the method on the class itself.)\n\n\nFor example:\n\n\nclass Dog:\n    count = 0 # this is a class variable\n    dogs = [] # this is a class variable\n\n    def __init__(self, name):\n        self.name = name #self.name is an instance variable\n        Dog.count += 1\n        Dog.dogs.append(name)\n\n    def bark(self, n): # this is an instance method\n        print(\"{} says: {}\".format(self.name, \"woof! \" * n))\n\n    def rollCall(n): #this is implicitly a class method (see comments below)\n        print(\"There are {} dogs.\".format(Dog.count))\n        if n >= len(Dog.dogs) or n < 0:\n            print(\"They are:\")\n            for dog in Dog.dogs:\n                print(\"  {}\".format(dog))\n        else:\n            print(\"The dog indexed at {} is {}.\".format(n, Dog.dogs[n]))\n\nfido = Dog(\"Fido\")\nfido.bark(3)\nDog.rollCall(-1)\nrex = Dog(\"Rex\")\nDog.rollCall(0)\n\n\n\nIn this code, the \"rollCall\" method assumes that the first argument is not an instance (as it would be if it were called by an instance instead of a class). As long as \"rollCall\" is called from the class rather than an instance, the code will work fine. If we try to call \"rollCall\" from an instance, e.g.:\n\n\nrex.rollCall(-1)\n\n\n\nhowever, it would cause an exception to be raised because it would send two arguments: itself and -1, and \"rollCall\" is only defined to accept one argument.\n\n\nIncidentally, rex.rollCall() would send the correct number of arguments, but would also cause an exception to be raised because now n would be representing a Dog instance (i.e., rex) when the function expects n to be numerical.\n\n\nThis is where the decoration comes in:\nIf we precede the \"rollCall\" method with\n\n\n@staticmethod\n\n\n\nthen, by explicitly stating that the method is static, we can even call it from an instance. Now, \n\n\nrex.rollCall(-1)\n\n\n\nwould work. The insertion of @staticmethod before a method definition, then, stops an instance from sending itself as an argument.\n\n\nYou can verify this by trying the following code with and without the @staticmethod line commented out.\n\n\nclass Dog:\n    count = 0 # this is a class variable\n    dogs = [] # this is a class variable\n\n    def __init__(self, name):\n        self.name = name #self.name is an instance variable\n        Dog.count += 1\n        Dog.dogs.append(name)\n\n    def bark(self, n): # this is an instance method\n        print(\"{} says: {}\".format(self.name, \"woof! \" * n))\n\n    @staticmethod\n    def rollCall(n):\n        print(\"There are {} dogs.\".format(Dog.count))\n        if n >= len(Dog.dogs) or n < 0:\n            print(\"They are:\")\n            for dog in Dog.dogs:\n                print(\"  {}\".format(dog))\n        else:\n            print(\"The dog indexed at {} is {}.\".format(n, Dog.dogs[n]))\n\n\nfido = Dog(\"Fido\")\nfido.bark(3)\nDog.rollCall(-1)\nrex = Dog(\"Rex\")\nDog.rollCall(0)\nrex.rollCall(-1)\n\n\n", "score": 259}}
{"question": "Static methods in Python?", "tags": ["python", "static-methods"], "link": "https://stackoverflow.com/questions/735975/static-methods-in-python", "answer_count": 12, "answers": {"id": 735978, "body": "Yep, using the \nstaticmethod\n decorator:\n\n\nclass MyClass(object):\n    @staticmethod\n    def the_static_method(x):\n        print(x)\n\nMyClass.the_static_method(2)  # outputs 2\n\n\n\nNote that some code might use the old method of defining a static method, using \nstaticmethod\n as a function rather than a decorator. This should only be used if you have to support ancient versions of Python (2.2 and 2.3):\n\n\nclass MyClass(object):\n    def the_static_method(x):\n        print(x)\n    the_static_method = staticmethod(the_static_method)\n\nMyClass.the_static_method(2)  # outputs 2\n\n\n\nThis is entirely identical to the first example (using \n@staticmethod\n), just not using the nice decorator syntax.\n\n\nFinally, use \nstaticmethod\n sparingly! There are very few situations where static-methods are necessary in Python, and I've seen them used many times where a separate \"top-level\" function would have been clearer.\n\n\n\n\nThe following is verbatim from the documentation:\n:\n\n\n\n\nA static method does not receive an implicit first argument. To declare a static method, use this idiom:\n\n\nclass C:\n    @staticmethod\n    def f(arg1, arg2, ...): ...\n\n\n\nThe @staticmethod form is a function \ndecorator\n \u2013 see the description of function definitions in \nFunction definitions\n for details.\n\n\nIt can be called either on the class (such as \nC.f()\n) or on an instance (such as \nC().f()\n). The instance is ignored except for its class.\n\n\nStatic methods in Python are similar to those found in Java or C++. For a more advanced concept, see \nclassmethod()\n.\n\n\nFor more information on static methods, consult the documentation on the standard type hierarchy in \nThe standard type hierarchy\n.\n\n\nNew in version 2.2.\n\n\nChanged in version 2.4: Function decorator syntax added.\n\n\n\n", "score": 2327}}
{"question": "How can I remove a trailing newline?", "tags": ["python", "newline", "trailing"], "link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "answer_count": 28, "answers": {"id": 275401, "body": "The canonical way to strip end-of-line (EOL) characters is to use the string rstrip() method removing any trailing \\r or \\n.  Here are examples for Mac, Windows, and Unix EOL characters.\n\n\n>>> 'Mac EOL\\r'.rstrip('\\r\\n')\n'Mac EOL'\n>>> 'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Windows EOL'\n>>> 'Unix EOL\\n'.rstrip('\\r\\n')\n'Unix EOL'\n\n\n\nUsing '\\r\\n' as the parameter to rstrip means that it will strip out any trailing combination of '\\r' or '\\n'.  That's why it works in all three cases above.\n\n\nThis nuance matters in rare cases.  For example, I once had to process a text file which contained an HL7 message.  The HL7 standard requires a trailing '\\r' as its EOL character.  The Windows machine on which I was using this message had appended its own '\\r\\n' EOL character.  Therefore, the end of each line looked like '\\r\\r\\n'.  Using rstrip('\\r\\n') would have taken off the entire '\\r\\r\\n' which is not what I wanted.  In that case, I simply sliced off the last two characters instead.\n\n\nNote that unlike Perl's \nchomp\n function, this will strip all specified characters at the end of the string, not just one:\n\n\n>>> \"Hello\\n\\n\\n\".rstrip(\"\\n\")\n\"Hello\"\n\n\n", "score": 175}}
{"question": "How can I remove a trailing newline?", "tags": ["python", "newline", "trailing"], "link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "answer_count": 28, "answers": {"id": 275659, "body": "And I would say the \"pythonic\" way to get lines without trailing newline characters is splitlines().\n\n\n>>> text = \"line 1\\nline 2\\r\\nline 3\\nline 4\"\n>>> text.splitlines()\n['line 1', 'line 2', 'line 3', 'line 4']\n\n\n", "score": 186}}
{"question": "How can I remove a trailing newline?", "tags": ["python", "newline", "trailing"], "link": "https://stackoverflow.com/questions/275018/how-can-i-remove-a-trailing-newline", "answer_count": 28, "answers": {"id": 275025, "body": "Try the method \nrstrip()\n (see doc \nPython 2\n and \nPython 3\n)\n\n\n>>> 'test string\\n'.rstrip()\n'test string'\n\n\n\nPython's \nrstrip()\n method strips \nall\n kinds of trailing whitespace by default, not just one newline as Perl does with \nchomp\n.\n\n\n>>> 'test string \\n \\r\\n\\n\\r \\n\\n'.rstrip()\n'test string'\n\n\n\nTo strip only newlines:\n\n\n>>> 'test string \\n \\r\\n\\n\\r \\n\\n'.rstrip('\\n')\n'test string \\n \\r\\n\\n\\r '\n\n\n\nIn addition to \nrstrip()\n, there are also the methods \nstrip()\n and \nlstrip()\n. Here is an example with the three of them:\n\n\n>>> s = \"   \\n\\r\\n  \\n  abc   def \\n\\r\\n  \\n  \"\n>>> s.strip()\n'abc   def'\n>>> s.lstrip()\n'abc   def \\n\\r\\n  \\n  '\n>>> s.rstrip()\n'   \\n\\r\\n  \\n  abc   def'\n\n\n", "score": 2328}}
{"question": "Is there a way to run Python on Android?", "tags": ["android", "python", "jython", "ase", "android-scripting"], "link": "https://stackoverflow.com/questions/101754/is-there-a-way-to-run-python-on-android", "answer_count": 23, "answers": {"id": 973765, "body": "Yes! : \nAndroid Scripting Environment\n\n\nAn example \nvia Matt Cutts\n via SL4A -- \"here\u2019s a barcode scanner written in six lines of Python code:\n\n\nimport android\ndroid = android.Android()\ncode = droid.scanBarcode()\nisbn = int(code['result']['SCAN_RESULT'])\nurl = \"http://books.google.com?q=%d\" % isbn\ndroid.startActivity('android.intent.action.VIEW', url)\n\n\n", "score": 231}}
{"question": "Is there a way to run Python on Android?", "tags": ["android", "python", "jython", "ase", "android-scripting"], "link": "https://stackoverflow.com/questions/101754/is-there-a-way-to-run-python-on-android", "answer_count": 23, "answers": {"id": 973786, "body": "There is also the new \nAndroid Scripting Environment\n (ASE/SL4A) project. It looks awesome, and it has some integration with native Android components. \n\n\nNote: no longer under \"active development\", but some forks may be.\n\n", "score": 366}}
{"question": "Is there a way to run Python on Android?", "tags": ["android", "python", "jython", "ase", "android-scripting"], "link": "https://stackoverflow.com/questions/101754/is-there-a-way-to-run-python-on-android", "answer_count": 23, "answers": {"id": 8189603, "body": "One way is to use \nKivy\n:\n\n\n\n\nOpen source Python library for rapid development of applications\n  that make use of innovative user interfaces, such as multi-touch apps.\n\n\n\n\n\n\n\n\nKivy runs on Linux, Windows, OS X, Android and iOS. You can run the same [python] code on all supported platforms.\n\n\n\n\nKivy Showcase app\n \n\n", "score": 1190}}
{"question": "How do I append to a file?", "tags": ["python", "file", "append"], "link": "https://stackoverflow.com/questions/4706499/how-do-i-append-to-a-file", "answer_count": 12, "answers": {"id": 26833243, "body": "I always do this,\n\n\nf = open('filename.txt', 'a')\nf.write(\"stuff\")\nf.close()\n\n\n\nIt's simple, but very useful.\n\n", "score": 59}}
{"question": "How do I append to a file?", "tags": ["python", "file", "append"], "link": "https://stackoverflow.com/questions/4706499/how-do-i-append-to-a-file", "answer_count": 12, "answers": {"id": 4706519, "body": "You need to open the file in append mode, by setting \"a\" or \"ab\" as the mode. See \nopen()\n.\n\n\nWhen you open with \"a\" mode, the write position will \nalways\n be at the end of the file (an append). You can open with \"a+\" to allow reading, seek backwards and read (but all writes will still be at the end of the file!).\n\n\nExample:\n\n\n>>> with open('test1','wb') as f:\n        f.write('test')\n>>> with open('test1','ab') as f:\n        f.write('koko')\n>>> with open('test1','rb') as f:\n        f.read()\n'testkoko'\n\n\n\nNote\n: Using 'a' is not the same as opening with 'w' and seeking to the end of the file - consider what might happen if another program opened the file and started writing between the seek and the write. On some operating systems, opening the file with 'a' guarantees that all your following writes will be appended atomically to the end of the file (even as the file grows by other writes).\n\n\n\n\nA few more details about how the \"a\" mode operates (\ntested on Linux only\n). Even if you seek back, every write will append to the end of the file:\n\n\n>>> f = open('test','a+') # Not using 'with' just to simplify the example REPL session\n>>> f.write('hi')\n>>> f.seek(0)\n>>> f.read()\n'hi'\n>>> f.seek(0)\n>>> f.write('bye') # Will still append despite the seek(0)!\n>>> f.seek(0)\n>>> f.read()\n'hibye'\n\n\n\nIn fact, the \nfopen\n \nmanpage\n states:\n\n\n\n\nOpening a file in append mode (a as the first character of mode)\n  causes all subsequent write operations to this stream to occur at\n  end-of-file, as if preceded the call:\n\n\nfseek(stream, 0, SEEK_END);\n\n\n\n\n\n\n\nOld simplified answer (not using \nwith\n):\n\n\nExample: (\nin a real program \nuse \nwith\n to close the file\n - see \nthe documentation\n)\n\n\n>>> open(\"test\",\"wb\").write(\"test\")\n>>> open(\"test\",\"a+b\").write(\"koko\")\n>>> open(\"test\",\"rb\").read()\n'testkoko'\n\n\n", "score": 273}}
{"question": "How do I append to a file?", "tags": ["python", "file", "append"], "link": "https://stackoverflow.com/questions/4706499/how-do-i-append-to-a-file", "answer_count": 12, "answers": {"id": 4706520, "body": "Set the mode in \nopen()\n to \n\"a\"\n (append) instead of \n\"w\"\n (write):\n\n\nwith open(\"test.txt\", \"a\") as myfile:\n    myfile.write(\"appended text\")\n\n\n\nThe \ndocumentation\n lists all the available modes.\n\n", "score": 3166}}
{"question": "Why is it string.join(list) instead of list.join(string)?", "tags": ["python", "string", "list"], "link": "https://stackoverflow.com/questions/493819/why-is-it-string-joinlist-instead-of-list-joinstring", "answer_count": 10, "answers": {"id": 493884, "body": "I agree that it's counterintuitive at first, but there's a good reason. Join can't be a method of a list because:\n\n\n\n\nit must work for different iterables too (tuples, generators, etc.) \n\n\nit must have different behavior between different types of strings.\n\n\n\n\nThere are actually two join methods (Python 3.0):\n\n\n>>> b\"\".join\n\n\n>>> \"\".join\n\n\n\n\n\nIf join was a method of a list, then it would have to inspect its arguments to decide which one of them to call. And you can't join byte and str together, so the way they have it now makes sense. \n\n", "score": 83}}
{"question": "Why is it string.join(list) instead of list.join(string)?", "tags": ["python", "string", "list"], "link": "https://stackoverflow.com/questions/493819/why-is-it-string-joinlist-instead-of-list-joinstring", "answer_count": 10, "answers": {"id": 12662361, "body": "This was discussed in the \nString methods... finally\n thread in the Python-Dev achive, and was accepted by Guido. This thread began in Jun 1999, and \nstr.join\n was included in Python 1.6 which was released in Sep 2000 (and supported Unicode). Python 2.0 (supported \nstr\n methods including \njoin\n) was released in Oct 2000.\n\n\n\n\nThere were four options proposed in this thread:\n\n\n\nseparator.join(items)\n\n\nitems.join(separator)\n\n\nitems.reduce(separator)\n\n\njoin\n as a built-in function\n\n\n\n\n\n\nGuido wanted to support not only \nlist\ns and \ntuple\ns, but all sequences/iterables.\n\n\nitems.reduce(separator)\n is difficult for newcomers.\n\n\nitems.join(separator)\n introduces unexpected dependency from sequences to str/unicode.\n\n\njoin()\n as a free-standing built-in function would support only specific data types. So using a built-in namespace is not good. If \njoin()\n were to support many data types, creating an optimized implementation would be difficult: if implemented using the \n__add__\n method then it would be O(n\u00b2).\n\n\nThe separator string (\nseparator\n) should not be omitted. Explicit is better than implicit.\n\n\n\n\nHere are some additional thoughts (my own, and my friend's):\n\n\n\n\nUnicode support was coming, but it was not final. At that time UTF-8 was the most likely about to replace UCS-2/-4. To calculate total buffer length for UTF-8 strings, the method needs to know the character encoding.\n\n\nAt that time, Python had already decided on a common sequence interface rule where a user could create a sequence-like (iterable) class. But Python didn't support extending built-in types until 2.2. At that time it was difficult to provide basic \niterable\n class (which is mentioned in another comment).\n\n\n\n\nGuido's decision is recorded in a \nhistorical mail\n, deciding on \nseparator.join(items)\n:\n\n\n\n\nFunny, but it does seem right!  Barry, go for it...  \n\n--Guido van Rossum\n\n\n\n", "score": 474}}
{"question": "Why is it string.join(list) instead of list.join(string)?", "tags": ["python", "string", "list"], "link": "https://stackoverflow.com/questions/493819/why-is-it-string-joinlist-instead-of-list-joinstring", "answer_count": 10, "answers": {"id": 493842, "body": "It's because any iterable can be joined (e.g, list, tuple, dict, set), but its contents and the \"joiner\" \nmust be\n strings.\n\n\nFor example:\n\n\n'_'.join(['welcome', 'to', 'stack', 'overflow'])\n'_'.join(('welcome', 'to', 'stack', 'overflow'))\n\n\n\n'welcome_to_stack_overflow'\n\n\n\nUsing something other than strings will raise the following error:\n\n\n\n\nTypeError: sequence item 0: expected str instance, int found\n\n\n\n", "score": 1466}}
{"question": "How do I measure elapsed time in Python?", "tags": ["python", "performance", "measure", "timeit"], "link": "https://stackoverflow.com/questions/7370801/how-do-i-measure-elapsed-time-in-python", "answer_count": 41, "answers": {"id": 21455138, "body": "Python 3 only:\n\n\nSince \ntime.clock()\n \nis deprecated as of Python 3.3\n, you will want to use \ntime.perf_counter()\n for system-wide timing, or \ntime.process_time()\n for process-wide timing, just the way you used to use \ntime.clock()\n:\n\n\nimport time\n\nt = time.process_time()\n#do some stuff\nelapsed_time = time.process_time() - t\n\n\n\nThe new function \nprocess_time\n will not include time elapsed during sleep.\n\n", "score": 258}}
{"question": "How do I measure elapsed time in Python?", "tags": ["python", "performance", "measure", "timeit"], "link": "https://stackoverflow.com/questions/7370801/how-do-i-measure-elapsed-time-in-python", "answer_count": 41, "answers": {"id": 25823885, "body": "Use \ntimeit.default_timer\n instead of \ntimeit.timeit\n. The former provides the best clock available on your platform and version of Python automatically:\n\n\nfrom timeit import default_timer as timer\n\nstart = timer()\n# ...\nend = timer()\nprint(end - start) # Time in seconds, e.g. 5.38091952400282\n\n\n\ntimeit.default_timer\n is assigned to time.time() or time.clock() depending on OS. On Python 3.3+ \ndefault_timer\n is \ntime.perf_counter()\n on all platforms. See \nPython - time.clock() vs. time.time() - accuracy?\n\n\nSee also:\n\n\n\n\nOptimizing code\n\n\nHow to optimize for speed\n\n\n\n", "score": 1213}}
{"question": "How do I measure elapsed time in Python?", "tags": ["python", "performance", "measure", "timeit"], "link": "https://stackoverflow.com/questions/7370801/how-do-i-measure-elapsed-time-in-python", "answer_count": 41, "answers": {"id": 7370824, "body": "Use \ntime.time()\n to measure the elapsed wall-clock time between two points:\n\n\nimport time\n\nstart = time.time()\nprint(\"hello\")\nend = time.time()\nprint(end - start)\n\n\n\nThis gives the execution time in seconds.\n\n\n\n\nAnother option since Python 3.3 might be to use \nperf_counter\n or \nprocess_time\n, depending on your requirements. Before 3.3 it was recommended to use \ntime.clock\n (thanks \nAmber\n). However, it is currently deprecated:\n\n\n\n\nOn Unix, return the current processor time as a floating point number\nexpressed in seconds. The precision, and in fact the very definition\nof the meaning of \u201cprocessor time\u201d, depends on that of the C function\nof the same name.\n\n\nOn Windows, this function returns wall-clock seconds elapsed since the\nfirst call to this function, as a floating point number, based on the\nWin32 function \nQueryPerformanceCounter()\n. The resolution is typically\nbetter than one microsecond.\n\n\nDeprecated since version 3.3\n: The behaviour of this function depends\non the platform: \nuse \nperf_counter()\n or \nprocess_time()\n instead\n,\ndepending on your requirements, to have a well defined behaviour.\n\n\n\n", "score": 2605}}
{"question": "Why is reading lines from stdin much slower in C++ than Python?", "tags": ["python", "c++", "benchmarking", "iostream", "getline"], "link": "https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python", "answer_count": 11, "answers": {"id": 43825662, "body": "I'm a few years behind here, but:\n\n\nIn 'Edit 4/5/6' of the original post, you are using the construction:\n\n\n$ /usr/bin/time cat big_file | program_to_benchmark\n\n\n\nThis is wrong in a couple of different ways:\n\n\n\n\nYou're actually timing the execution of \ncat\n, not your benchmark.  The 'user' and 'sys' CPU usage displayed by \ntime\n are those of \ncat\n, not your benchmarked program.  Even worse, the 'real' time is also not necessarily accurate. Depending on the implementation of \ncat\n and of pipelines in your local OS, it is possible that \ncat\n writes a final giant buffer and exits long before the reader process finishes its work.\n\n\nUse of \ncat\n is unnecessary and in fact counterproductive; you're adding moving parts.  If you were on a sufficiently old system (i.e. with a single CPU and -- in certain generations of computers -- I/O faster than CPU) -- the mere fact that \ncat\n was running could substantially color the results.  You are also subject to whatever input and output buffering and other processing \ncat\n may do.  (This would likely earn you a \n'Useless Use Of Cat'\n award if I were Randal Schwartz.\n\n\n\n\nA better construction would be:\n\n\n$ /usr/bin/time program_to_benchmark < big_file\n\n\n\nIn this statement it is the \nshell\n which opens big_file, passing it to your program (well, actually to \ntime\n which then executes your program as a subprocess) as an already-open file descriptor. 100% of the file reading is strictly the responsibility of the program you're trying to benchmark.  This gets you a real reading of its performance without spurious complications.\n\n\nI will mention two possible, but actually wrong, 'fixes' which could also be considered (but I 'number' them differently as these are not things which were wrong in the original post):\n\n\nA. You could 'fix' this by timing only your program:\n\n\n$ cat big_file | /usr/bin/time program_to_benchmark\n\n\n\nB. or by timing the entire pipeline:\n\n\n$ /usr/bin/time sh -c 'cat big_file | program_to_benchmark'\n\n\n\nThese are wrong for the same reasons as #2: they're still using \ncat\n unnecessarily. I mention them for a few reasons:\n\n\n\n\nthey're more 'natural' for people who aren't entirely comfortable with the I/O redirection facilities of the POSIX shell\n\n\nthere may be cases where \ncat\n \nis\n needed (e.g.: the file to be read requires some sort of privilege to access, and you do not want to grant that privilege to the program to be benchmarked: \nsudo cat /dev/sda | /usr/bin/time my_compression_test --no-output\n)\n\n\nin practice\n, on modern machines, the added \ncat\n in the pipeline is probably of no real consequence.\n\n\n\n\nBut I say that last thing with some hesitation. If we examine the last result in 'Edit 5' --\n\n\n$ /usr/bin/time cat temp_big_file | wc -l\n0.01user 1.34system 0:01.83elapsed 74%CPU ...\n\n\n\n-- this claims that \ncat\n consumed 74% of the CPU during the test; and indeed 1.34/1.83 is approximately 74%.  Perhaps a run of:\n\n\n$ /usr/bin/time wc -l < temp_big_file\n\n\n\nwould have taken only the remaining .49 seconds!  Probably not: \ncat\n here had to pay for the \nread()\n system calls (or equivalent) which transferred the file from 'disk' (actually buffer cache), as well as the pipe writes to deliver them to \nwc\n.  The correct test would still have had to do those \nread()\n calls; only the write-to-pipe and read-from-pipe calls would have been saved, and those should be pretty cheap.\n\n\nStill, I predict you would be able to measure the difference between \ncat file | wc -l\n and \nwc -l < file\n and find a noticeable (2-digit percentage) difference. Each of the slower tests will have paid a similar penalty in absolute time; which would however amount to a smaller fraction of its larger total time.\n\n\nIn fact I did some quick tests with a 1.5 gigabyte file of garbage, on a Linux 3.13 (Ubuntu 14.04) system, obtaining these results (these are actually 'best of 3' results; after priming the cache, of course): \n\n\n$ time wc -l < /tmp/junk\nreal 0.280s user 0.156s sys 0.124s (total cpu 0.280s)\n$ time cat /tmp/junk | wc -l\nreal 0.407s user 0.157s sys 0.618s (total cpu 0.775s)\n$ time sh -c 'cat /tmp/junk | wc -l'\nreal 0.411s user 0.118s sys 0.660s (total cpu 0.778s)\n\n\n\nNotice that the two pipeline results claim to have taken more CPU time (user+sys) than real wall-clock time. This is because I'm using the shell (bash)'s built-in 'time' command, which is cognizant of the pipeline; and I'm on a multi-core machine where separate processes in a pipeline can use separate cores, accumulating CPU time faster than realtime.  Using \n/usr/bin/time\n I see smaller CPU time than realtime -- showing that it can only time the single pipeline element passed to it on its command line. Also, the shell's output gives milliseconds while \n/usr/bin/time\n only gives hundredths of a second.\n\n\nSo at the efficiency level of \nwc -l\n, the \ncat\n makes a huge difference: 409 / 283 = 1.453 or 45.3% more realtime, and 775 / 280 = 2.768, or a whopping 177% more CPU used!  On my random it-was-there-at-the-time test box.\n\n\nI should add that there is at least one other significant difference between these styles of testing, and I can't say whether it is a benefit or fault; you have to decide this yourself:\n\n\nWhen you run \ncat big_file | /usr/bin/time my_program\n, your program is receiving input from a pipe, at precisely the pace sent by \ncat\n, and in chunks no larger than written by \ncat\n.\n\n\nWhen you run \n/usr/bin/time my_program < big_file\n, your program receives an open file descriptor to the actual file.  Your program -- \nor\n in many cases the I/O libraries of the language in which it was written -- may take different actions when presented with a file descriptor referencing a regular file.  It may use \nmmap(2)\n to map the input file into its address space, instead of using explicit \nread(2)\n system calls.  These differences could have a far larger effect on your benchmark results than the small cost of running the \ncat\n binary.\n\n\nOf course it is an interesting benchmark result if the same program performs significantly differently between the two cases. It shows that, indeed, the program or its I/O libraries \nare\n doing something interesting, like using \nmmap()\n. So in practice it might be good to run the benchmarks both ways; perhaps discounting the \ncat\n result by some small factor to \"forgive\" the cost of running \ncat\n itself.\n\n", "score": 218}}
{"question": "Why is reading lines from stdin much slower in C++ than Python?", "tags": ["python", "c++", "benchmarking", "iostream", "getline"], "link": "https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python", "answer_count": 11, "answers": {"id": 9657502, "body": "Just out of curiosity I've taken a look at what happens under the hood, and I've used \ndtruss/strace\n on each test.\n\n\nC++\n\n\n./a.out < in\nSaw 6512403 lines in 8 seconds.  Crunch speed: 814050\n\n\n\nsyscalls \nsudo dtruss -c ./a.out < in\n\n\nCALL                                        COUNT\n__mac_syscall                                   1\n\n\nopen                                            6\npread                                           8\nmprotect                                       17\nmmap                                           22\nstat64                                         30\nread_nocancel                               25958\n\n\n\nPython\n\n\n./a.py < in\nRead 6512402 lines in 1 seconds. LPS: 6512402\n\n\n\nsyscalls \nsudo dtruss -c ./a.py < in\n\n\nCALL                                        COUNT\n__mac_syscall                                   1\n\n\nopen                                            5\npread                                           8\nmprotect                                       17\nmmap                                           21\nstat64                                         29\n\n\n", "score": 224}}
{"question": "Why is reading lines from stdin much slower in C++ than Python?", "tags": ["python", "c++", "benchmarking", "iostream", "getline"], "link": "https://stackoverflow.com/questions/9371238/why-is-reading-lines-from-stdin-much-slower-in-c-than-python", "answer_count": 11, "answers": {"id": 9371717, "body": "tl;dr: Because of different default settings in C++ requiring more system calls.\n\n\nBy default, \ncin\n is synchronized with stdio, which causes it to avoid any input buffering.  If you add this to the top of your main, you should see much better performance:\n\n\nstd::ios_base::sync_with_stdio(false);\n\n\n\nNormally, when an input stream is buffered, instead of reading one character at a time, the stream will be read in larger chunks.  This reduces the number of system calls, which are typically relatively expensive.  However, since the \nFILE*\n based \nstdio\n and \niostreams\n often have separate implementations and therefore separate buffers, this could lead to a problem if both were used together.  For example:\n\n\nint myvalue1;\ncin >> myvalue1;\nint myvalue2;\nscanf(\"%d\",&myvalue2);\n\n\n\nIf more input was read by \ncin\n than it actually needed, then the second integer value wouldn't be available for the \nscanf\n function, which has its own independent buffer.  This would lead to unexpected results.\n\n\nTo avoid this, by default, streams are synchronized with \nstdio\n.  One common way to achieve this is to have \ncin\n read each character one at a time as needed using \nstdio\n functions.  Unfortunately, this introduces a lot of overhead.  For small amounts of input, this isn't a big problem, but when you are reading millions of lines, the performance penalty is significant.\n\n\nFortunately, the library designers decided that you should also be able to disable this feature to get improved performance if you knew what you were doing, so they provided the \nsync_with_stdio\n method. From this link (emphasis added):\n\n\n\n\nIf the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, \nwhich may be considerably faster in some cases\n.\n\n\n\n", "score": 1956}}
{"question": "How to check if the string is empty in Python?", "tags": ["python", "string", "boolean", "is-empty", "comparison-operators"], "link": "https://stackoverflow.com/questions/9573244/how-to-check-if-the-string-is-empty-in-python", "answer_count": 20, "answers": {"id": 9573278, "body": "The most elegant way would probably be to simply check if its true or falsy, e.g.:\n\n\nif not my_string:\n\n\n\nHowever, you may want to strip white space because:\n\n\n >>> bool(\"\")\n False\n >>> bool(\"   \")\n True\n >>> bool(\"   \".strip())\n False\n\n\n\nYou should probably be a bit more explicit in this however, unless you know for sure that this string has passed some kind of validation and is a string that can be tested this way.\n\n", "score": 358}}
{"question": "How to check if the string is empty in Python?", "tags": ["python", "string", "boolean", "is-empty", "comparison-operators"], "link": "https://stackoverflow.com/questions/9573244/how-to-check-if-the-string-is-empty-in-python", "answer_count": 20, "answers": {"id": 9573283, "body": "From \nPEP 8\n, in the \n\u201cProgramming Recommendations\u201d section\n:\n\n\n\n\nFor sequences, (strings, lists, tuples), use the fact that empty sequences are false.\n\n\n\n\nSo you should use:\n\n\nif not some_string:\n\n\n\nor:\n\n\nif some_string:\n\n\n\nJust to clarify, sequences are \nevaluated\n to \nFalse\n or \nTrue\n in a Boolean context if they are empty or not. They are \nnot equal\n to \nFalse\n or \nTrue\n.\n\n", "score": 564}}
{"question": "How to check if the string is empty in Python?", "tags": ["python", "string", "boolean", "is-empty", "comparison-operators"], "link": "https://stackoverflow.com/questions/9573244/how-to-check-if-the-string-is-empty-in-python", "answer_count": 20, "answers": {"id": 9573259, "body": "Empty strings are \"falsy\" (\npython 2\n or \npython 3\n reference), which means they are considered false in a Boolean context, so you can just do this:\n\n\nif not myString:\n\n\n\nThis is the preferred way if you know that your variable is a string.  If your variable could also be some other type then you should use:\n\n\nif myString == \"\":\n\n\n\nSee the documentation on \nTruth Value Testing\n for other values that are false in Boolean contexts.\n\n", "score": 3147}}
{"question": "Determine the type of an object?", "tags": ["python", "dictionary", "types", "typeof"], "link": "https://stackoverflow.com/questions/2225038/determine-the-type-of-an-object", "answer_count": 15, "answers": {"id": 2225081, "body": "It might be more Pythonic to use a \ntry\n...\nexcept\n block. That way, if you have a class which quacks like a list, or quacks like a dict, it will behave properly regardless of what its type \nreally\n is.\n\n\nTo clarify, the preferred method of \"telling the difference\" between variable types is with something called \nduck typing\n: as long as the methods (and return types) that a variable responds to are what your subroutine expects, treat it like what you expect it to be. For example, if you have a class that overloads the bracket operators with \ngetattr\n and \nsetattr\n, but uses some funny internal scheme, it would be appropriate for it to behave as a dictionary if that's what it's trying to emulate.\n\n\nThe other problem with the \ntype(A) is type(B)\n checking is that if \nA\n is a subclass of \nB\n, it evaluates to \nfalse\n when, programmatically, you would hope it would be \ntrue\n. If an object is a subclass of a list, it should work like a list: checking the type as presented in the other answer will prevent this. (\nisinstance\n will work, however).\n\n", "score": 45}}
{"question": "Determine the type of an object?", "tags": ["python", "dictionary", "types", "typeof"], "link": "https://stackoverflow.com/questions/2225038/determine-the-type-of-an-object", "answer_count": 15, "answers": {"id": 2225055, "body": "Use \ntype()\n:\n\n\n>>> a = []\n>>> type(a)\n\n\n>>> f = ()\n>>> type(f)\n\n\n\n\n", "score": 233}}
{"question": "Determine the type of an object?", "tags": ["python", "dictionary", "types", "typeof"], "link": "https://stackoverflow.com/questions/2225038/determine-the-type-of-an-object", "answer_count": 15, "answers": {"id": 2225066, "body": "There are two built-in functions that help you identify the type of an object. You can use \ntype()\n  if you need the exact type of an object, and \nisinstance()\n to \ncheck\n an object\u2019s type against something. Usually, you want to use \nisinstance()\n most of the times since it is very robust and also supports type inheritance.\n\n\n\n\nTo get the actual type of an object, you use the built-in \ntype()\n function. Passing an object as the only parameter will return the type object of that object:\n\n\n>>> type([]) is list\nTrue\n>>> type({}) is dict\nTrue\n>>> type('') is str\nTrue\n>>> type(0) is int\nTrue\n\n\n\nThis of course also works for custom types:\n\n\n>>> class Test1 (object):\n        pass\n>>> class Test2 (Test1):\n        pass\n>>> a = Test1()\n>>> b = Test2()\n>>> type(a) is Test1\nTrue\n>>> type(b) is Test2\nTrue\n\n\n\nNote that \ntype()\n will only return the immediate type of the object, but won\u2019t be able to tell you about type inheritance.\n\n\n>>> type(b) is Test1\nFalse\n\n\n\nTo cover that, you should use the \nisinstance\n function. This of course also works for built-in types:\n\n\n>>> isinstance(b, Test1)\nTrue\n>>> isinstance(b, Test2)\nTrue\n>>> isinstance(a, Test1)\nTrue\n>>> isinstance(a, Test2)\nFalse\n>>> isinstance([], list)\nTrue\n>>> isinstance({}, dict)\nTrue\n\n\n\nisinstance()\n is usually the preferred way to ensure the type of an object because it will also accept derived types. So unless you actually need the type object (for whatever reason), using \nisinstance()\n is preferred over \ntype()\n.\n\n\nThe second parameter of \nisinstance()\n also accepts a tuple of types, so it\u2019s possible to check for multiple types at once. \nisinstance\n will then return true, if the object is of any of those types:\n\n\n>>> isinstance([], (tuple, list, set))\nTrue\n\n\n", "score": 2387}}
{"question": "How do I count the occurrences of a list item?", "tags": ["python", "list", "count"], "link": "https://stackoverflow.com/questions/2600191/how-do-i-count-the-occurrences-of-a-list-item", "answer_count": 29, "answers": {"id": 23909767, "body": "Counting the occurrences of one item in a list\n\n\nFor counting the occurrences of just one list item you can use \ncount()\n\n\n>>> l = [\"a\",\"b\",\"b\"]\n>>> l.count(\"a\")\n1\n>>> l.count(\"b\")\n2\n\n\n\nCounting the occurrences of \nall\n items in a list is also known as \"tallying\" a list, or creating a tally counter.\n\n\nCounting all items with count()\n\n\nTo count the occurrences of items in \nl\n one can simply use a list comprehension and the \ncount()\n method\n\n\n[[x,l.count(x)] for x in set(l)]\n\n\n\n(or similarly with a dictionary \ndict((x,l.count(x)) for x in set(l))\n)\n\n\nExample: \n\n\n>>> l = [\"a\",\"b\",\"b\"]\n>>> [[x,l.count(x)] for x in set(l)]\n[['a', 1], ['b', 2]]\n>>> dict((x,l.count(x)) for x in set(l))\n{'a': 1, 'b': 2}\n\n\n\nCounting all items with Counter()\n\n\nAlternatively, there's the faster \nCounter\n class from the \ncollections\n library\n\n\nCounter(l)\n\n\n\nExample:\n\n\n>>> l = [\"a\",\"b\",\"b\"]\n>>> from collections import Counter\n>>> Counter(l)\nCounter({'b': 2, 'a': 1})\n\n\n\nHow much faster is Counter?\n\n\nI checked how much faster \nCounter\n is for tallying lists. I tried both methods out with a few values of \nn\n and it appears that \nCounter\n is faster by a constant factor of approximately 2.\n\n\nHere is the script I used:\n\n\nfrom __future__ import print_function\nimport timeit\n\nt1=timeit.Timer('Counter(l)', \\\n                'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in range(n)]'\n                )\n\nt2=timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n                'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in range(n)]'\n                )\n\nprint(\"Counter(): \", t1.repeat(repeat=3,number=10000))\nprint(\"count():   \", t2.repeat(repeat=3,number=10000)\n\n\n\nAnd the output:\n\n\nCounter():  [0.46062711701961234, 0.4022796869976446, 0.3974247490405105]\ncount():    [7.779430688009597, 7.962715800967999, 8.420845870045014]\n\n\n", "score": 373}}
{"question": "How do I count the occurrences of a list item?", "tags": ["python", "list", "count"], "link": "https://stackoverflow.com/questions/2600191/how-do-i-count-the-occurrences-of-a-list-item", "answer_count": 29, "answers": {"id": 5829377, "body": "Use \nCounter\n if you are using Python 2.7 or 3.x and you want the number of occurrences for each element:\n\n\n>>> from collections import Counter\n>>> z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\n>>> Counter(z)\nCounter({'blue': 3, 'red': 2, 'yellow': 1})\n\n\n", "score": 2445}}
{"question": "How do I count the occurrences of a list item?", "tags": ["python", "list", "count"], "link": "https://stackoverflow.com/questions/2600191/how-do-i-count-the-occurrences-of-a-list-item", "answer_count": 29, "answers": {"id": 2600208, "body": "If you only want a single item's count, use the \ncount\n method:\n\n\n>>> [1, 2, 3, 4, 1, 4, 1].count(1)\n3\n\n\n\n\n\nImportant: this is very slow if you are counting \nmultiple\n different items\n\n\nEach \ncount\n call goes over the entire list of \nn\n elements. Calling \ncount\n in a loop \nn\n times means \nn * n\n total checks, which can be catastrophic for performance.\n\n\nIf you want to count multiple items, use \nCounter\n, which only does \nn\n total checks.\n\n", "score": 2555}}
{"question": "What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?", "tags": ["python", "virtualenv", "virtualenvwrapper", "pyenv", "python-venv"], "link": "https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe", "answer_count": 8, "answers": {"id": 59923461, "body": "UPDATE 2020-08-25:\n\n\nAdded below \"\nConclusion\n\" paragraph\n\n\nI've went down the \npipenv\n rabbit hole (\nit's a deep and dark hole indeed...\n) and \nsince the last answer is over 2 years ago\n, felt it was useful to update the discussion with the latest developments on the Python virtual envelopes topic I've found.\n\n\nDISCLAIMER:\n\n\nThis answer is \nNOT\n about continuing the raging debate about the merits of \npipenv\n \nversus\n \nvenv\n as envelope solutions- \nI make no endorsement of either\n. It's about \nPyPA\n endorsing conflicting standards and how future development of \nvirtualenv\n promises to negate making an \neither/or\n choice between them at all. I focused on these two tools precisely because they are the anointed ones by \nPyPA\n.\n\n\n\n\nvenv\n\n\nAs the OP notes, \nvenv\n is a tool for virtualizing environments. \nNOT\n a third party solution, but native tool. \nPyPA\n endorses \nvenv\n for creating \nVIRTUAL ENVELOPES\n: \"\nChanged in version 3.5: The use of venv is now recommended for creating virtual environments\n\".\n\n\npipenv\n\n\npipenv\n- like \nvenv\n - can be used to create virtual envelopes but additionally rolls-in package management and \nvulnerability checking\n functionality. Instead of using \nrequirements.txt\n, \npipenv\n delivers package management via \nPipfile\n.  As \nPyPA\n endorses pipenv for \nPACKAGE MANAGEMENT\n, that would seem to imply \npipfile\n is to supplant \nrequirements.txt\n.\n\n\nHOWEVER\n: \npipenv\n uses \nvirtualenv\n as its tool for creating virtual envelopes, \nNOT\n \nvenv\n which is endorsed by \nPyPA\n as the go-to tool for creating virtual envelopes.\n\n\nConflicting Standards:\n\n\nSo if settling on a virtual envelope solution wasn't difficult enough, we now have \nPyPA\n endorsing two different tools which use different virtual envelope solutions. The raging Github debate on \nvenv vs virtualenv\n which highlights this conflict can be found \nhere\n.\n\n\nConflict Resolution:\n\n\nThe Github debate referenced in above link has steered \nvirtualenv\n development in the direction of accommodating \nvenv\n in \nfuture releases\n:\n\n\n\n\nprefer built-in venv: if the target python has venv we'll create the\nenvironment using that (and then perform subsequent operations on that\nto facilitate other guarantees we offer)\n\n\n\n\n\n\nConclusion:\n\n\nSo it looks like there will be some future convergence between the two rival virtual envelope solutions, but as of now \npipenv\n- which uses \nvirtualenv\n - varies materially from \nvenv\n.\n\n\nGiven \nthe problems \npipenv\n solves\n and the fact that \nPyPA\n has given its blessing, it \nappears\n to have a bright future. And if \nvirtualenv\n delivers on its proposed development objectives, choosing a virtual envelope solution should no longer be a case of either \npipenv\n OR \nvenv\n.\n\n\nUpdate 2020-08-25:\n\n\nAn oft repeated criticism of \nPipenv\n I saw when producing this analysis was that it was not actively maintained. Indeed, what's the point of using a solution whose future could be seen questionable due to lack of continuous development? After a dry spell of about 18 months, \nPipenv\n is once again being actively developed. Indeed, large and material updates have since been \nreleased\n.\n\n", "score": 129}}
{"question": "What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?", "tags": ["python", "virtualenv", "virtualenvwrapper", "pyenv", "python-venv"], "link": "https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe", "answer_count": 8, "answers": {"id": 47559925, "body": "I would just avoid the use of \nvirtualenv\n after Python3.3+ and instead use the standard shipped library \nvenv\n. To create a new virtual environment you would type:\n\n\n$ python3 -m venv \n  \n\n\n\nvirtualenv\n tries to copy the Python binary into the virtual environment's bin directory. However it does not update library file links embedded into that binary, so if you build Python from source into a non-system directory with relative path names, the Python binary breaks. Since this is how you make a copy distributable Python, it is a big flaw. BTW to inspect embedded library file links on OS X, use \notool\n. For example from within your virtual environment, type:\n\n\n$ otool -L bin/python\npython:\n    @executable_path/../Python (compatibility version 3.4.0, current version 3.4.0)\n    /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1238.0.0)\n\n\n\nConsequently I would avoid \nvirtualenvwrapper\n and \npipenv\n. \npyvenv\n is deprecated. \npyenv\n seems to be used often where \nvirtualenv\n is used but I would stay away from it also since I think \nvenv\n also does what \npyenv\n is built for.\n\n\nvenv\n creates virtual environments in the shell that are \nfresh\n and \nsandboxed\n, with \nuser-installable libraries\n, and it's \nmulti-python safe\n.\n\n\nFresh\n: because virtual environments only start with the standard libraries that ship with python, you have to install any other libraries all over again with \npip install\n while the virtual environment is active.\n\n\nSandboxed\n: because none of these new library installs are visible outside the virtual environment, so you can delete the whole environment and start again without worrying about impacting your base python install.\n\n\nUser-installable libraries\n: because the virtual environment's target folder is created without \nsudo\n in some directory you already own, so you won't need \nsudo\n permissions to install libraries into it.\n\n\nmulti-python safe\n: because when virtual environments activate, the shell only sees the python version (3.4, 3.5 etc.) that was used to build that virtual environment.\n\n\npyenv\n is similar to \nvenv\n in that it lets you manage multiple python environments. However with \npyenv\n you can't conveniently rollback library installs to some start state and you will likely need \nadmin\n privileges at some point to update libraries. So I think it is also best to use \nvenv\n.\n\n\nIn the last couple of years I have found many problems in build systems (emacs packages, python standalone application builders, installers...) that ultimately come down to issues with \nvirtualenv\n. I think python will be a better platform when we eliminate this additional option and only use \nvenv\n.\n\n\nEDIT: Tweet of the BDFL,\n\n\n\n\nI use venv (in the stdlib) and a bunch of shell aliases to quickly switch.\n\n\n\u2014 Guido van Rossum (@gvanrossum) \nOctober 22, 2020\n\n\n\n", "score": 630}}
{"question": "What is the difference between venv, pyvenv, pyenv, virtualenv, virtualenvwrapper, pipenv, etc?", "tags": ["python", "virtualenv", "virtualenvwrapper", "pyenv", "python-venv"], "link": "https://stackoverflow.com/questions/41573587/what-is-the-difference-between-venv-pyvenv-pyenv-virtualenv-virtualenvwrappe", "answer_count": 8, "answers": {"id": 41573588, "body": "This is my personal recommendation for beginners:\n start by learning \nvirtualenv\n and \npip\n, tools which work with both Python 2 and 3 and in a variety of situations, and pick up other tools once you start needing them.\n\n\nNow on to answer the question: what is the difference between these similarly named things: venv, virtualenv, etc?\n\n\nPyPI packages not in the standard library:\n\n\n\n\nvirtualenv\n is a very popular tool that creates isolated Python environments for Python libraries. If you're not familiar with this tool, I highly recommend learning it, as it is a very useful tool.\n\n\nIt works by installing a bunch of files in a directory (eg: \nenv/\n), and then modifying the \nPATH\n environment variable to prefix it with a custom \nbin\n directory (eg: \nenv/bin/\n). An exact copy of the \npython\n or \npython3\n binary is placed in this directory, but Python is programmed to look for libraries relative to its path first, in the environment directory. It's not part of Python's standard library, but is officially blessed by the PyPA (Python Packaging Authority). Once activated, you can install packages in the virtual environment using \npip\n.\n\n\n\n\npyenv\n is used to isolate Python versions. For example, you may want to test your code against Python 2.7, 3.6, 3.7 and 3.8, so you'll need a way to switch between them. Once activated, it prefixes the \nPATH\n environment variable with \n~/.pyenv/shims\n, where there are special files matching the Python commands (\npython\n, \npip\n). These are not copies of the Python-shipped commands; they are special scripts that decide on the fly which version of Python to run based on the \nPYENV_VERSION\n environment variable, or the \n.python-version\n file, or the \n~/.pyenv/version\n file. \npyenv\n also makes the process of downloading and installing multiple Python versions easier, using the command \npyenv install\n.\n\n\n\n\npyenv-virtualenv\n is a plugin for \npyenv\n by the same author as \npyenv\n, to allow you to use \npyenv\n and \nvirtualenv\n at the same time conveniently. However, if you're using Python 3.3 or later, \npyenv-virtualenv\n will try to run \npython -m venv\n if it is available, instead of \nvirtualenv\n. You can use \nvirtualenv\n and \npyenv\n together without \npyenv-virtualenv\n, if you don't want the convenience features.\n\n\n\n\nvirtualenvwrapper\n is a set of extensions to \nvirtualenv\n (see \ndocs\n). It gives you commands like \nmkvirtualenv\n, \nlssitepackages\n, and especially \nworkon\n for switching between different \nvirtualenv\n directories. This tool is especially useful if you want multiple \nvirtualenv\n directories.\n\n\n\n\npyenv-virtualenvwrapper\n is a plugin for \npyenv\n by the same author as \npyenv\n, to conveniently integrate \nvirtualenvwrapper\n into \npyenv\n.\n\n\n\n\npipenv\n aims to combine \nPipfile\n, \npip\n and \nvirtualenv\n into one command on the command-line. The \nvirtualenv\n directory typically gets placed in \n~/.local/share/virtualenvs/XXX\n, with \nXXX\n being a hash of the path of the project directory. This is different from \nvirtualenv\n, where the directory is typically in the current working directory. \npipenv\n is meant to be used when developing Python applications (as opposed to libraries). There are alternatives to \npipenv\n, such as \npoetry\n, which I won't list here since this question is only about the packages that are similarly named.\n\n\n\n\n\n\nStandard library:\n\n\n\n\npyvenv\n (not to be confused with \npyenv\n in the previous section) is a script shipped with Python 3.3 to 3.7. It was \nremoved from Python 3.8\n as it had problems (not to mention the confusing name). Running \npython3 -m venv\n has exactly the same effect as \npyvenv\n.\n\n\n\n\nvenv\n is a package shipped with Python 3, which you can run using \npython3 -m venv\n (although for some reason some distros separate it out into a separate distro package, such as \npython3-venv\n on Ubuntu/Debian). It serves the same purpose as \nvirtualenv\n, but only has a subset of its features (\nsee a comparison here\n). \nvirtualenv\n continues to be more popular than \nvenv\n, especially since the former supports both Python 2 and 3.\n\n\n\n\n\n", "score": 2437}}
{"question": "How can I determine a Python variable&#39;s type?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/402504/how-can-i-determine-a-python-variables-type", "answer_count": 22, "answers": {"id": 32885953, "body": "It is so simple. You do it like this.\n\n\nprint(type(variable_name))\n\n\n", "score": 214}}
{"question": "How can I determine a Python variable&#39;s type?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/402504/how-can-i-determine-a-python-variables-type", "answer_count": 22, "answers": {"id": 402507, "body": "You may be looking for the \ntype()\n \nbuilt-in function\n.\n\n\nSee the examples below, but there's no \"unsigned\" type in Python just like Java.\n\n\nPositive integer:\n\n\n>>> v = 10\n>>> type(v)\n\n\n\n\n\nLarge\n positive integer:\n\n\n>>> v = 100000000000000\n>>> type(v)\n\n\n\n\n\nNegative integer:\n\n\n>>> v = -10\n>>> type(v)\n\n\n\n\n\nLiteral sequence of characters:\n\n\n>>> v = 'hi'\n>>> type(v)\n\n\n\n\n\nFloating point number:\n\n\n>>> v = 3.14159\n>>> type(v)\n\n\n\n\n", "score": 530}}
{"question": "How can I determine a Python variable&#39;s type?", "tags": ["python", "types"], "link": "https://stackoverflow.com/questions/402504/how-can-i-determine-a-python-variables-type", "answer_count": 22, "answers": {"id": 402704, "body": "Use the \ntype()\n built-in function:\n\n\n>>> i = 123\n>>> type(i)\n\n\n>>> type(i) is int\nTrue\n>>> i = 123.456\n>>> type(i)\n\n\n>>> type(i) is float\nTrue\n\n\n\nTo check if a variable is of a given type, use \nisinstance\n:\n\n\n>>> i = 123\n>>> isinstance(i, int)\nTrue\n>>> isinstance(i, (float, str, set, dict))\nFalse\n\n\n\nNote that Python doesn't have the same types as C/C++, which appears to be your question.\n\n", "score": 2094}}
{"question": "Delete an element from a dictionary", "tags": ["python", "dictionary", "del"], "link": "https://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary", "answer_count": 20, "answers": {"id": 5844700, "body": "I think your solution is best way to do it. But if you want another solution, you can create a new dictionary with using the keys from old dictionary without including your specified key, like this:\n\n\n>>> a\n{0: 'zero', 1: 'one', 2: 'two', 3: 'three'}\n>>> {i:a[i] for i in a if i!=0}\n{1: 'one', 2: 'two', 3: 'three'}\n\n\n", "score": 119}}
{"question": "Delete an element from a dictionary", "tags": ["python", "dictionary", "del"], "link": "https://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary", "answer_count": 20, "answers": {"id": 22564121, "body": "pop\n mutates the dictionary.\n\n\n >>> lol = {\"hello\": \"gdbye\"}\n >>> lol.pop(\"hello\")\n     'gdbye'\n >>> lol\n     {}\n\n\n\nIf you want to keep the original you could just copy it.\n\n", "score": 529}}
{"question": "Delete an element from a dictionary", "tags": ["python", "dictionary", "del"], "link": "https://stackoverflow.com/questions/5844672/delete-an-element-from-a-dictionary", "answer_count": 20, "answers": {"id": 5844692, "body": "The \ndel\n statement\n removes an element:\n\n\ndel d[key]\n\n\n\nNote that this mutates the existing dictionary, so the contents of the dictionary changes for anybody else who has a reference to the same instance. To return a \nnew\n dictionary, make a copy of the dictionary:\n\n\ndef removekey(d, key):\n    r = dict(d)\n    del r[key]\n    return r\n\n\n\nThe \ndict()\n constructor makes a \nshallow copy\n. To make a deep copy, see the \ncopy\n module\n.\n\n\n\n\nNote that making a copy for every dict \ndel\n/assignment/etc. means you're going from constant time to linear time, and also using linear space. For small dicts, this is not a problem. But if you're planning to make lots of copies of large dicts, you probably want a different data structure, like a HAMT (as described in \nthis answer\n).\n\n", "score": 2567}}
{"question": "How do I pad a string with zeros?", "tags": ["python", "string", "zero-padding"], "link": "https://stackoverflow.com/questions/339007/how-do-i-pad-a-string-with-zeros", "answer_count": 19, "answers": {"id": 24386708, "body": "For Python 3.6+ using \nf-strings\n:\n\n\n>>> i = 1\n>>> f\"{i:0>2}\"  # Works for both numbers and strings.\n'01'\n>>> f\"{i:02}\"  # Works only for numbers.\n'01'\n\n\n\nFor \nPython 2.6\n to Python 3.5:\n\n\n>>> \"{:0>2}\".format(\"1\")  # Works for both numbers and strings.\n'01'\n>>> \"{:02}\".format(1)  # Works only for numbers.\n'01'\n\n\n\nThose \nstandard format specifiers\n are \n[[fill]align][minimumwidth]\n and \n[0][minimumwidth]\n.\n\n", "score": 258}}
{"question": "How do I pad a string with zeros?", "tags": ["python", "string", "zero-padding"], "link": "https://stackoverflow.com/questions/339007/how-do-i-pad-a-string-with-zeros", "answer_count": 19, "answers": {"id": 339024, "body": "Just use the \nrjust\n method of the string object.\n\n\nThis example creates a 10-character length string, padding as necessary:\n\n\n>>> s = 'test'\n>>> s.rjust(10, '0')\n>>> '000000test'\n\n\n", "score": 502}}
{"question": "How do I pad a string with zeros?", "tags": ["python", "string", "zero-padding"], "link": "https://stackoverflow.com/questions/339007/how-do-i-pad-a-string-with-zeros", "answer_count": 19, "answers": {"id": 339013, "body": "To pad strings:\n\n\n>>> n = '4'\n>>> print(n.zfill(3))\n004\n\n\n\nTo pad numbers:\n\n\n>>> n = 4\n>>> print(f'{n:03}') # Preferred method, python >= 3.6\n004\n>>> print('%03d' % n)\n004\n>>> print(format(n, '03')) # python >= 2.6\n004\n>>> print('{0:03d}'.format(n))  # python >= 2.6 + python 3\n004\n>>> print('{foo:03d}'.format(foo=n))  # python >= 2.6 + python 3\n004\n>>> print('{:03d}'.format(n))  # python >= 2.7 + python3\n004\n\n\n\nString formatting documentation\n.\n\n", "score": 3485}}
{"question": "How do I get the number of elements in a list (length of a list) in Python?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/1712227/how-do-i-get-the-number-of-elements-in-a-list-length-of-a-list-in-python", "answer_count": 11, "answers": {"id": 16114025, "body": "While this may not be useful due to the fact that it'd make a lot more sense as being \"out of the box\" functionality, a fairly simple hack would be to build a class with a \nlength\n property:\n\n\nclass slist(list):\n    @property\n    def length(self):\n        return len(self)\n\n\n\nYou can use it like so:\n\n\n>>> l = slist(range(10))\n>>> l.length\n10\n>>> print l\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nEssentially, it's exactly identical to a list object, with the added benefit of having an OOP-friendly \nlength\n property.\n\n\nAs always, your mileage may vary.\n\n", "score": 80}}
{"question": "How do I get the number of elements in a list (length of a list) in Python?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/1712227/how-do-i-get-the-number-of-elements-in-a-list-length-of-a-list-in-python", "answer_count": 11, "answers": {"id": 27137427, "body": "\n\nHow do I get the length of a list?\n\n\n\n\nTo find the number of elements in a list, use the builtin function \nlen\n:\n\n\nitems = []\nitems.append(\"apple\")\nitems.append(\"orange\")\nitems.append(\"banana\")\n\n\n\nAnd now:\n\n\nlen(items)\n\n\n\nreturns 3.\n\n\nExplanation\n\n\nEverything in Python is an object, including lists. All objects have a header of some sort in the C implementation.\n\n\nLists and other similar builtin objects with a \"size\" in Python, in particular, have an attribute called \nob_size\n, where the number of elements in the object is cached. So checking the number of objects in a list is very fast.\n\n\nBut if you're checking if list size is zero or not, don't use \nlen\n - instead, put the list in a boolean context - \nit is treated as False if empty, and True if non-empty\n.\n\n\nFrom the \ndocs\n\n\nlen(s)\n\n\n\n\nReturn the length (the number of items) of an object. The argument may be a sequence (such as a string, bytes, tuple, list, or range) or\na collection (such as a dictionary, set, or frozen set).\n\n\n\n\nlen\n is implemented with \n__len__\n, from the data model \ndocs\n:\n\n\nobject.__len__(self)\n\n\n\n\nCalled to implement the built-in function \nlen()\n. Should return the length of the object, an integer >= 0. Also, an object that doesn\u2019t\ndefine a \n__nonzero__()\n [in Python 2 or \n__bool__()\n in Python 3] method and whose \n__len__()\n method returns zero\nis considered to be false in a Boolean context.\n\n\n\n\nAnd we can also see that \n__len__\n is a method of lists:\n\n\nitems.__len__()\n\n\n\nreturns 3.\n\n\nBuiltin types you can get the \nlen\n (length) of\n\n\nAnd in fact we see we can get this information for all of the described types:\n\n\n>>> all(hasattr(cls, '__len__') for cls in (str, bytes, tuple, list, \n                                            range, dict, set, frozenset))\nTrue\n\n\n\nDo not use \nlen\n to test for an empty or nonempty list\n\n\nTo test for a specific length, of course, simply test for equality:\n\n\nif len(items) == required_length:\n    ...\n\n\n\nBut there's a special case for testing for a zero length list or the inverse. In that case, do not test for equality.\n\n\nAlso, do not do:\n\n\nif len(items): \n    ...\n\n\n\nInstead, simply do:\n\n\nif items:     # Then we have some items, not empty!\n    ...\n\n\n\nor\n\n\nif not items: # Then we have an empty list!\n    ...\n\n\n\nI \nexplain why here\n but in short, \nif items\n or \nif not items\n is more readable and performant than other alternatives.\n\n", "score": 318}}
{"question": "How do I get the number of elements in a list (length of a list) in Python?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/1712227/how-do-i-get-the-number-of-elements-in-a-list-length-of-a-list-in-python", "answer_count": 11, "answers": {"id": 1712236, "body": "The \nlen()\n function can be used with several different types in Python - both built-in types and library types. For example:\n\n\n>>> len([1, 2, 3])\n3\n\n\n", "score": 2973}}
{"question": "Delete a column from a Pandas DataFrame", "tags": ["python", "pandas", "dataframe", "del"], "link": "https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe", "answer_count": 23, "answers": {"id": 22596982, "body": "Use:\n\n\ncolumns = ['Col1', 'Col2', ...]\ndf.drop(columns, inplace=True, axis=1)\n\n\n\nThis will delete one or more columns in-place. Note that \ninplace=True\n was added in pandas v0.13 and won't work on older versions. You'd have to assign the result back in that case:\n\n\ndf = df.drop(columns, axis=1)\n\n\n", "score": 318}}
{"question": "Delete a column from a Pandas DataFrame", "tags": ["python", "pandas", "dataframe", "del"], "link": "https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe", "answer_count": 23, "answers": {"id": 13485766, "body": "As you've guessed, the right syntax is \n\n\ndel df['column_name']\n\n\n\nIt's difficult to make \ndel df.column_name\n work simply as the result of syntactic limitations in Python. \ndel df[name]\n gets translated to \ndf.__delitem__(name)\n under the covers by Python.\n\n", "score": 1332}}
{"question": "Delete a column from a Pandas DataFrame", "tags": ["python", "pandas", "dataframe", "del"], "link": "https://stackoverflow.com/questions/13411544/delete-a-column-from-a-pandas-dataframe", "answer_count": 23, "answers": {"id": 18145399, "body": "The best way to do this in Pandas is to use \ndrop\n:\n\n\ndf = df.drop('column_name', axis=1)\n\n\n\nwhere \n1\n is the \naxis\n number (\n0\n for rows and \n1\n for columns.)\n\n\nOr, the \ndrop()\n method accepts \nindex\n/\ncolumns\n keywords as an alternative to specifying the axis. So we can now just do:\n\n\ndf = df.drop(columns=['column_nameA', 'column_nameB'])\n\n\n\n\n\nThis was \nintroduced in v0.21.0\n (October 27, 2017)\n\n\n\n\nTo delete the column without having to reassign \ndf\n you can do:\n\n\ndf.drop('column_name', axis=1, inplace=True)\n\n\n\nFinally, to drop by column \nnumber\n instead of by column \nlabel\n, try this to delete, e.g. the 1st, 2nd and 4th columns:\n\n\ndf = df.drop(df.columns[[0, 1, 3]], axis=1)  # df.columns is zero-based pd.Index\n\n\n\nAlso working with \"text\" syntax for the columns:\n\n\ndf.drop(['column_nameA', 'column_nameB'], axis=1, inplace=True)\n\n\n", "score": 3717}}
{"question": "How to remove an element from a list by index", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/627435/how-to-remove-an-element-from-a-list-by-index", "answer_count": 18, "answers": {"id": 24352671, "body": "Like others mentioned pop and del are \nthe\n efficient ways to remove an item of given index. Yet just for the sake of completion (since the same thing can be done via many ways in Python):\n\n\nUsing slices (this does not do in place removal of item from original list):\n\n\n(Also this will be the least efficient method when working with Python list, but this could be useful (but not efficient, I reiterate) when working with user defined objects that do not support pop, yet do define a \n__getitem__\n ):\n\n\n>>> a = [1, 2, 3, 4, 5, 6]\n>>> index = 3 # Only positive index\n\n>>> a = a[:index] + a[index+1 :]\n# a is now [1, 2, 3, 5, 6]\n\n\n\nNote:\n Please note that this method does not modify the list in place like \npop\n and \ndel\n. It instead makes two copies of lists (one from the start until the index but without it (\na[:index]\n) and one after the index till the last element (\na[index+1:]\n)) and creates a new list object by adding both. This is then reassigned to the list variable (\na\n). The old list object is hence dereferenced and hence garbage collected (provided the original list object is not referenced by any variable other than a).\n\n\nThis makes this method very inefficient and it can also produce undesirable side effects (especially when other variables point to the original list object which remains un-modified).\n\n\nThanks to @MarkDickinson for pointing this out ...\n\n\nThis\n Stack Overflow answer explains the concept of slicing.\n\n\nAlso note that this works only with positive indices.\n\n\nWhile using with objects, the \n__getitem__\n method must have been defined and more importantly the \n__add__\n method must have been defined to return an object containing items from both the operands.\n\n\nIn essence, this works with any object whose class definition is like:\n\n\nclass foo(object):\n    def __init__(self, items):\n        self.items = items\n\n    def __getitem__(self, index):\n        return foo(self.items[index])\n\n    def __add__(self, right):\n        return foo( self.items + right.items )\n\n\n\nThis works with \nlist\n which defines \n__getitem__\n and \n__add__\n methods.\n\n\nComparison of the three ways in terms of efficiency:\n\n\nAssume the following is predefined:\n\n\na = range(10)\nindex = 3\n\n\n\nThe \ndel object[index]\n method:\n\n\nBy far the most efficient method. It works will all objects that define a \n__del__\n method.\n\n\nThe disassembly is as follows:\n\n\nCode:\n\n\ndef del_method():\n    global a\n    global index\n    del a[index]\n\n\n\nDisassembly:\n\n\n 10    0 LOAD_GLOBAL     0 (a)\n       3 LOAD_GLOBAL     1 (index)\n       6 DELETE_SUBSCR   # This is the line that deletes the item\n       7 LOAD_CONST      0 (None)\n      10 RETURN_VALUE\nNone\n\n\n\npop\n method:\n\n\nIt is less efficient than the del method and is used when you need to get the deleted item.\n\n\nCode:\n\n\ndef pop_method():\n    global a\n    global index\n    a.pop(index)\n\n\n\nDisassembly:\n\n\n 17     0 LOAD_GLOBAL     0 (a)\n        3 LOAD_ATTR       1 (pop)\n        6 LOAD_GLOBAL     2 (index)\n        9 CALL_FUNCTION   1\n       12 POP_TOP\n       13 LOAD_CONST      0 (None)\n       16 RETURN_VALUE\n\n\n\nThe slice and add method.\n\n\nThe least efficient.\n\n\nCode:\n\n\ndef slice_method():\n    global a\n    global index\n    a = a[:index] + a[index+1:]\n\n\n\nDisassembly:\n\n\n 24     0 LOAD_GLOBAL    0 (a)\n        3 LOAD_GLOBAL    1 (index)\n        6 SLICE+2\n        7 LOAD_GLOBAL    0 (a)\n       10 LOAD_GLOBAL    1 (index)\n       13 LOAD_CONST     1 (1)\n       16 BINARY_ADD\n       17 SLICE+1\n       18 BINARY_ADD\n       19 STORE_GLOBAL   0 (a)\n       22 LOAD_CONST     0 (None)\n       25 RETURN_VALUE\nNone\n\n\n\nNote: In all three disassembles ignore the last two lines which basically are \nreturn None\n. Also the first two lines are loading the global values \na\n and \nindex\n.\n\n", "score": 197}}
{"question": "How to remove an element from a list by index", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/627435/how-to-remove-an-element-from-a-list-by-index", "answer_count": 18, "answers": {"id": 627441, "body": "You probably want \npop\n:\n\n\na = ['a', 'b', 'c', 'd']\na.pop(1)\n\n# now a is ['a', 'c', 'd']\n\n\n\nBy default, \npop\n without any arguments removes the last item:\n\n\na = ['a', 'b', 'c', 'd']\na.pop()\n\n# now a is ['a', 'b', 'c']\n\n\n", "score": 958}}
{"question": "How to remove an element from a list by index", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/627435/how-to-remove-an-element-from-a-list-by-index", "answer_count": 18, "answers": {"id": 627453, "body": "Use \ndel\n and specify the index of the element you want to delete:\n\n\n>>> a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> del a[-1]\n>>> a\n[0, 1, 2, 3, 4, 5, 6, 7, 8]\n\n\n\nAlso supports slices:\n\n\n>>> del a[2:4]\n>>> a\n[0, 1, 4, 5, 6, 7, 8, 9]\n\n\n\nHere\n is the section from the tutorial.\n\n", "score": 2602}}
{"question": "How can I randomly select (choose) an item from a list (get a random element)?", "tags": ["python", "list", "random"], "link": "https://stackoverflow.com/questions/306400/how-can-i-randomly-select-choose-an-item-from-a-list-get-a-random-element", "answer_count": 18, "answers": {"id": 12373205, "body": "If you also need the index, use \nrandom.randrange\n\n\nfrom random import randrange\nrandom_index = randrange(len(foo))\nprint(foo[random_index])\n\n\n", "score": 194}}
{"question": "How can I randomly select (choose) an item from a list (get a random element)?", "tags": ["python", "list", "random"], "link": "https://stackoverflow.com/questions/306400/how-can-i-randomly-select-choose-an-item-from-a-list-get-a-random-element", "answer_count": 18, "answers": {"id": 30488952, "body": "If you want to randomly select more than one item from a list, or select an item from a set, I'd recommend using \nrandom.sample\n instead.\n\n\nimport random\ngroup_of_items = {'a', 'b', 'c', 'd', 'e'}  # a sequence or set will work here.\nnum_to_select = 2                           # set the number to select here.\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1] \n\n\n\nIf you're only pulling a single item from a list though, choice is less clunky, as using sample would have the syntax \nrandom.sample(some_list, 1)[0]\n instead of \nrandom.choice(some_list)\n.\n\n\nUnfortunately though, choice only works for a single output from sequences (such as lists or tuples).  Though \nrandom.choice(tuple(some_set))\n may be an option for getting a single item from a set.\n\n\nEDIT: Using Secrets\n\n\nAs many have pointed out, if you require more secure pseudorandom samples, you should use the secrets module:\n\n\nimport secrets                              # imports secure module.\nsecure_random = secrets.SystemRandom()      # creates a secure random object.\ngroup_of_items = {'a', 'b', 'c', 'd', 'e'}  # a sequence or set will work here.\nnum_to_select = 2                           # set the number to select here.\nlist_of_random_items = secure_random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]\n\n\n\nEDIT: Pythonic One-Liner\n\n\nIf you want a more pythonic one-liner for selecting multiple items, you can use unpacking.\n\n\nimport random\nfirst_random_item, second_random_item = random.sample({'a', 'b', 'c', 'd', 'e'}, 2)\n\n\n", "score": 300}}
{"question": "How can I randomly select (choose) an item from a list (get a random element)?", "tags": ["python", "list", "random"], "link": "https://stackoverflow.com/questions/306400/how-can-i-randomly-select-choose-an-item-from-a-list-get-a-random-element", "answer_count": 18, "answers": {"id": 306417, "body": "Use \nrandom.choice()\n:\n\n\nimport random\n\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint(random.choice(foo))\n\n\n\nFor \ncryptographically secure\n random choices (e.g., for generating a passphrase from a wordlist), use \nsecrets.choice()\n:\n\n\nimport secrets\n\nfoo = ['battery', 'correct', 'horse', 'staple']\nprint(secrets.choice(foo))\n\n\n\nsecrets\n is new in Python 3.6. On older versions of Python you can use the \nrandom.SystemRandom\n class:\n\n\nimport random\n\nsecure_random = random.SystemRandom()\nprint(secure_random.choice(foo))\n\n\n", "score": 3522}}
{"question": "Limiting floats to two decimal points", "tags": ["python", "floating-point", "rounding", "precision"], "link": "https://stackoverflow.com/questions/455612/limiting-floats-to-two-decimal-points", "answer_count": 36, "answers": {"id": 41407651, "body": "The built-in \nround()\n works just fine in Python 2.7 or later.\n\n\nExample:\n\n\n>>> round(14.22222223, 2)\n14.22\n\n\n\nCheck out \nthe documentation\n.\n\n", "score": 447}}
{"question": "Limiting floats to two decimal points", "tags": ["python", "floating-point", "rounding", "precision"], "link": "https://stackoverflow.com/questions/455612/limiting-floats-to-two-decimal-points", "answer_count": 36, "answers": {"id": 6539677, "body": "There are new format specifications, \nString Format Specification Mini-Language\n:\n\n\nYou can do the same as:\n\n\n\"{:.2f}\".format(13.949999999999999)\n\n\n\nNote 1:\n the above returns a string. In order to get as float, simply wrap with \nfloat(...)\n:\n\n\nfloat(\"{:.2f}\".format(13.949999999999999))\n\n\n\nNote 2:\n wrapping with \nfloat()\n doesn't change anything:\n\n\n>>> x = 13.949999999999999999\n>>> x\n13.95\n>>> g = float(\"{:.2f}\".format(x))\n>>> g\n13.95\n>>> x == g\nTrue\n>>> h = round(x, 2)\n>>> h\n13.95\n>>> x == h\nTrue\n\n\n", "score": 831}}
{"question": "Limiting floats to two decimal points", "tags": ["python", "floating-point", "rounding", "precision"], "link": "https://stackoverflow.com/questions/455612/limiting-floats-to-two-decimal-points", "answer_count": 36, "answers": {"id": 455634, "body": "You are running into the \nold problem\n with floating point numbers that not all numbers can be represented exactly. The command line is just showing you the full floating point form from memory.\n\n\nWith floating point representation, your rounded version is the same number. Since computers are binary, they store floating point numbers as an integer and then divide it by a power of two so 13.95 will be represented in a similar fashion to 125650429603636838/(2**53).\n\n\nDouble precision numbers have 53 bits (16 digits) of precision and regular floats have 24 bits (8 digits) of precision. The \nfloating point type in Python uses double precision\n to store the values.\n\n\nFor example,\n\n\n>>> 125650429603636838/(2**53)\n13.949999999999999\n\n>>> 234042163/(2**24)\n13.949999988079071\n\n>>> a = 13.946\n>>> print(a)\n13.946\n>>> print(\"%.2f\" % a)\n13.95\n>>> round(a,2)\n13.949999999999999\n>>> print(\"%.2f\" % round(a, 2))\n13.95\n>>> print(\"{:.2f}\".format(a))\n13.95\n>>> print(\"{:.2f}\".format(round(a, 2)))\n13.95\n>>> print(\"{:.15f}\".format(round(a, 2)))\n13.949999999999999\n\n\n\nIf you are after only two decimal places (to display a currency value, for example), then you have a couple of better choices:\n\n\n\n\nUse integers and store values in cents, not dollars and then divide by 100 to convert to dollars.\n\n\nOr use a fixed point number like \ndecimal\n.\n\n\n\n", "score": 2321}}
{"question": "Calling a function of a module by using its name (a string)", "tags": ["python", "object", "reflection"], "link": "https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string", "answer_count": 19, "answers": {"id": 4605, "body": "Based on \nPatrick's solution\n, to get the module dynamically as well, import it using:\n\n\nmodule = __import__('foo')\nfunc = getattr(module, 'bar')\nfunc()\n\n\n", "score": 485}}
{"question": "Calling a function of a module by using its name (a string)", "tags": ["python", "object", "reflection"], "link": "https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string", "answer_count": 19, "answers": {"id": 834451, "body": "\n\nUsing \nlocals()\n, which returns a dictionary with the current local symbol table:\n\n\nlocals()[\"myfunction\"]()\n\n\n\n\n\nUsing \nglobals()\n, which returns a dictionary with the global symbol table:\n\n\nglobals()[\"myfunction\"]()\n\n\n\n\n\n\n", "score": 794}}
{"question": "Calling a function of a module by using its name (a string)", "tags": ["python", "object", "reflection"], "link": "https://stackoverflow.com/questions/3061/calling-a-function-of-a-module-by-using-its-name-a-string", "answer_count": 19, "answers": {"id": 3071, "body": "Given a module \nfoo\n with method \nbar\n:\n\n\nimport foo\nbar = getattr(foo, 'bar')\nresult = bar()\n\n\n\ngetattr\n can similarly be used on class instance bound methods, module-level methods, class methods... the list goes on.\n\n", "score": 2971}}
{"question": "How to print without a newline or space", "tags": ["python", "trailing-newline"], "link": "https://stackoverflow.com/questions/493386/how-to-print-without-a-newline-or-space", "answer_count": 30, "answers": {"id": 493500, "body": "Note: The title of this question used to be something like \"How to printf in Python\"\n\n\nSince people may come here looking for it based on the title, Python also supports printf-style substitution:\n\n\n>>> strings = [ \"one\", \"two\", \"three\" ]\n>>>\n>>> for i in xrange(3):\n...     print \"Item %d: %s\" % (i, strings[i])\n...\nItem 0: one\nItem 1: two\nItem 2: three\n\n\n\nAnd, you can handily multiply string values:\n\n\n>>> print \".\" * 10\n..........\n\n\n", "score": 177}}
{"question": "How to print without a newline or space", "tags": ["python", "trailing-newline"], "link": "https://stackoverflow.com/questions/493386/how-to-print-without-a-newline-or-space", "answer_count": 30, "answers": {"id": 11685717, "body": "For Python 2 and earlier, it should be as simple as described in \nRe: How does one print without a CR?\n by \nGuido van Rossum\n (paraphrased):\n\n\n\n\nIs it possible to print something, but not automatically have a\ncarriage return appended to it?\n\n\n\n\nYes, append a comma after the last argument to print. For instance, this loop prints the numbers 0..9 on a line separated by spaces. Note the parameterless \"print\" that adds the final newline:\n\n\n>>> for i in range(10):\n...     print i,\n... else:\n...     print\n...\n0 1 2 3 4 5 6 7 8 9\n>>>\n\n\n", "score": 301}}
{"question": "How to print without a newline or space", "tags": ["python", "trailing-newline"], "link": "https://stackoverflow.com/questions/493386/how-to-print-without-a-newline-or-space", "answer_count": 30, "answers": {"id": 493399, "body": "In Python 3, you can use the \nsep=\n and \nend=\n parameters of the \nprint\n function:\n\n\nTo not add a newline to the end of the string:\n\n\nprint('.', end='')\n\n\n\nTo not add a space between all the function arguments you want to print:\n\n\nprint('a', 'b', 'c', sep='')\n\n\n\nYou can pass any string to either parameter, and you can use both parameters at the same time.\n\n\nIf you are having trouble with buffering, you can flush the output by adding \nflush=True\n keyword argument:\n\n\nprint('.', end='', flush=True)\n\n\n\nPython 2.6 and 2.7\n\n\nFrom Python 2.6 you can either import the \nprint\n function from Python 3 using the \n__future__\n module\n:\n\n\nfrom __future__ import print_function\n\n\n\nwhich allows you to use the Python 3 solution above.\n\n\nHowever, note that the \nflush\n keyword is not available in the version of the \nprint\n function imported from \n__future__\n in Python 2; it only works in Python 3, more specifically 3.3 and later. In earlier versions you'll still need to flush manually with a call to \nsys.stdout.flush()\n. You'll also have to rewrite all other print statements in the file where you do this import.\n\n\nOr you can use \nsys.stdout.write()\n\n\nimport sys\nsys.stdout.write('.')\n\n\n\nYou may also need to call\n\n\nsys.stdout.flush()\n\n\n\nto ensure \nstdout\n is flushed immediately.\n\n", "score": 3393}}
{"question": "How can I check if an object has an attribute?", "tags": ["python", "class", "object", "attributes", "attributeerror"], "link": "https://stackoverflow.com/questions/610883/how-can-i-check-if-an-object-has-an-attribute", "answer_count": 16, "answers": {"id": 611708, "body": "You can use \nhasattr()\n or catch \nAttributeError\n, but if you really just want the value of the attribute with a default if it isn't there, the best option is just to use \ngetattr()\n:\n\n\ngetattr(a, 'property', 'default value')\n\n\n", "score": 686}}
{"question": "How can I check if an object has an attribute?", "tags": ["python", "class", "object", "attributes", "attributeerror"], "link": "https://stackoverflow.com/questions/610883/how-can-i-check-if-an-object-has-an-attribute", "answer_count": 16, "answers": {"id": 610923, "body": "As \nJarret Hardie answered\n, \nhasattr\n will do the trick.  I would like to add, though, that many in the Python community recommend a strategy of \"easier to ask for forgiveness than permission\" (EAFP) rather than \"look before you leap\" (LBYL).  See these references:\n\n\nEAFP vs LBYL (was Re: A little disappointed so far)\n\n\nEAFP vs. LBYL @Code Like a Pythonista: Idiomatic Python\n\n\nThat is,\n\n\ntry:\n    doStuff(a.property)\nexcept AttributeError:\n    otherStuff()\n\n\n\n... is preferred to:\n\n\nif hasattr(a, 'property'):\n    doStuff(a.property)\nelse:\n    otherStuff()\n\n\n", "score": 834}}
{"question": "How can I check if an object has an attribute?", "tags": ["python", "class", "object", "attributes", "attributeerror"], "link": "https://stackoverflow.com/questions/610883/how-can-i-check-if-an-object-has-an-attribute", "answer_count": 16, "answers": {"id": 610893, "body": "Try \nhasattr()\n:\n\n\nif hasattr(a, 'property'):\n    a.property\n\n\n\nSee \nzweiterlinde's answer\n, which offers good advice about asking forgiveness! It is a very Pythonic approach!\n\n\nThe general practice in Python is that, if the property is likely to be there most of the time, simply call it and either let the exception propagate, or trap it with a try/except block. This will likely be faster than \nhasattr\n. If the property is likely to not be there most of the time, or you're not sure, using \nhasattr\n will probably be faster than repeatedly falling into an exception block.\n\n", "score": 3508}}
{"question": "How do I lowercase a string in Python?", "tags": ["python", "string", "uppercase", "lowercase"], "link": "https://stackoverflow.com/questions/6797984/how-do-i-lowercase-a-string-in-python", "answer_count": 10, "answers": {"id": 26175350, "body": "With Python 2, this doesn't work for non-English words in UTF-8. In this case \ndecode('utf-8')\n can help:\n\n\n>>> s='\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n>>> print s.lower()\n\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n>>> print s.decode('utf-8').lower()\n\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n\n\n", "score": 211}}
{"question": "How do I lowercase a string in Python?", "tags": ["python", "string", "uppercase", "lowercase"], "link": "https://stackoverflow.com/questions/6797984/how-do-i-lowercase-a-string-in-python", "answer_count": 10, "answers": {"id": 31599276, "body": "The canonical Pythonic way of doing this is\n\n\n>>> 'Kilometers'.lower()\n'kilometers'\n\n\n\nHowever, if the purpose is to do case insensitive matching, you should use case-folding:\n\n\n>>> 'Kilometers'.casefold()\n'kilometers'\n\n\n\nHere's why:\n\n\n>>> \"Ma\u00dfe\".casefold()\n'masse'\n>>> \"Ma\u00dfe\".lower()\n'ma\u00dfe'\n>>> \"MASSE\" == \"Ma\u00dfe\"\nFalse\n>>> \"MASSE\".lower() == \"Ma\u00dfe\".lower()\nFalse\n>>> \"MASSE\".casefold() == \"Ma\u00dfe\".casefold()\nTrue\n\n\n\nThis is a str method in Python 3, but in Python 2, you'll want to look at the PyICU or py2casefold - \nseveral answers address this here\n.\n\n\nUnicode Python 3\n\n\nPython 3\n handles plain string literals as unicode:\n\n\n>>> string = '\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n>>> string\n'\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n>>> string.lower()\n'\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n\n\n\nPython 2, plain string literals are bytes\n\n\nIn Python 2, the below, pasted into a shell, encodes the literal as a string of bytes, using \nutf-8\n.\n\n\nAnd \nlower\n doesn't map any changes that bytes would be aware of, so we get the same string.\n\n\n>>> string = '\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n>>> string\n'\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\n>>> string.lower()\n'\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\n>>> print string.lower()\n\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n\n\n\nIn scripts, Python will object to non-ascii (as of Python 2.5, and warning in Python 2.4) bytes being in a string with no encoding given, since the intended coding would be ambiguous. For more on that, see the Unicode how-to in the \ndocs\n and \nPEP 263\n\n\nUse Unicode literals, not \nstr\n literals\n\n\nSo we need a \nunicode\n string to handle this conversion, accomplished easily with a unicode string literal, which disambiguates with a \nu\n prefix (and note the \nu\n prefix also works in Python 3):\n\n\n>>> unicode_literal = u'\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440'\n>>> print(unicode_literal.lower())\n\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n\n\n\nNote that the bytes are completely different from the \nstr\n bytes - the escape character is \n'\\u'\n followed by the 2-byte width, or 16 bit representation of these \nunicode\n letters:\n\n\n>>> unicode_literal\nu'\\u041a\\u0438\\u043b\\u043e\\u043c\\u0435\\u0442\\u0440'\n>>> unicode_literal.lower()\nu'\\u043a\\u0438\\u043b\\u043e\\u043c\\u0435\\u0442\\u0440'\n\n\n\nNow if we only have it in the form of a \nstr\n, we need to convert it to \nunicode\n. Python's Unicode type is a universal encoding format that has many \nadvantages\n relative to most other encodings. We can either use the \nunicode\n constructor or \nstr.decode\n method with the codec to convert the \nstr\n to \nunicode\n:\n\n\n>>> unicode_from_string = unicode(string, 'utf-8') # \"encoding\" unicode from string\n>>> print(unicode_from_string.lower())\n\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n>>> string_to_unicode = string.decode('utf-8') \n>>> print(string_to_unicode.lower())\n\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n>>> unicode_from_string == string_to_unicode == unicode_literal\nTrue\n\n\n\nBoth methods convert to the unicode type - and same as the unicode_literal.\n\n\nBest Practice, use Unicode\n\n\nIt is recommended that you always \nwork with text in Unicode\n.\n\n\n\n\nSoftware should only work with Unicode strings internally, converting to a particular encoding on output.\n\n\n\n\nCan encode back when necessary\n\n\nHowever, to get the lowercase back in type \nstr\n, encode the python string to \nutf-8\n again:\n\n\n>>> print string\n\u041a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n>>> string\n'\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\n>>> string.decode('utf-8')\nu'\\u041a\\u0438\\u043b\\u043e\\u043c\\u0435\\u0442\\u0440'\n>>> string.decode('utf-8').lower()\nu'\\u043a\\u0438\\u043b\\u043e\\u043c\\u0435\\u0442\\u0440'\n>>> string.decode('utf-8').lower().encode('utf-8')\n'\\xd0\\xba\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\n>>> print string.decode('utf-8').lower().encode('utf-8')\n\u043a\u0438\u043b\u043e\u043c\u0435\u0442\u0440\n\n\n\nSo in Python 2, Unicode can encode into Python strings, and Python strings can decode into the Unicode type.\n\n", "score": 441}}
{"question": "How do I lowercase a string in Python?", "tags": ["python", "string", "uppercase", "lowercase"], "link": "https://stackoverflow.com/questions/6797984/how-do-i-lowercase-a-string-in-python", "answer_count": 10, "answers": {"id": 6797990, "body": "Use \nstr.lower()\n:\n\n\n\"Kilometer\".lower()\n\n\n", "score": 3649}}
{"question": "Class (static) variables and methods", "tags": ["python", "class", "static", "class-variables"], "link": "https://stackoverflow.com/questions/68645/class-static-variables-and-methods", "answer_count": 27, "answers": {"id": 27568860, "body": "Static and Class Methods\n\n\nAs the other answers have noted, static and class methods are easily accomplished using the built-in decorators:\n\n\nclass Test(object):\n\n    # regular instance method:\n    def my_method(self):\n        pass\n\n    # class method:\n    @classmethod\n    def my_class_method(cls):\n        pass\n\n    # static method:\n    @staticmethod\n    def my_static_method():\n        pass\n\n\n\nAs usual, the first argument to \nmy_method()\n is bound to the class instance object. In contrast, the first argument to \nmy_class_method()\n is \nbound to the class object itself\n (e.g., in this case, \nTest\n). For \nmy_static_method()\n, none of the arguments are bound, and having arguments at all is optional.\n\n\n\"Static Variables\"\n\n\nHowever, implementing \"static variables\" (well, \nmutable\n static variables, anyway, if that's not a contradiction in terms...) is not as straight forward. As millerdev \npointed out in his answer\n, the problem is that Python's class attributes are not truly \"static variables\". Consider:\n\n\nclass Test(object):\n    i = 3  # This is a class attribute\n\nx = Test()\nx.i = 12   # Attempt to change the value of the class attribute using x instance\nassert x.i == Test.i  # ERROR\nassert Test.i == 3    # Test.i was not affected\nassert x.i == 12      # x.i is a different object than Test.i\n\n\n\nThis is because the line \nx.i = 12\n has added a new instance attribute \ni\n to \nx\n instead of changing the value of the \nTest\n class \ni\n attribute.\n\n\nPartial\n expected static variable behavior, i.e., syncing of the attribute between multiple instances (but \nnot\n with the class itself; see \"gotcha\" below), can be achieved by turning the class attribute into a property:\n\n\nclass Test(object):\n\n    _i = 3\n\n    @property\n    def i(self):\n        return type(self)._i\n\n    @i.setter\n    def i(self,val):\n        type(self)._i = val\n\n## ALTERNATIVE IMPLEMENTATION - FUNCTIONALLY EQUIVALENT TO ABOVE ##\n## (except with separate methods for getting and setting i) ##\n\nclass Test(object):\n\n    _i = 3\n\n    def get_i(self):\n        return type(self)._i\n\n    def set_i(self,val):\n        type(self)._i = val\n\n    i = property(get_i, set_i)\n\n\n\nNow you can do:\n\n\nx1 = Test()\nx2 = Test()\nx1.i = 50\nassert x2.i == x1.i  # no error\nassert x2.i == 50    # the property is synced\n\n\n\nThe static variable will now remain in sync \nbetween all class instances\n.\n\n\n(NOTE: That is, unless a class instance decides to define its own version of \n_i\n! But if someone decides to do THAT, they deserve what they get, don't they???)\n\n\nNote that technically speaking, \ni\n is still not a 'static variable' at all; it is a \nproperty\n, which is a special type of descriptor. However, the \nproperty\n behavior is now equivalent to a (mutable) static variable synced across all class instances.\n\n\nImmutable \"Static Variables\"\n\n\nFor immutable static variable behavior, simply omit the \nproperty\n setter:\n\n\nclass Test(object):\n\n    _i = 3\n\n    @property\n    def i(self):\n        return type(self)._i\n\n## ALTERNATIVE IMPLEMENTATION - FUNCTIONALLY EQUIVALENT TO ABOVE ##\n## (except with separate methods for getting i) ##\n\nclass Test(object):\n\n    _i = 3\n\n    def get_i(self):\n        return type(self)._i\n\n    i = property(get_i)\n\n\n\nNow attempting to set the instance \ni\n attribute will return an \nAttributeError\n:\n\n\nx = Test()\nassert x.i == 3  # success\nx.i = 12         # ERROR\n\n\n\nOne Gotcha to be Aware of\n\n\nNote that the above methods only work with \ninstances\n of your class - they will \nnot\n work \nwhen using the class itself\n. So for example:\n\n\nx = Test()\nassert x.i == Test.i  # ERROR\n\n# x.i and Test.i are two different objects:\ntype(Test.i)  # class 'property'\ntype(x.i)     # class 'int'\n\n\n\nThe line \nassert Test.i == x.i\n produces an error, because the \ni\n attribute of \nTest\n and \nx\n are two different objects.\n\n\nMany people will find this surprising. However, it should not be. If we go back and inspect our \nTest\n class definition (the second version), we take note of this line:\n\n\n    i = property(get_i) \n\n\n\nClearly, the member \ni\n of \nTest\n must be a \nproperty\n object, which is the type of object returned from the \nproperty\n function.\n\n\nIf you find the above confusing, you are most likely still thinking about it from the perspective of other languages (e.g. Java or c++). You should go study the \nproperty\n object, about the order in which Python attributes are returned, the descriptor protocol, and the method resolution order (MRO).\n\n\nI present a solution to the above 'gotcha' below; however I would suggest - strenuously - that you do not try to do something like the following until - at minimum - you thoroughly understand why \nassert Test.i = x.i\n causes an error.\n\n\nREAL, ACTUAL\n Static Variables - \nTest.i == x.i\n\n\nI present the (Python 3) solution below for informational purposes only. I am not endorsing it as a \"good solution\". I have my doubts as to whether emulating the static variable behavior of other languages in Python is ever actually necessary. However, regardless as to whether it is actually useful, the below should help further understanding of how Python works.\n\n\nUPDATE: this attempt \nis really pretty awful\n; if you insist on doing something like this (hint: please don't; Python is a very elegant language and shoe-horning it into behaving like another language is just not necessary), use the code in \nEthan Furman's answer\n instead.\n\n\nEmulating static variable behavior of other languages using a metaclass\n\n\nA metaclass is the class of a class. The default metaclass for all classes in Python (i.e., the \"new style\" classes post Python 2.3 I believe) is \ntype\n. For example:\n\n\ntype(int)  # class 'type'\ntype(str)  # class 'type'\nclass Test(): pass\ntype(Test) # class 'type'\n\n\n\nHowever, you can define your own metaclass like this:\n\n\nclass MyMeta(type): pass\n\n\n\nAnd apply it to your own class like this (Python 3 only):\n\n\nclass MyClass(metaclass = MyMeta):\n    pass\n\ntype(MyClass)  # class MyMeta\n\n\n\nBelow is a metaclass I have created which attempts to emulate \"static variable\" behavior of other languages. It basically works by replacing the default getter, setter, and deleter with versions which check to see if the attribute being requested is a \"static variable\".\n\n\nA catalog of the \"static variables\" is stored in the \nStaticVarMeta.statics\n attribute. All attribute requests are initially attempted to be resolved using a substitute resolution order. I have dubbed this the \"static resolution order\", or \"SRO\". This is done by looking for the requested attribute in the set of \"static variables\" for a given class (or its parent classes). If the attribute does not appear in the \"SRO\", the class will fall back on the default attribute get/set/delete behavior (i.e., \"MRO\").\n\n\nfrom functools import wraps\n\nclass StaticVarsMeta(type):\n    '''A metaclass for creating classes that emulate the \"static variable\" behavior\n    of other languages. I do not advise actually using this for anything!!!\n    \n    Behavior is intended to be similar to classes that use __slots__. However, \"normal\"\n    attributes and __statics___ can coexist (unlike with __slots__). \n    \n    Example usage: \n        \n        class MyBaseClass(metaclass = StaticVarsMeta):\n            __statics__ = {'a','b','c'}\n            i = 0  # regular attribute\n            a = 1  # static var defined (optional)\n            \n        class MyParentClass(MyBaseClass):\n            __statics__ = {'d','e','f'}\n            j = 2              # regular attribute\n            d, e, f = 3, 4, 5  # Static vars\n            a, b, c = 6, 7, 8  # Static vars (inherited from MyBaseClass, defined/re-defined here)\n            \n        class MyChildClass(MyParentClass):\n            __statics__ = {'a','b','c'}\n            j = 2  # regular attribute (redefines j from MyParentClass)\n            d, e, f = 9, 10, 11   # Static vars (inherited from MyParentClass, redefined here)\n            a, b, c = 12, 13, 14  # Static vars (overriding previous definition in MyParentClass here)'''\n    statics = {}\n    def __new__(mcls, name, bases, namespace):\n        # Get the class object\n        cls = super().__new__(mcls, name, bases, namespace)\n        # Establish the \"statics resolution order\"\n        cls.__sro__ = tuple(c for c in cls.__mro__ if isinstance(c,mcls))\n                        \n        # Replace class getter, setter, and deleter for instance attributes\n        cls.__getattribute__ = StaticVarsMeta.__inst_getattribute__(cls, cls.__getattribute__)\n        cls.__setattr__ = StaticVarsMeta.__inst_setattr__(cls, cls.__setattr__)\n        cls.__delattr__ = StaticVarsMeta.__inst_delattr__(cls, cls.__delattr__)\n        # Store the list of static variables for the class object\n        # This list is permanent and cannot be changed, similar to __slots__\n        try:\n            mcls.statics[cls] = getattr(cls,'__statics__')\n        except AttributeError:\n            mcls.statics[cls] = namespace['__statics__'] = set() # No static vars provided\n        # Check and make sure the statics var names are strings\n        if any(not isinstance(static,str) for static in mcls.statics[cls]):\n            typ = dict(zip((not isinstance(static,str) for static in mcls.statics[cls]), map(type,mcls.statics[cls])))[True].__name__\n            raise TypeError('__statics__ items must be strings, not {0}'.format(typ))\n        # Move any previously existing, not overridden statics to the static var parent class(es)\n        if len(cls.__sro__) > 1:\n            for attr,value in namespace.items():\n                if attr not in StaticVarsMeta.statics[cls] and attr != ['__statics__']:\n                    for c in cls.__sro__[1:]:\n                        if attr in StaticVarsMeta.statics[c]:\n                            setattr(c,attr,value)\n                            delattr(cls,attr)\n        return cls\n    def __inst_getattribute__(self, orig_getattribute):\n        '''Replaces the class __getattribute__'''\n        @wraps(orig_getattribute)\n        def wrapper(self, attr):\n            if StaticVarsMeta.is_static(type(self),attr):\n                return StaticVarsMeta.__getstatic__(type(self),attr)\n            else:\n                return orig_getattribute(self, attr)\n        return wrapper\n    def __inst_setattr__(self, orig_setattribute):\n        '''Replaces the class __setattr__'''\n        @wraps(orig_setattribute)\n        def wrapper(self, attr, value):\n            if StaticVarsMeta.is_static(type(self),attr):\n                StaticVarsMeta.__setstatic__(type(self),attr, value)\n            else:\n                orig_setattribute(self, attr, value)\n        return wrapper\n    def __inst_delattr__(self, orig_delattribute):\n        '''Replaces the class __delattr__'''\n        @wraps(orig_delattribute)\n        def wrapper(self, attr):\n            if StaticVarsMeta.is_static(type(self),attr):\n                StaticVarsMeta.__delstatic__(type(self),attr)\n            else:\n                orig_delattribute(self, attr)\n        return wrapper\n    def __getstatic__(cls,attr):\n        '''Static variable getter'''\n        for c in cls.__sro__:\n            if attr in StaticVarsMeta.statics[c]:\n                try:\n                    return getattr(c,attr)\n                except AttributeError:\n                    pass\n        raise AttributeError(cls.__name__ + \" object has no attribute '{0}'\".format(attr))\n    def __setstatic__(cls,attr,value):\n        '''Static variable setter'''\n        for c in cls.__sro__:\n            if attr in StaticVarsMeta.statics[c]:\n                setattr(c,attr,value)\n                break\n    def __delstatic__(cls,attr):\n        '''Static variable deleter'''\n        for c in cls.__sro__:\n            if attr in StaticVarsMeta.statics[c]:\n                try:\n                    delattr(c,attr)\n                    break\n                except AttributeError:\n                    pass\n        raise AttributeError(cls.__name__ + \" object has no attribute '{0}'\".format(attr))\n    def __delattr__(cls,attr):\n        '''Prevent __sro__ attribute from deletion'''\n        if attr == '__sro__':\n            raise AttributeError('readonly attribute')\n        super().__delattr__(attr)\n    def is_static(cls,attr):\n        '''Returns True if an attribute is a static variable of any class in the __sro__'''\n        if any(attr in StaticVarsMeta.statics[c] for c in cls.__sro__):\n            return True\n        return False\n\n\n", "score": 299}}
{"question": "Class (static) variables and methods", "tags": ["python", "class", "static", "class-variables"], "link": "https://stackoverflow.com/questions/68645/class-static-variables-and-methods", "answer_count": 27, "answers": {"id": 69067, "body": "@Blair Conrad said static variables declared inside the class definition, but not inside a method are class or \"static\" variables:\n\n\n>>> class Test(object):\n...     i = 3\n...\n>>> Test.i\n3\n\n\n\nThere are a few gotcha's here. Carrying on from the example above:\n\n\n>>> t = Test()\n>>> t.i     # \"static\" variable accessed via instance\n3\n>>> t.i = 5 # but if we assign to the instance ...\n>>> Test.i  # we have not changed the \"static\" variable\n3\n>>> t.i     # we have overwritten Test.i on t by creating a new attribute t.i\n5\n>>> Test.i = 6 # to change the \"static\" variable we do it by assigning to the class\n>>> t.i\n5\n>>> Test.i\n6\n>>> u = Test()\n>>> u.i\n6           # changes to t do not affect new instances of Test\n\n# Namespaces are one honking great idea -- let's do more of those!\n>>> Test.__dict__\n{'i': 6, ...}\n>>> t.__dict__\n{'i': 5}\n>>> u.__dict__\n{}\n\n\n\nNotice how the instance variable \nt.i\n got out of sync with the \"static\" class variable when the attribute \ni\n was set directly on \nt\n. This is because \ni\n was re-bound within the \nt\n namespace, which is distinct from the \nTest\n namespace. If you want to change the value of a \"static\" variable, you must change it within the scope (or object) where it was originally defined. I put \"static\" in quotes because Python does not really have static variables in the sense that C++ and Java do.\n\n\nAlthough it doesn't say anything specific about static variables or methods, the \nPython tutorial\n has some relevant information on \nclasses and class objects\n. \n\n\n@Steve Johnson also answered regarding static methods, also documented under \"Built-in Functions\" in the Python Library Reference.\n\n\nclass Test(object):\n    @staticmethod\n    def f(arg1, arg2, ...):\n        ...\n\n\n\n@beid also mentioned classmethod, which is similar to staticmethod. A classmethod's first argument is the class object. Example:\n\n\nclass Test(object):\n    i = 3 # class (or static) variable\n    @classmethod\n    def g(cls, arg):\n        # here we can use 'cls' instead of the class name (Test)\n        if arg > cls.i:\n            cls.i = arg # would be the same as Test.i = arg1\n\n\n\n\n", "score": 783}}
{"question": "Class (static) variables and methods", "tags": ["python", "class", "static", "class-variables"], "link": "https://stackoverflow.com/questions/68645/class-static-variables-and-methods", "answer_count": 27, "answers": {"id": 68672, "body": "Variables declared inside the class definition, but not inside a method are class or static variables:\n\n\n>>> class MyClass:\n...     i = 3\n...\n>>> MyClass.i\n3 \n\n\n\nAs @\nmillerdev\n points out, this creates a class-level \ni\n variable, but this is distinct from any instance-level \ni\n variable, so you could have\n\n\n>>> m = MyClass()\n>>> m.i = 4\n>>> MyClass.i, m.i\n>>> (3, 4)\n\n\n\nThis is different from C++ and Java, but not so different from C#, where a static member can't be accessed using a reference to an instance.\n\n\nSee \nwhat the Python tutorial has to say on the subject of classes and class objects\n.\n\n\n@Steve Johnson has already answered regarding \nstatic methods\n, also documented under \n\"Built-in Functions\" in the Python Library Reference\n.\n\n\nclass C:\n    @staticmethod\n    def f(arg1, arg2, ...): ...\n\n\n\n@beidy recommends \nclassmethod\ns over staticmethod, as the method then receives the class type as the first argument.\n\n", "score": 2392}}
{"question": "Importing files from different folder", "tags": ["python", "importerror", "python-import"], "link": "https://stackoverflow.com/questions/4383571/importing-files-from-different-folder", "answer_count": 41, "answers": {"id": 40612922, "body": "When modules are in parallel locations, as in the question:\n\n\napplication/app2/some_folder/some_file.py\napplication/app2/another_folder/another_file.py\n\n\n\nThis shorthand makes one module visible to the other:\n\n\nimport sys\nsys.path.append('../')\n\n\n", "score": 264}}
{"question": "Importing files from different folder", "tags": ["python", "importerror", "python-import"], "link": "https://stackoverflow.com/questions/4383571/importing-files-from-different-folder", "answer_count": 41, "answers": {"id": 21995949, "body": "There is nothing wrong with:\n\n\nfrom application.app.folder.file import func_name\n\n\n\nJust make sure \nfolder\n also contains an \n__init__.py\n. This allows it to be included as a package. I am not sure why the other answers talk about \nPYTHONPATH\n.\n\n", "score": 1404}}
{"question": "Importing files from different folder", "tags": ["python", "importerror", "python-import"], "link": "https://stackoverflow.com/questions/4383571/importing-files-from-different-folder", "answer_count": 41, "answers": {"id": 4383597, "body": "Note: This answer was intended for a very specific question. For most programmers coming here from a search engine, this is not the answer you are looking for. Typically you would structure your files into packages (see other answers) instead of modifying the search path.\n\n\n\n\nBy default, you can't. When importing a file, Python only searches the directory that the entry-point script is running from and \nsys.path\n which includes locations such as the package installation directory (it's actually \na little more complex\n than this, but this covers most cases).\n\n\nHowever, you can add to the Python path at runtime:\n\n\n# some_file.py\nimport sys\n# caution: path[0] is reserved for script path (or '' in REPL)\nsys.path.insert(1, '/path/to/application/app/folder')\n\nimport file\n\n\n", "score": 2338}}
{"question": "Check if a given key already exists in a dictionary", "tags": ["python", "dictionary"], "link": "https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary", "answer_count": 16, "answers": {"id": 1602990, "body": "You can test for the presence of a key in a dictionary, using the \nin\n keyword:\n\n\nd = {'a': 1, 'b': 2}\n'a' in d # <== evaluates to True\n'c' in d # <== evaluates to False\n\n\n\nA common use for checking the existence of a key in a dictionary before mutating it is to default-initialize the value (e.g. if your values are lists, for example, and you want to ensure that there is an empty list to which you can append when inserting the first value for a key). In cases such as those, you may find the \ncollections.defaultdict()\n type to be of interest.\n\n\nIn older code, you may also find some uses of \nhas_key()\n, a deprecated method for checking the existence of keys in dictionaries (just use \nkey_name in dict_name\n, instead).\n\n", "score": 299}}
{"question": "Check if a given key already exists in a dictionary", "tags": ["python", "dictionary"], "link": "https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary", "answer_count": 16, "answers": {"id": 1602944, "body": "Use \nkey in my_dict\n directly instead of \nkey in my_dict.keys()\n:\n\n\nif 'key1' in my_dict:\n    print(\"blah\")\nelse:\n    print(\"boo\")\n\n\n\nThat will be much \nfaster\n as it uses the dictionary's O(1) hashing as opposed to doing an O(n) linear search on a list of keys.\n\n", "score": 1932}}
{"question": "Check if a given key already exists in a dictionary", "tags": ["python", "dictionary"], "link": "https://stackoverflow.com/questions/1602934/check-if-a-given-key-already-exists-in-a-dictionary", "answer_count": 16, "answers": {"id": 1602964, "body": "in\n tests for the existence of a key in a \ndict\n:\n\n\nd = {\"key1\": 10, \"key2\": 23}\n\nif \"key1\" in d:\n    print(\"this will execute\")\n\nif \"nonexistent key\" in d:\n    print(\"this will not\")\n\n\n\n\n\nUse \ndict.get()\n to provide a default value when the key does not exist:\n\n\nd = {}\n\nfor i in range(100):\n    key = i % 10\n    d[key] = d.get(key, 0) + 1\n\n\n\n\n\nTo provide a default value for \nevery\n key, either use \ndict.setdefault()\n on each assignment:\n\n\nd = {}\n\nfor i in range(100):\n    d[i % 10] = d.setdefault(i % 10, 0) + 1    \n\n\n\n...or better, use \ndefaultdict\n from the \ncollections\n module:\n\n\nfrom collections import defaultdict\n\nd = defaultdict(int)\n\nfor i in range(100):\n    d[i % 10] += 1\n\n\n", "score": 5669}}
{"question": "How do I escape curly-brace ({}) characters characters in a string while using .format?", "tags": ["python", "string", "format", "string-formatting", "curly-braces"], "link": "https://stackoverflow.com/questions/5466451/how-do-i-escape-curly-brace-characters-characters-in-a-string-while-using", "answer_count": 24, "answers": {"id": 5466473, "body": "You escape it by doubling the braces.\n\n\nEg:\n\n\nx = \"{{ Hello }} {0}\"\nprint(x.format(42))\n\n\n", "score": 121}}
{"question": "How do I escape curly-brace ({}) characters characters in a string while using .format?", "tags": ["python", "string", "format", "string-formatting", "curly-braces"], "link": "https://stackoverflow.com/questions/5466451/how-do-i-escape-curly-brace-characters-characters-in-a-string-while-using", "answer_count": 24, "answers": {"id": 47923703, "body": "Python 3.6+ (2017)\n\n\nIn the recent versions of Python one would use \nf-strings\n (see also \nPEP498\n).\n\n\nWith f-strings one should use double \n{{\n or \n}}\n\n\nn = 42  \nprint(f\" {{Hello}} {n} \")\n\n\n\nproduces the desired\n\n\n {Hello} 42\n\n\n\nIf you need to resolve an expression in the brackets instead of using literal text you'll need three sets of brackets:\n\n\nhello = \"HELLO\"\nprint(f\"{{{hello.lower()}}}\")\n\n\n\nproduces\n\n\n{hello}\n\n\n", "score": 309}}
{"question": "How do I escape curly-brace ({}) characters characters in a string while using .format?", "tags": ["python", "string", "format", "string-formatting", "curly-braces"], "link": "https://stackoverflow.com/questions/5466451/how-do-i-escape-curly-brace-characters-characters-in-a-string-while-using", "answer_count": 24, "answers": {"id": 5466478, "body": "You need to double the \n{{\n and \n}}\n:\n\n\n>>> x = \" {{ Hello }} {0} \"\n>>> print(x.format(42))\n' { Hello } 42 '\n\n\n\nHere's the relevant part of the \nPython documentation for format string syntax\n:\n\n\n\n\nFormat strings contain \u201creplacement fields\u201d surrounded by curly braces \n{}\n. Anything that is not contained in braces is considered literal text, which is copied unchanged to the output. If you need to include a brace character in the literal text, it can be escaped by doubling: \n{{\n and \n}}\n.\n\n\n\n", "score": 3532}}
{"question": "How do I get a substring of a string in Python?", "tags": ["python", "string", "substring"], "link": "https://stackoverflow.com/questions/663171/how-do-i-get-a-substring-of-a-string-in-python", "answer_count": 16, "answers": {"id": 11808384, "body": "Substr() normally (i.e. PHP and Perl) works this way: \n\n\ns = Substr(s, beginning, LENGTH)\n\n\n\nSo the parameters are \nbeginning\n and \nLENGTH\n.\n\n\nBut Python's behaviour is different; it expects beginning and one after END (!). \nThis is difficult to spot by beginners.\n So the correct replacement for Substr(s, beginning, LENGTH) is\n\n\ns = s[ beginning : beginning + LENGTH]\n\n\n", "score": 174}}
{"question": "How do I get a substring of a string in Python?", "tags": ["python", "string", "substring"], "link": "https://stackoverflow.com/questions/663171/how-do-i-get-a-substring-of-a-string-in-python", "answer_count": 16, "answers": {"id": 9780082, "body": "Just for completeness as nobody else has mentioned it.  The third parameter to an array slice is a step.  So reversing a string is as simple as:\n\n\nsome_string[::-1]\n\n\n\nOr selecting alternate characters would be:\n\n\n\"H-e-l-l-o- -W-o-r-l-d\"[::2] # outputs \"Hello World\"\n\n\n\nThe ability to step forwards and backwards through the string maintains consistency with being able to array slice from the start or end.\n\n", "score": 500}}
{"question": "How do I get a substring of a string in Python?", "tags": ["python", "string", "substring"], "link": "https://stackoverflow.com/questions/663171/how-do-i-get-a-substring-of-a-string-in-python", "answer_count": 16, "answers": {"id": 663175, "body": ">>> x = \"Hello World!\"\n>>> x[2:]\n'llo World!'\n>>> x[:2]\n'He'\n>>> x[:-2]\n'Hello Worl'\n>>> x[-2:]\n'd!'\n>>> x[2:-2]\n'llo Worl'\n\n\n\nPython calls this concept \"slicing\" and it works on more than just strings. Take a look \nhere\n for a comprehensive introduction.\n\n", "score": 3804}}
{"question": "How do I parse a string to a float or int?", "tags": ["python", "parsing", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int", "answer_count": 34, "answers": {"id": 379966, "body": "def num(s):\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n\n\n", "score": 583}}
{"question": "How do I parse a string to a float or int?", "tags": ["python", "parsing", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int", "answer_count": 34, "answers": {"id": 20929983, "body": "Python2 method to check if a string is a float:\n\n\ndef is_float(value):\n  if value is None:\n      return False\n  try:\n      float(value)\n      return True\n  except:\n      return False\n\n\n\nFor the Python3 version of is_float see: \nChecking if a string can be converted to float in Python\n\n\nA longer and more accurate name for this function could be: \nis_convertible_to_float(value)\n\n\nWhat is, and is not a float in \nPython\n may surprise you:\n\n\nThe below unit tests were done using python2.  Check it that Python3 has different behavior for what strings are convertable to float.  One confounding difference is that any number of interior underscores are now allowed:  \n(float(\"1_3.4\") == float(13.4))\n is True\n\n\nval                   is_float(val) Note\n--------------------  ----------   --------------------------------\n\"\"                    False        Blank string\n\"127\"                 True         Passed string\nTrue                  True         Pure sweet Truth\n\"True\"                False        Vile contemptible lie\nFalse                 True         So false it becomes true\n\"123.456\"             True         Decimal\n\"      -127    \"      True         Spaces trimmed\n\"\\t\\n12\\r\\n\"          True         whitespace ignored\n\"NaN\"                 True         Not a number\n\"NaNanananaBATMAN\"    False        I am Batman\n\"-iNF\"                True         Negative infinity\n\"123.E4\"              True         Exponential notation\n\".1\"                  True         mantissa only\n\"1_2_3.4\"             False        Underscores not allowed\n\"12 34\"               False        Spaces not allowed on interior\n\"1,234\"               False        Commas gtfo\nu'\\x30'               True         Unicode is fine.\n\"NULL\"                False        Null is not special\n0x3fade               True         Hexadecimal\n\"6e7777777777777\"     True         Shrunk to infinity\n\"1.797693e+308\"       True         This is max value\n\"infinity\"            True         Same as inf\n\"infinityandBEYOND\"   False        Extra characters wreck it\n\"12.34.56\"            False        Only one dot allowed\nu'\u56db'                 False        Japanese '4' is not a float.\n\"#56\"                 False        Pound sign\n\"56%\"                 False        Percent of what?\n\"0E0\"                 True         Exponential, move dot 0 places\n0**0                  True         0___0  Exponentiation\n\"-5e-5\"               True         Raise to a negative number\n\"+1e1\"                True         Plus is OK with exponent\n\"+1e1^5\"              False        Fancy exponent not interpreted\n\"+1e1.3\"              False        No decimals in exponent\n\"-+1\"                 False        Make up your mind\n\"(1)\"                 False        Parenthesis is bad\n\n\n\nYou think you know what numbers are? You are not so good as you think! Not big surprise.\n\n\nDon't use this code on life-critical software!\n\n\nCatching broad exceptions this way, killing canaries and gobbling the exception creates a tiny chance that a valid float as string will return false.  The \nfloat(...)\n line of code can failed for any of a thousand reasons that have nothing to do with the contents of the string.  But if you're writing life-critical software in a duck-typing prototype language like Python, then you've got much larger problems.\n\n", "score": 604}}
{"question": "How do I parse a string to a float or int?", "tags": ["python", "parsing", "floating-point", "type-conversion", "integer"], "link": "https://stackoverflow.com/questions/379906/how-do-i-parse-a-string-to-a-float-or-int", "answer_count": 34, "answers": {"id": 379910, "body": ">>> a = \"545.2222\"\n>>> float(a)\n545.22220000000004\n>>> int(float(a))\n545\n\n\n", "score": 3106}}
{"question": "How do I install pip on Windows?", "tags": ["python", "windows", "pip"], "link": "https://stackoverflow.com/questions/4750806/how-do-i-install-pip-on-windows", "answer_count": 40, "answers": {"id": 9038397, "body": "2014 UPDATE:\n\n\n1) If you have installed Python 3.4 or later, pip is included with Python and should already be working on your system.\n\n\n2) If you are running a version below Python 3.4 or if pip was not installed with Python 3.4 for some reason, then you'd probably use pip's official installation script \nget-pip.py\n. The pip installer now grabs setuptools for you, and works regardless of architecture (32-bit or 64-bit).\n\n\nThe installation \ninstructions are detailed here\n and involve:\n\n\n\n\nTo install or upgrade pip, securely download \nget-pip.py\n.\n\n\nThen run the following (which may require administrator access):\n\n\n\n\npython get-pip.py\n\n\n\n\n\nTo upgrade an existing setuptools (or distribute), run \npip install -U setuptools\n\n\n\n\nI'll leave the two sets of old instructions below for posterity.\n\n\nOLD Answers:\n\n\nFor Windows editions of the \n64 bit\n variety - 64-bit Windows + Python used to require a separate installation method due to ez_setup, but I've tested the new distribute method on 64-bit Windows running 32-bit Python and 64-bit Python, and you can now use the same method for all versions of Windows/Python 2.7X:\n\n\nOLD Method 2\n using \ndistribute\n:\n\n\n\n\nDownload \ndistribute\n - I threw mine in \nC:\\Python27\\Scripts\n (feel free to create a \nScripts\n directory if it doesn't exist.\n\n\nOpen up a command prompt (on Windows you should check out \nconemu2\n if you don't use \nPowerShell\n) and change (\ncd\n) to the directory you've downloaded \ndistribute_setup.py\n to.\n\n\nRun distribute_setup: \npython distribute_setup.py\n (This will not work if your python installation directory is not added to your path - \ngo here for help\n)\n\n\nChange the current directory to the \nScripts\n directory for your Python installation (\nC:\\Python27\\Scripts\n) or add that directory, as well as the Python base installation directory to your %PATH% environment variable.\n\n\nInstall pip using the newly installed setuptools: \neasy_install pip\n\n\n\n\nThe last step will not work unless you're either in the directory \neasy_install.exe\n is located in (C:\\Python27\\Scripts would be the default for Python 2.7), or you have that directory added to your path.\n\n\nOLD Method 1\n using ez_setup:\n\n\nfrom the setuptools page\n --\n\n\n\n\nDownload \nez_setup.py\n and run it; it will download the appropriate .egg file and install it for you. (Currently, the provided .exe installer does not support 64-bit versions of Python for Windows, due to a distutils installer compatibility issue.\n\n\n\n\nAfter this, you may continue with:\n\n\n\n\nAdd \nc:\\Python2x\\Scripts\n to the Windows path (replace the \nx\n in \nPython2x\n with the actual version number you have installed)\n\n\nOpen a new (!) DOS prompt. From there run \neasy_install pip\n\n\n\n", "score": 225}}
{"question": "How do I install pip on Windows?", "tags": ["python", "windows", "pip"], "link": "https://stackoverflow.com/questions/4750806/how-do-i-install-pip-on-windows", "answer_count": 40, "answers": {"id": 4921215, "body": "-- \nOutdated\n -- use distribute, not setuptools as described here. --\n\n-- \nOutdated #2\n -- use setuptools as distribute is deprecated.\n\n\nAs you mentioned pip doesn't include an independent installer, but you can install it with its predecessor easy_install.\n\n\nSo:\n\n\n\n\nDownload the last pip version from here: \nhttp://pypi.python.org/pypi/pip#downloads\n\n\nUncompress it\n\n\nDownload the last easy installer for Windows: (\ndownload the .exe at the bottom of \nhttp://pypi.python.org/pypi/setuptools\n ). Install it.\n\n\ncopy the uncompressed pip folder \ncontent\n into \nC:\\Python2x\\\n folder (don't copy the whole folder into it, just the content), because python command doesn't work outside \nC:\\Python2x\n folder and then run:  \npython setup.py install\n\n\nAdd your python \nC:\\Python2x\\Scripts\n to the path\n\n\n\n\nYou are done. \n\n\nNow you can use \npip install package\n to easily install packages as in Linux :)\n\n", "score": 310}}
{"question": "How do I install pip on Windows?", "tags": ["python", "windows", "pip"], "link": "https://stackoverflow.com/questions/4750806/how-do-i-install-pip-on-windows", "answer_count": 40, "answers": {"id": 12476379, "body": "Python 3.4+ and 2.7.9+\n\n\nGood news! \nPython 3.4\n (released March 2014) and \nPython 2.7.9\n (released December 2014) ship with Pip. This is the best feature of any Python release. It makes the community's wealth of libraries accessible to everyone. Newbies are no longer excluded from using community libraries by the prohibitive difficulty of setup. In shipping with a package manager, Python joins \nRuby\n, \nNode.js\n, \nHaskell\n, \nPerl\n, \nGo\n\u2014almost every other contemporary language with a majority open-source community. Thank you, Python.\n\n\nIf you do find that pip is not available, simply run \nensurepip\n.\n\n\n\n\nOn Windows:\n\n\npy -3 -m ensurepip\n\n\n\n\n\nOtherwise:\n\n\npython3 -m ensurepip\n\n\n\n\n\n\n\nOf course, that doesn't mean Python packaging is problem solved. The experience remains frustrating. I discuss this \nin the Stack Overflow question \nDoes Python have a package/module management system?\n.\n\n\nPython 3 \u2264 3.3 and 2 \u2264 2.7.8\n\n\nFlying in the face of its \n'batteries included'\n motto, Python ships without a package manager. To make matters worse, Pip was\u2014until recently\u2014ironically difficult to install.\n\n\nOfficial instructions\n\n\nPer \nhttps://pip.pypa.io/en/stable/installing/#do-i-need-to-install-pip\n:\n\n\nDownload \nget-pip.py\n, being careful to save it as a \n.py\n file rather than \n.txt\n. Then, run it from the command prompt:\n\n\npython get-pip.py\n\n\n\nYou possibly need an administrator command prompt to do this. Follow \nStart a Command Prompt as an Administrator\n (Microsoft TechNet).\n\n\nThis installs the pip package, which (in Windows) contains ...\\Scripts\\pip.exe that path must be in PATH environment variable to use pip from the command line (see the second part of 'Alternative Instructions' for adding it to your PATH,\n\n\nAlternative instructions\n\n\nThe official documentation tells users to install Pip and each of its dependencies from source. That's tedious for the experienced and prohibitively difficult for newbies.\n\n\nFor our sake, Christoph Gohlke prepares Windows installers (\n.msi\n) for popular Python packages. He builds installers for all Python versions, both 32 and 64 bit. You need to:\n\n\n\n\nInstall setuptools\n\n\nInstall pip\n\n\n\n\nFor me, this installed Pip at \nC:\\Python27\\Scripts\\pip.exe\n. Find \npip.exe\n on your computer, then add its folder (for example, \nC:\\Python27\\Scripts\n) to your path (Start / Edit environment variables). Now you should be able to run \npip\n from the command line. Try installing a package:\n\n\npip install httpie\n\n\n\nThere you go (hopefully)! Solutions for common problems are given below:\n\n\nProxy problems\n\n\nIf you work in an office, you might be behind an HTTP proxy. If so, set the environment variables \nhttp_proxy\n and \nhttps_proxy\n. Most Python applications (and other free software) respect these. Example syntax:\n\n\nhttp://proxy_url:port\nhttp://username:password@proxy_url:port\n\n\n\nIf you're really unlucky, your proxy might be a Microsoft \nNTLM\n proxy. Free software can't cope. The only solution is to install a free software friendly proxy that forwards to the nasty proxy. \nhttp://cntlm.sourceforge.net/\n\n\nUnable to find vcvarsall.bat\n\n\nPython modules can be partly written in C or C++. Pip tries to compile from source. If you don't have a C/C++ compiler installed and configured, you'll see this cryptic error message.\n\n\n\n\nError: Unable to find vcvarsall.bat\n\n\n\n\nYou can fix that by \ninstalling a C++ compiler\n such as \nMinGW\n or \nVisual C++\n. Microsoft actually ships one specifically for use with Python. Or try \nMicrosoft Visual C++ Compiler for Python 2.7\n.\n\n\nOften though it's easier to check \nChristoph's site\n for your package.\n\n", "score": 1960}}
{"question": "How to leave/exit/deactivate a Python virtualenv", "tags": ["python", "virtualenv", "exit", "virtualenvwrapper"], "link": "https://stackoverflow.com/questions/990754/how-to-leave-exit-deactivate-a-python-virtualenv", "answer_count": 16, "answers": {"id": 33932473, "body": "To activate a Python virtual environment:\n\n\n$ cd ~/python-venv/\n$ ./bin/activate\n\n\n\nTo deactivate:\n\n\n$ deactivate\n\n\n", "score": 81}}
{"question": "How to leave/exit/deactivate a Python virtualenv", "tags": ["python", "virtualenv", "exit", "virtualenvwrapper"], "link": "https://stackoverflow.com/questions/990754/how-to-leave-exit-deactivate-a-python-virtualenv", "answer_count": 16, "answers": {"id": 29586756, "body": "Use:\n\n\n$ deactivate \n\n\n\nIf this doesn't work, try \n\n\n$ source deactivate\n\n\n\nAnyone who knows how \nBash \nsource\n works will think that's odd, but some wrappers/workflows around virtualenv implement it as a complement/counterpart to \nsource activate\n. Your mileage may vary.\n\n", "score": 177}}
{"question": "How to leave/exit/deactivate a Python virtualenv", "tags": ["python", "virtualenv", "exit", "virtualenvwrapper"], "link": "https://stackoverflow.com/questions/990754/how-to-leave-exit-deactivate-a-python-virtualenv", "answer_count": 16, "answers": {"id": 990779, "body": "Usually, activating a virtualenv gives you a shell function named:\n\n\n$ deactivate\n\n\n\nwhich puts things back to normal.\n\n\nI have just looked specifically again at the code for \nvirtualenvwrapper\n, and, yes, it too supports \ndeactivate\n as the way to escape from all virtualenvs.\n\n\nIf you are trying to leave an \nAnaconda\n environment, the command depends upon your version of \nconda\n. Recent versions (like 4.6) install a \nconda\n function directly in your shell, in which case you run:\n\n\nconda deactivate\n\n\n\nOlder conda versions instead implement deactivation using a stand-alone script:\n\n\nsource deactivate\n\n\n", "score": 4456}}
{"question": "How do I get the last element of a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/930397/how-do-i-get-the-last-element-of-a-list", "answer_count": 26, "answers": {"id": 930759, "body": "You can also do:\n\n\nlast_elem = alist.pop()\n\n\n\nIt depends on what you want to do with your list because the \npop()\n method will delete the last element.\n\n", "score": 136}}
{"question": "How do I get the last element of a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/930397/how-do-i-get-the-last-element-of-a-list", "answer_count": 26, "answers": {"id": 4139773, "body": "If your \nstr()\n or \nlist()\n objects might end up being empty as so: \nastr = ''\n or \nalist = []\n, then you might want to use \nalist[-1:]\n instead of \nalist[-1]\n for object \"sameness\".\n\n\nThe significance of this is:\n\n\nalist = []\nalist[-1]   # will generate an IndexError exception whereas \nalist[-1:]  # will return an empty list\nastr = ''\nastr[-1]    # will generate an IndexError exception whereas\nastr[-1:]   # will return an empty str\n\n\n\nWhere the distinction being made is that returning an empty list object or empty str object is more \"last element\"-like then an exception object.\n\n", "score": 333}}
{"question": "How do I get the last element of a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/930397/how-do-i-get-the-last-element-of-a-list", "answer_count": 26, "answers": {"id": 930398, "body": "some_list[-1]\n is the shortest and most Pythonic.\n\n\nIn fact, you can do much more with this syntax. The \nsome_list[-n]\n syntax gets the nth-to-last element. So \nsome_list[-1]\n gets the last element, \nsome_list[-2]\n gets the second to last, etc, all the way down to \nsome_list[-len(some_list)]\n, which gives you the first element.\n\n\nYou can also set list elements in this way. For instance:\n\n\n>>> some_list = [1, 2, 3]\n>>> some_list[-1] = 5 # Set the last element\n>>> some_list[-2] = 3 # Set the second to last element\n>>> some_list\n[1, 3, 5]\n\n\n\nNote that getting a list item by index will raise an \nIndexError\n if the expected item doesn't exist. This means that \nsome_list[-1]\n will raise an exception if \nsome_list\n is empty, because an empty list can't have a last element.\n\n", "score": 4003}}
{"question": "How to sort a list of dictionaries by a value of the dictionary in Python?", "tags": ["python", "list", "sorting", "dictionary", "data-structures"], "link": "https://stackoverflow.com/questions/72899/how-to-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary-in-python", "answer_count": 22, "answers": {"id": 73044, "body": "my_list = [{'name':'Homer', 'age':39}, {'name':'Bart', 'age':10}]\n\nmy_list.sort(lambda x,y : cmp(x['name'], y['name']))\n\n\n\nmy_list\n will now be what you want.\n\n\nOr better:\n\n\nSince Python 2.4, there's a \nkey\n argument is both more efficient and neater:\n\n\nmy_list = sorted(my_list, key=lambda k: k['name'])\n\n\n\n...the lambda is, IMO, easier to understand than \noperator.itemgetter\n, but your mileage may vary.\n\n", "score": 125}}
{"question": "How to sort a list of dictionaries by a value of the dictionary in Python?", "tags": ["python", "list", "sorting", "dictionary", "data-structures"], "link": "https://stackoverflow.com/questions/72899/how-to-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary-in-python", "answer_count": 22, "answers": {"id": 73465, "body": "import operator\n\n\n\nTo sort the list of dictionaries by key='name':\n\n\nlist_of_dicts.sort(key=operator.itemgetter('name'))\n\n\n\nTo sort the list of dictionaries by key='age':\n\n\nlist_of_dicts.sort(key=operator.itemgetter('age'))\n\n\n", "score": 247}}
{"question": "How to sort a list of dictionaries by a value of the dictionary in Python?", "tags": ["python", "list", "sorting", "dictionary", "data-structures"], "link": "https://stackoverflow.com/questions/72899/how-to-sort-a-list-of-dictionaries-by-a-value-of-the-dictionary-in-python", "answer_count": 22, "answers": {"id": 73050, "body": "The \nsorted()\n function takes a \nkey=\n parameter\n\n\nnewlist = sorted(list_to_be_sorted, key=lambda d: d['name'])\n\n\n\nAlternatively, you can use \noperator.itemgetter\n instead of defining the function yourself\n\n\nfrom operator import itemgetter\nnewlist = sorted(list_to_be_sorted, key=itemgetter('name'))\n\n\n\nFor completeness, add \nreverse=True\n to sort in descending order\n\n\nnewlist = sorted(list_to_be_sorted, key=itemgetter('name'), reverse=True)\n\n\n", "score": 3735}}
{"question": "How to upgrade all Python packages with pip", "tags": ["python", "pip", "pypi"], "link": "https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip", "answer_count": 63, "answers": {"id": 5839291, "body": "You can use the following Python code. Unlike \npip freeze\n, this will not print warnings and FIXME errors.\n\nFor pip < 10.0.1\n\n\nimport pip\nfrom subprocess import call\n\npackages = [dist.project_name for dist in pip.get_installed_distributions()]\ncall(\"pip install --upgrade \" + ' '.join(packages), shell=True)\n\n\n\nFor pip >= 10.0.1\n\n\nimport pkg_resources\nfrom subprocess import call\n\npackages = [dist.project_name for dist in pkg_resources.working_set]\ncall(\"pip install --upgrade \" + ' '.join(packages), shell=True)\n\n\n", "score": 843}}
{"question": "How to upgrade all Python packages with pip", "tags": ["python", "pip", "pypi"], "link": "https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip", "answer_count": 63, "answers": {"id": 16269635, "body": "To upgrade all local packages, you can install \npip-review\n:\n\n\n$ pip install pip-review\n\n\n\nAfter that, you can either upgrade the packages interactively:\n\n\n$ pip-review --local --interactive\n\n\n\nOr automatically:\n\n\n$ pip-review --local --auto\n\n\n\n\n\npip-review\n is a fork of \npip-tools\n. See \npip-tools\n issue\n mentioned by \n@knedlsepp\n. \npip-review\n package works but \npip-tools\n package no longer works. \npip-review\n is looking for a new maintainer.\n\n\npip-review\n works on Windows \nsince version 0.5\n.\n\n", "score": 947}}
{"question": "How to upgrade all Python packages with pip", "tags": ["python", "pip", "pypi"], "link": "https://stackoverflow.com/questions/2720014/how-to-upgrade-all-python-packages-with-pip", "answer_count": 63, "answers": {"id": 3452888, "body": "There isn't a built-in flag yet. Starting with pip version 22.3, the \n--outdated\n and \n--format=freeze\n have become \nmutually exclusive\n. Use Python, to parse the JSON output:\n\n\npip --disable-pip-version-check list --outdated --format=json | python -c \"import json, sys; print('\\n'.join([x['name'] for x in json.load(sys.stdin)]))\" | xargs -n1 pip install -U\n\n\n\nIf you are using \npip<22.3\n you can use:\n\n\npip list --outdated --format=freeze | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\n\n\n\nFor older versions of \npip\n:\n\n\npip freeze --local | grep -v '^\\-e' | cut -d = -f 1  | xargs -n1 pip install -U\n\n\n\n\n\n\n\nThe \ngrep\n is to skip editable (\"-e\") package definitions, as suggested by \n@jawache\n. (Yes, you could replace \ngrep\n+\ncut\n with \nsed\n or \nawk\n or \nperl\n or...).\n\n\n\n\nThe \n-n1\n flag for \nxargs\n prevents stopping everything if updating one package fails (thanks \n@andsens\n).\n\n\n\n\n\n\n\n\nNote:\n there are infinite potential variations for this. I'm trying to keep this answer short and simple, but please do suggest variations in the comments!\n\n", "score": 2932}}
{"question": "How can I remove a key from a Python dictionary?", "tags": ["python", "dictionary", "unset"], "link": "https://stackoverflow.com/questions/11277432/how-can-i-remove-a-key-from-a-python-dictionary", "answer_count": 11, "answers": {"id": 15206537, "body": "It took me some time to figure out what exactly \nmy_dict.pop(\"key\", None)\n is doing. So I'll add this as an answer to save others googling time:\n\n\n\n\npop(key[, default])\n\n\nIf \nkey\n is in the dictionary, remove it and return its value, else\nreturn \ndefault\n. If \ndefault\n is not given and \nkey\n is not in the\ndictionary, a \nKeyError\n is raised.\n\n\n\n\nDocumentation\n\n", "score": 206}}
{"question": "How can I remove a key from a Python dictionary?", "tags": ["python", "dictionary", "unset"], "link": "https://stackoverflow.com/questions/11277432/how-can-i-remove-a-key-from-a-python-dictionary", "answer_count": 11, "answers": {"id": 11277484, "body": "Specifically to answer \"is there a one line way of doing this?\"\n\n\nif 'key' in my_dict: del my_dict['key']\n\n\n\n...well, you \nasked\n ;-)\n\n\nYou should consider, though, that this way of deleting an object from a \ndict\n is \nnot atomic\n\u2014it is possible that \n'key'\n may be in \nmy_dict\n during the \nif\n statement, but may be deleted before \ndel\n is executed, in which case \ndel\n will fail with a \nKeyError\n.  Given this, it would be safest to either \nuse \ndict.pop\n or something along the lines of\n\n\ntry:\n    del my_dict['key']\nexcept KeyError:\n    pass\n\n\n\nwhich, of course, is definitely \nnot\n a one-liner.\n\n", "score": 475}}
{"question": "How can I remove a key from a Python dictionary?", "tags": ["python", "dictionary", "unset"], "link": "https://stackoverflow.com/questions/11277432/how-can-i-remove-a-key-from-a-python-dictionary", "answer_count": 11, "answers": {"id": 11277439, "body": "To delete a key regardless of whether it is in the dictionary, use the two-argument form of \ndict.pop()\n:\n\n\nmy_dict.pop('key', None)\n\n\n\nThis will return \nmy_dict[key]\n if \nkey\n exists in the dictionary, and \nNone\n otherwise. If the second parameter is not specified (i.e. \nmy_dict.pop('key')\n) and \nkey\n does not exist, a \nKeyError\n is raised.\n\n\nTo delete a key that is guaranteed to exist, you can also use\n\n\ndel my_dict['key']\n\n\n\nThis will raise a \nKeyError\n if the key is not in the dictionary.\n\n", "score": 4769}}
{"question": "Convert string &quot;Jun 1 2005 1:33PM&quot; into datetime", "tags": ["python", "datetime", "type-conversion"], "link": "https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime", "answer_count": 26, "answers": {"id": 466366, "body": "Check out \nstrptime\n in the \ntime\n module.  It is the inverse of \nstrftime\n.\n\n\n$ python\n>>> import time\n>>> my_time = time.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\ntime.struct_time(tm_year=2005, tm_mon=6, tm_mday=1,\n                 tm_hour=13, tm_min=33, tm_sec=0,\n                 tm_wday=2, tm_yday=152, tm_isdst=-1)\n\ntimestamp = time.mktime(my_time)\n# convert time object to datetime\nfrom datetime import datetime\nmy_datetime = datetime.fromtimestamp(timestamp)\n# convert time object to date\nfrom datetime import date\nmy_date = date.fromtimestamp(timestamp)\n\n\n", "score": 516}}
{"question": "Convert string &quot;Jun 1 2005 1:33PM&quot; into datetime", "tags": ["python", "datetime", "type-conversion"], "link": "https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime", "answer_count": 26, "answers": {"id": 470303, "body": "Use the third-party \ndateutil\n library:\n\n\nfrom dateutil import parser\nparser.parse(\"Aug 28 1999 12:00AM\")  # datetime.datetime(1999, 8, 28, 0, 0)\n\n\n\nIt can handle most date formats and is more convenient than \nstrptime\n since it usually guesses the correct format. It is also very useful for writing tests, where readability is more important than performance.\n\n\nInstall it with:\n\n\npip install python-dateutil\n\n\n", "score": 1082}}
{"question": "Convert string &quot;Jun 1 2005 1:33PM&quot; into datetime", "tags": ["python", "datetime", "type-conversion"], "link": "https://stackoverflow.com/questions/466345/convert-string-jun-1-2005-133pm-into-datetime", "answer_count": 26, "answers": {"id": 466376, "body": "datetime.strptime\n parses an input string in the user-specified format into a \ntimezone-naive\n \ndatetime\n object:\n\n\n>>> from datetime import datetime\n>>> datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')\ndatetime.datetime(2005, 6, 1, 13, 33)\n\n\n\nTo obtain a \ndate\n object using an existing \ndatetime\n object, convert it using \n.date()\n:\n\n\n>>> datetime.strptime('Jun 1 2005', '%b %d %Y').date()\ndate(2005, 6, 1)\n\n\n\n\n\nLinks:\n\n\n\n\nstrptime\n docs: \nPython 2\n, \nPython 3\n\n\n\n\nstrptime\n/\nstrftime\n format string docs: \nPython 2\n, \nPython 3\n\n\n\n\nstrftime.org\n format string cheatsheet\n\n\n\n\n\n\nNotes:\n\n\n\n\nstrptime\n = \"string parse time\"\n\n\nstrftime\n = \"string format time\"\n\n\n\n", "score": 4463}}
{"question": "Renaming column names in Pandas", "tags": ["python", "pandas", "replace", "dataframe", "rename"], "link": "https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas", "answer_count": 33, "answers": {"id": 16667215, "body": "The \nrename\n method can take a \nfunction\n, for example:\n\n\nIn [11]: df.columns\nOut[11]: Index([u'$a', u'$b', u'$c', u'$d', u'$e'], dtype=object)\n\nIn [12]: df.rename(columns=lambda x: x[1:], inplace=True)\n\nIn [13]: df.columns\nOut[13]: Index([u'a', u'b', u'c', u'd', u'e'], dtype=object)\n\n\n", "score": 523}}
{"question": "Renaming column names in Pandas", "tags": ["python", "pandas", "replace", "dataframe", "rename"], "link": "https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas", "answer_count": 33, "answers": {"id": 11346337, "body": "Just assign it to the \n.columns\n attribute:\n\n\n>>> df = pd.DataFrame({'$a':[1,2], '$b': [10,20]})\n>>> df\n   $a  $b\n0   1  10\n1   2  20\n\n>>> df.columns = ['a', 'b']\n>>> df\n   a   b\n0  1  10\n1  2  20\n\n\n", "score": 2566}}
{"question": "Renaming column names in Pandas", "tags": ["python", "pandas", "replace", "dataframe", "rename"], "link": "https://stackoverflow.com/questions/11346283/renaming-column-names-in-pandas", "answer_count": 33, "answers": {"id": 11354850, "body": "Rename Specific Columns\n\n\nUse the \ndf.rename()\n function and refer the columns to be renamed. Not all the columns have to be renamed:\n\n\ndf = df.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'})\n\n# Or rename the existing DataFrame (rather than creating a copy) \ndf.rename(columns={'oldName1': 'newName1', 'oldName2': 'newName2'}, inplace=True)\n\n\n\nMinimal Code Example\n\n\ndf = pd.DataFrame('x', index=range(3), columns=list('abcde'))\ndf\n\n   a  b  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n\n\n\nThe following methods all work and produce the same output:\n\n\ndf2 = df.rename({'a': 'X', 'b': 'Y'}, axis=1)\ndf2 = df.rename({'a': 'X', 'b': 'Y'}, axis='columns')\ndf2 = df.rename(columns={'a': 'X', 'b': 'Y'}) \n\ndf2\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n\n\n\nRemember to assign the result back, as the modification is not-inplace. Alternatively, specify \ninplace=True\n:\n\n\ndf.rename({'a': 'X', 'b': 'Y'}, axis=1, inplace=True)\ndf\n\n   X  Y  c  d  e\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n \n\n\n\nYou can specify \nerrors='raise'\n to raise errors if an invalid column-to-rename is specified.\n\n\n\n\nReassign Column Headers\n\n\nUse \ndf.set_axis()\n with \naxis=1\n.\n\n\ndf2 = df.set_axis(['V', 'W', 'X', 'Y', 'Z'], axis=1)\ndf2\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n\n\n\nHeaders can be assigned directly:\n\n\ndf.columns = ['V', 'W', 'X', 'Y', 'Z']\ndf\n\n   V  W  X  Y  Z\n0  x  x  x  x  x\n1  x  x  x  x  x\n2  x  x  x  x  x\n\n\n", "score": 4688}}
{"question": "Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3?", "tags": ["python", "performance", "python-3.x", "range", "python-internals"], "link": "https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3", "answer_count": 12, "answers": {"id": 30081470, "body": "Use the \nsource\n, Luke!\n\n\nIn CPython, \nrange(...).__contains__\n (a method wrapper) will eventually delegate to a simple calculation which checks if the value can possibly be in the range.  The reason for the speed here is we're using \nmathematical reasoning about the bounds, rather than a direct iteration of the range object\n.  To explain the logic used:\n\n\n\n\nCheck that the number is between \nstart\n and \nstop\n, and\n\n\nCheck that the stride value doesn't \"step over\" our number.\n\n\n\n\nFor example, \n994\n is in \nrange(4, 1000, 2)\n because:\n\n\n\n\n4 <= 994 < 1000\n, and\n\n\n(994 - 4) % 2 == 0\n.\n\n\n\n\nThe full C code is included below, which is a bit more verbose because of memory management and reference counting details, but the basic idea is there:\n\n\nstatic int\nrange_contains_long(rangeobject *r, PyObject *ob)\n{\n    int cmp1, cmp2, cmp3;\n    PyObject *tmp1 = NULL;\n    PyObject *tmp2 = NULL;\n    PyObject *zero = NULL;\n    int result = -1;\n\n    zero = PyLong_FromLong(0);\n    if (zero == NULL) /* MemoryError in int(0) */\n        goto end;\n\n    /* Check if the value can possibly be in the range. */\n\n    cmp1 = PyObject_RichCompareBool(r->step, zero, Py_GT);\n    if (cmp1 == -1)\n        goto end;\n    if (cmp1 == 1) { /* positive steps: start <= ob < stop */\n        cmp2 = PyObject_RichCompareBool(r->start, ob, Py_LE);\n        cmp3 = PyObject_RichCompareBool(ob, r->stop, Py_LT);\n    }\n    else { /* negative steps: stop < ob <= start */\n        cmp2 = PyObject_RichCompareBool(ob, r->start, Py_LE);\n        cmp3 = PyObject_RichCompareBool(r->stop, ob, Py_LT);\n    }\n\n    if (cmp2 == -1 || cmp3 == -1) /* TypeError */\n        goto end;\n    if (cmp2 == 0 || cmp3 == 0) { /* ob outside of range */\n        result = 0;\n        goto end;\n    }\n\n    /* Check that the stride does not invalidate ob's membership. */\n    tmp1 = PyNumber_Subtract(ob, r->start);\n    if (tmp1 == NULL)\n        goto end;\n    tmp2 = PyNumber_Remainder(tmp1, r->step);\n    if (tmp2 == NULL)\n        goto end;\n    /* result = ((int(ob) - start) % step) == 0 */\n    result = PyObject_RichCompareBool(tmp2, zero, Py_EQ);\n  end:\n    Py_XDECREF(tmp1);\n    Py_XDECREF(tmp2);\n    Py_XDECREF(zero);\n    return result;\n}\n\nstatic int\nrange_contains(rangeobject *r, PyObject *ob)\n{\n    if (PyLong_CheckExact(ob) || PyBool_Check(ob))\n        return range_contains_long(r, ob);\n\n    return (int)_PySequence_IterSearch((PyObject*)r, ob,\n                                       PY_ITERSEARCH_CONTAINS);\n}\n\n\n\nThe \"meat\" of the idea is mentioned in the comment lines:\n\n\n/* positive steps: start <= ob < stop */\n/* negative steps: stop < ob <= start */\n/* result = ((int(ob) - start) % step) == 0 */ \n\n\n\nAs a final note - look at the \nrange_contains\n function at the bottom of the code snippet.  If the exact type check fails then we don't use the clever algorithm described, instead falling back to a dumb iteration search of the range using \n_PySequence_IterSearch\n!  You can check this behaviour in the interpreter (I'm using v3.5.0 here):\n\n\n>>> x, r = 1000000000000000, range(1000000000000001)\n>>> class MyInt(int):\n...     pass\n... \n>>> x_ = MyInt(x)\n>>> x in r  # calculates immediately :) \nTrue\n>>> x_ in r  # iterates for ages.. :( \n^\\Quit (core dumped)\n\n\n", "score": 528}}
{"question": "Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3?", "tags": ["python", "performance", "python-3.x", "range", "python-internals"], "link": "https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3", "answer_count": 12, "answers": {"id": 30081894, "body": "The fundamental misunderstanding here is in thinking that \nrange\n is a generator. It's not. In fact, it's not any kind of iterator.\n\n\nYou can tell this pretty easily:\n\n\n>>> a = range(5)\n>>> print(list(a))\n[0, 1, 2, 3, 4]\n>>> print(list(a))\n[0, 1, 2, 3, 4]\n\n\n\nIf it were a generator, iterating it once would exhaust it:\n\n\n>>> b = my_crappy_range(5)\n>>> print(list(b))\n[0, 1, 2, 3, 4]\n>>> print(list(b))\n[]\n\n\n\nWhat \nrange\n actually is, is a sequence, just like a list. You can even test this:\n\n\n>>> import collections.abc\n>>> isinstance(a, collections.abc.Sequence)\nTrue\n\n\n\nThis means it has to follow all the rules of being a sequence:\n\n\n>>> a[3]         # indexable\n3\n>>> len(a)       # sized\n5\n>>> 3 in a       # membership\nTrue\n>>> reversed(a)  # reversible\n\n\n>>> a.index(3)   # implements 'index'\n3\n>>> a.count(3)   # implements 'count'\n1\n\n\n\n\n\nThe difference between a \nrange\n and a \nlist\n is that a \nrange\n is a \nlazy\n or \ndynamic\n sequence; it doesn't remember all of its values, it just remembers its \nstart\n, \nstop\n, and \nstep\n, and creates the values on demand on \n__getitem__\n.\n\n\n(As a side note, if you \nprint(iter(a))\n, you'll notice that \nrange\n uses the same \nlistiterator\n type as \nlist\n. How does that work? A \nlistiterator\n doesn't use anything special about \nlist\n except for the fact that it provides a C implementation of \n__getitem__\n, so it works fine for \nrange\n too.)\n\n\n\n\nNow, there's nothing that says that \nSequence.__contains__\n has to be constant time\u2014in fact, for obvious examples of sequences like \nlist\n, it isn't. But there's nothing that says it \ncan't\n be. And it's easier to implement \nrange.__contains__\n to just check it mathematically (\n(val - start) % step\n, but with some extra complexity to deal with negative steps) than to actually generate and test all the values, so why \nshouldn't\n it do it the better way?\n\n\nBut there doesn't seem to be anything in the language that \nguarantees\n this will happen. As Ashwini Chaudhari points out, if you give it a non-integral value, instead of converting to integer and doing the mathematical test, it will fall back to iterating all the values and comparing them one by one. And just because CPython 3.2+ and PyPy 3.x versions happen to contain this optimization, and it's an obvious good idea and easy to do, there's no reason that IronPython or NewKickAssPython 3.x couldn't leave it out. (And in fact, CPython 3.0-3.1 \ndidn't\n include it.)\n\n\n\n\nIf \nrange\n actually were a generator, like \nmy_crappy_range\n, then it wouldn't make sense to test \n__contains__\n this way, or at least the way it makes sense wouldn't be obvious. If you'd already iterated the first 3 values, is \n1\n still \nin\n the generator? Should testing for \n1\n cause it to iterate and consume all the values up to \n1\n (or up to the first value \n>= 1\n)?\n\n", "score": 1235}}
{"question": "Why is &quot;1000000000000000 in range(1000000000000001)&quot; so fast in Python 3?", "tags": ["python", "performance", "python-3.x", "range", "python-internals"], "link": "https://stackoverflow.com/questions/30081275/why-is-1000000000000000-in-range1000000000000001-so-fast-in-python-3", "answer_count": 12, "answers": {"id": 30081318, "body": "The Python 3 \nrange()\n object doesn't produce numbers immediately; it is a smart \nsequence object\n that produces numbers \non demand\n. All it contains is your start, stop and step values, then as you iterate over the object the next integer is calculated each iteration.\n\n\nThe object also implements the \nobject.__contains__\n hook\n, and \ncalculates\n if your number is part of its range. Calculating is a (near) constant time operation \n*\n. There is never a need to scan through all possible integers in the range.\n\n\nFrom the \nrange()\n object documentation\n:\n\n\n\n\nThe advantage of the \nrange\n type over a regular \nlist\n or \ntuple\n is that a range object will always take the same (small) amount of memory, no matter the size of the range it represents (as it only stores the \nstart\n, \nstop\n and \nstep\n values, calculating individual items and subranges as needed).\n\n\n\n\nSo at a minimum, your \nrange()\n object would do:\n\n\nclass my_range:\n    def __init__(self, start, stop=None, step=1, /):\n        if stop is None:\n            start, stop = 0, start\n        self.start, self.stop, self.step = start, stop, step\n        if step < 0:\n            lo, hi, step = stop, start, -step\n        else:\n            lo, hi = start, stop\n        self.length = 0 if lo > hi else ((hi - lo - 1) // step) + 1\n\n    def __iter__(self):\n        current = self.start\n        if self.step < 0:\n            while current > self.stop:\n                yield current\n                current += self.step\n        else:\n            while current < self.stop:\n                yield current\n                current += self.step\n\n    def __len__(self):\n        return self.length\n\n    def __getitem__(self, i):\n        if i < 0:\n            i += self.length\n        if 0 <= i < self.length:\n            return self.start + i * self.step\n        raise IndexError('my_range object index out of range')\n\n    def __contains__(self, num):\n        if self.step < 0:\n            if not (self.stop < num <= self.start):\n                return False\n        else:\n            if not (self.start <= num < self.stop):\n                return False\n        return (num - self.start) % self.step == 0\n\n\n\nThis is still missing several things that a real \nrange()\n supports (such as the \n.index()\n or \n.count()\n methods, hashing, equality testing, or slicing), but should give you an idea.\n\n\nI also simplified the \n__contains__\n implementation to only focus on integer tests; if you give a real \nrange()\n object a non-integer value (including subclasses of \nint\n), a slow scan is initiated to see if there is a match, just as if you use a containment test against a list of all the contained values. This was done to continue to support other numeric types that just happen to support equality testing with integers but are not expected to support integer arithmetic as well. See the original \nPython issue\n that implemented the containment test.\n\n\n\n\n* \nNear\n constant time because Python integers are unbounded and so math operations also grow in time as N grows, making this a O(log N) operation. Since it\u2019s all executed in optimised C code and Python stores integer values in 30-bit chunks, you\u2019d run out of memory before you saw any performance impact due to the size of the integers involved here.\n\n", "score": 3131}}
{"question": "Find the current directory and file&#39;s directory", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/5137497/find-the-current-directory-and-files-directory", "answer_count": 13, "answers": {"id": 13720875, "body": "You may find this useful as a reference:\n\n\nimport os\n\nprint(\"Path at terminal when executing this file\")\nprint(os.getcwd() + \"\\n\")\n\nprint(\"This file path, relative to os.getcwd()\")\nprint(__file__ + \"\\n\")\n\nprint(\"This file full path (following symlinks)\")\nfull_path = os.path.realpath(__file__)\nprint(full_path + \"\\n\")\n\nprint(\"This file directory and name\")\npath, filename = os.path.split(full_path)\nprint(path + ' --> ' + filename + \"\\n\")\n\nprint(\"This file directory only\")\nprint(os.path.dirname(full_path))\n\n\n", "score": 371}}
{"question": "Find the current directory and file&#39;s directory", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/5137497/find-the-current-directory-and-files-directory", "answer_count": 13, "answers": {"id": 5137507, "body": "Current working directory\n:  \nos.getcwd()\n\n\nAnd the \n__file__\n attribute\n can help you find out where the file you are executing is located. This Stack\u00a0Overflow post explains everything:  \nHow do I get the path of the current executed file in Python?\n\n", "score": 392}}
{"question": "Find the current directory and file&#39;s directory", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/5137497/find-the-current-directory-and-files-directory", "answer_count": 13, "answers": {"id": 5137509, "body": "To get the full path to the directory a Python file is contained in, write this in that file:\n\n\nimport os \ndir_path = os.path.dirname(os.path.realpath(__file__))\n\n\n\n(Note that the incantation above won't work if you've already used \nos.chdir()\n to change your current working directory, since the value of the \n__file__\n constant is relative to the current working directory and is not changed by an \nos.chdir()\n call.)\n\n\n\n\nTo get the current working directory use \n\n\nimport os\ncwd = os.getcwd()\n\n\n\n\n\nDocumentation references for the modules, constants and functions used above:\n\n\n\n\nThe \nos\n and \nos.path\n modules.\n\n\nThe \n__file__\n constant\n\n\nos.path.realpath(path)\n (returns \n\"the canonical path of the specified filename, eliminating any symbolic links encountered in the path\"\n)\n\n\nos.path.dirname(path)\n (returns \n\"the directory name of pathname \npath\n\"\n)\n\n\nos.getcwd()\n (returns \n\"a string representing the current working directory\"\n)\n\n\nos.chdir(path)\n (\n\"change the current working directory to \npath\n\"\n)\n\n\n\n", "score": 4806}}
{"question": "What is the difference between Python&#39;s list methods append and extend?", "tags": ["python", "list", "data-structures", "append", "extend"], "link": "https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend", "answer_count": 20, "answers": {"id": 28119966, "body": "\n\nWhat is the difference between the list methods append and extend?\n\n\n\n\n\n\n.append()\n adds its argument as a single element to the end of a list. The length of the list itself will increase by one.\n\n\n.extend()\n iterates over its argument adding each element to the list, extending the list. The length of the list will increase by however many elements were in the iterable argument.\n\n\n\n\n.append()\n\n\nThe \n.append()\n method appends an object to the end of the list.\n\n\nmy_list.append(object) \n\n\n\nWhatever the object is, whether a number, a string, another list, or something else, it gets added onto the end of \nmy_list\n as a single entry on the list.\n\n\n>>> my_list\n['foo', 'bar']\n>>> my_list.append('baz')\n>>> my_list\n['foo', 'bar', 'baz']\n\n\n\nSo keep in mind that a list is an object. If you append another list onto a list, the first list will be a single object at the end of the list (which may not be what you want):\n\n\n>>> another_list = [1, 2, 3]\n>>> my_list.append(another_list)\n>>> my_list\n['foo', 'bar', 'baz', [1, 2, 3]]\n                     #^^^^^^^^^--- single item at the end of the list.\n\n\n\n.extend()\n\n\nThe \n.extend()\n method extends a list by appending elements from an iterable:\n\n\nmy_list.extend(iterable)\n\n\n\nSo with extend, each element of the iterable gets appended onto the list. For example:\n\n\n>>> my_list\n['foo', 'bar']\n>>> another_list = [1, 2, 3]\n>>> my_list.extend(another_list)\n>>> my_list\n['foo', 'bar', 1, 2, 3]\n\n\n\nKeep in mind that a string is an iterable, so if you extend a list with a string, you'll append each character as you iterate over the string (which may not be what you want):\n\n\n>>> my_list.extend('baz')\n>>> my_list\n['foo', 'bar', 1, 2, 3, 'b', 'a', 'z']\n\n\n\nOperator Overload, \n__add__\n (\n+\n) and \n__iadd__\n (\n+=\n)\n\n\nBoth \n+\n and \n+=\n operators are defined for \nlist\n. They are semantically similar to extend.\n\n\nmy_list + another_list\n creates a third list in memory, so you can return the result of it, but it requires that the second iterable be a list.\n\n\nmy_list += another_list\n modifies the list in-place (it \nis\n the in-place operator, and lists are mutable objects, as we've seen) so it does not create a new list. It also works like extend, in that the second iterable can be any kind of iterable.\n\n\nDon't get confused - \nmy_list = my_list + another_list\n is not equivalent to \n+=\n - it gives you a brand new list assigned to my_list.\n\n\nTime Complexity\n\n\nAppend has (\namortized\n) \nconstant time complexity\n, O(1).\n\n\nExtend has time complexity, O(k).\n\n\nIterating through the multiple calls to \n.append()\n adds to the complexity, making it equivalent to that of extend, and since extend's iteration is implemented in C, it will always be faster if you intend to append successive items from an iterable onto a list.\n\n\nRegarding \"amortized\" - from the \nlist object implementation source\n:\n\n\n    /* This over-allocates proportional to the list size, making room\n     * for additional growth.  The over-allocation is mild, but is\n     * enough to give linear-time amortized behavior over a long\n     * sequence of appends() in the presence of a poorly-performing\n     * system realloc().\n\n\n\nThis means that we get the benefits of a larger than needed memory reallocation up front, but we may pay for it on the next marginal reallocation with an even larger one. Total time for all appends is linear at O(n), and that time allocated per append, becomes O(1).\n\n\nPerformance\n\n\nYou may wonder what is more performant, since append can be used to achieve the same outcome as extend. The following functions do the same thing:\n\n\ndef append(alist, iterable):\n    for item in iterable:\n        alist.append(item)\n        \ndef extend(alist, iterable):\n    alist.extend(iterable)\n\n\n\nSo let's time them:\n\n\nimport timeit\n\n>>> min(timeit.repeat(lambda: append([], \"abcdefghijklmnopqrstuvwxyz\")))\n2.867846965789795\n>>> min(timeit.repeat(lambda: extend([], \"abcdefghijklmnopqrstuvwxyz\")))\n0.8060121536254883\n\n\n\nAddressing a comment on timings\n\n\nA commenter said:\n\n\n\n\nPerfect answer, I just miss the timing of comparing adding only one element\n\n\n\n\nDo the semantically correct thing. If you want to append all elements in an iterable, use \n.extend()\n. If you're just adding one element, use \n.append()\n.\n\n\nOk, so let's create an experiment to see how this works out in time:\n\n\ndef append_one(a_list, element):\n    a_list.append(element)\n\ndef extend_one(a_list, element):\n    \"\"\"creating a new list is semantically the most direct\n    way to create an iterable to give to extend\"\"\"\n    a_list.extend([element])\n\nimport timeit\n\n\n\nAnd we see that going out of our way to create an iterable just to use extend is a (minor) waste of time:\n\n\n>>> min(timeit.repeat(lambda: append_one([], 0)))\n0.2082819009956438\n>>> min(timeit.repeat(lambda: extend_one([], 0)))\n0.2397019260097295\n\n\n\nWe learn from this that there's nothing gained from using \n.extend()\n when we have only \none\n element to append.\n\n\nAlso, these timings are not that important. I am just showing them to make the point that, in Python, doing the semantically correct thing is doing things the \nRight\n Way\u2122.\n\n\nIt's conceivable that you might test timings on two comparable operations and get an ambiguous or inverse result. Just focus on doing the semantically correct thing.\n\n\nConclusion\n\n\nWe see that \n.extend()\n is semantically clearer, and that it can run much faster than \n.append()\n, \nwhen you intend to append each element in an iterable to a list.\n\n\nIf you only have a single element (not in an iterable) to add to the list, use \n.append()\n.\n\n", "score": 672}}
{"question": "What is the difference between Python&#39;s list methods append and extend?", "tags": ["python", "list", "data-structures", "append", "extend"], "link": "https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend", "answer_count": 20, "answers": {"id": 252705, "body": ".append()\n adds an element to a list,\n\nwhereas \n.extend()\n concatenates the first list with another list/iterable.\n\n\n>>> xs = ['A', 'B']\n>>> xs\n['A', 'B']\n\n>>> xs.append(\"D\")\n>>> xs\n['A', 'B', 'D']\n\n>>> xs.append([\"E\", \"F\"])\n>>> xs\n['A', 'B', 'D', ['E', 'F']]\n\n>>> xs.insert(2, \"C\")\n>>> xs\n['A', 'B', 'C', 'D', ['E', 'F']]\n\n>>> xs.extend([\"G\", \"H\"])\n>>> xs\n['A', 'B', 'C', 'D', ['E', 'F'], 'G', 'H']\n\n\n", "score": 741}}
{"question": "What is the difference between Python&#39;s list methods append and extend?", "tags": ["python", "list", "data-structures", "append", "extend"], "link": "https://stackoverflow.com/questions/252703/what-is-the-difference-between-pythons-list-methods-append-and-extend", "answer_count": 20, "answers": {"id": 252711, "body": ".append()\n appends a \nsingle object\n at the end of the list:\n\n\n>>> x = [1, 2, 3]\n>>> x.append([4, 5])\n>>> print(x)\n[1, 2, 3, [4, 5]]\n\n\n\n.extend()\n appends \nmultiple objects\n that are taken from inside the specified iterable:\n\n\n>>> x = [1, 2, 3]\n>>> x.extend([4, 5])\n>>> print(x)\n[1, 2, 3, 4, 5]\n\n\n", "score": 5914}}
{"question": "How do I split a list into equally-sized chunks?", "tags": ["python", "list", "split", "chunks"], "link": "https://stackoverflow.com/questions/312443/how-do-i-split-a-list-into-equally-sized-chunks", "answer_count": 69, "answers": {"id": 16935535, "body": "I know this is kind of old but nobody yet mentioned \nnumpy.array_split\n:\n\n\nimport numpy as np\n\nlst = range(50)\nnp.array_split(lst, 5)\n\n\n\nResult:\n\n\n[array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]),\n array([10, 11, 12, 13, 14, 15, 16, 17, 18, 19]),\n array([20, 21, 22, 23, 24, 25, 26, 27, 28, 29]),\n array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39]),\n array([40, 41, 42, 43, 44, 45, 46, 47, 48, 49])]\n\n\n", "score": 446}}
{"question": "How do I split a list into equally-sized chunks?", "tags": ["python", "list", "split", "chunks"], "link": "https://stackoverflow.com/questions/312443/how-do-i-split-a-list-into-equally-sized-chunks", "answer_count": 69, "answers": {"id": 1751478, "body": "Something super simple:\n\n\ndef chunks(xs, n):\n    n = max(1, n)\n    return (xs[i:i+n] for i in range(0, len(xs), n))\n\n\n\nFor Python 2, use \nxrange()\n instead of \nrange()\n.\n\n", "score": 668}}
{"question": "How do I split a list into equally-sized chunks?", "tags": ["python", "list", "split", "chunks"], "link": "https://stackoverflow.com/questions/312443/how-do-i-split-a-list-into-equally-sized-chunks", "answer_count": 69, "answers": {"id": 312464, "body": "Here's a generator that yields evenly-sized chunks:\n\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in range(0, len(lst), n):\n        yield lst[i:i + n]\n\n\n\nimport pprint\npprint.pprint(list(chunks(range(10, 75), 10)))\n[[10, 11, 12, 13, 14, 15, 16, 17, 18, 19],\n [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],\n [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],\n [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],\n [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],\n [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],\n [70, 71, 72, 73, 74]]\n\n\n\nFor Python 2, using \nxrange\n instead of \nrange\n:\n\n\ndef chunks(lst, n):\n    \"\"\"Yield successive n-sized chunks from lst.\"\"\"\n    for i in xrange(0, len(lst), n):\n        yield lst[i:i + n]\n\n\n\n\n\nBelow is a list comprehension one-liner. The method above is preferable, though, since using named functions makes code easier to understand. For Python 3:\n\n\n[lst[i:i + n] for i in range(0, len(lst), n)]\n\n\n\nFor Python 2:\n\n\n[lst[i:i + n] for i in xrange(0, len(lst), n)]\n\n\n", "score": 4484}}
{"question": "How do I make function decorators and chain them together?", "tags": ["python", "function", "decorator", "python-decorators", "chain"], "link": "https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together", "answer_count": 22, "answers": {"id": 739679, "body": "Alternatively, you could write a factory function which return a decorator which wraps the return value of the decorated function in a tag passed to the factory function. For example:\n\n\nfrom functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator():\n            return '<%(tag)s>%(rv)s\n' % (\n                {'tag': tag, 'rv': func()})\n        return decorator\n    return factory\n\n\n\nThis enables you to write:\n\n\n@wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say():\n    return 'hello'\n\n\n\nor\n\n\nmakebold = wrap_in_tag('b')\nmakeitalic = wrap_in_tag('i')\n\n@makebold\n@makeitalic\ndef say():\n    return 'hello'\n\n\n\nPersonally I would have written the decorator somewhat differently:\n\n\nfrom functools import wraps\n\ndef wrap_in_tag(tag):\n    def factory(func):\n        @wraps(func)\n        def decorator(val):\n            return func('<%(tag)s>%(val)s\n' %\n                        {'tag': tag, 'val': val})\n        return decorator\n    return factory\n\n\n\nwhich would yield:\n\n\n@wrap_in_tag('b')\n@wrap_in_tag('i')\ndef say(val):\n    return val\nsay('hello')\n\n\n\nDon't forget the construction for which decorator syntax is a shorthand:\n\n\nsay = wrap_in_tag('b')(wrap_in_tag('i')(say)))\n\n\n", "score": 162}}
{"question": "How do I make function decorators and chain them together?", "tags": ["python", "function", "decorator", "python-decorators", "chain"], "link": "https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together", "answer_count": 22, "answers": {"id": 739665, "body": "Check out \nthe documentation\n to see how decorators work. Here is what you asked for:\n\n\nfrom functools import wraps\n\ndef makebold(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return \"\n\" + fn(*args, **kwargs) + \"\n\"\n    return wrapper\n\ndef makeitalic(fn):\n    @wraps(fn)\n    def wrapper(*args, **kwargs):\n        return \"\n\" + fn(*args, **kwargs) + \"\n\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef hello():\n    return \"hello world\"\n\n@makebold\n@makeitalic\ndef log(s):\n    return s\n\nprint hello()        # returns \"\nhello world\n\"\nprint hello.__name__ # with functools.wraps() this returns \"hello\"\nprint log('hello')   # returns \"\nhello\n\"\n\n\n", "score": 3101}}
{"question": "How do I make function decorators and chain them together?", "tags": ["python", "function", "decorator", "python-decorators", "chain"], "link": "https://stackoverflow.com/questions/739654/how-do-i-make-function-decorators-and-chain-them-together", "answer_count": 22, "answers": {"id": 1594484, "body": "If you are not into long explanations, see \nPaolo Bergantino\u2019s answer\n.\n\n\nDecorator Basics\n\n\nPython\u2019s functions are objects\n\n\nTo understand decorators, you must first understand that functions are objects in Python. This has important consequences. Let\u2019s see why with a simple example :\n\n\ndef shout(word=\"yes\"):\n    return word.capitalize()+\"!\"\n\nprint(shout())\n# outputs : 'Yes!'\n\n# As an object, you can assign the function to a variable like any other object \nscream = shout\n\n# Notice we don't use parentheses: we are not calling the function,\n# we are putting the function \"shout\" into the variable \"scream\".\n# It means you can then call \"shout\" from \"scream\":\n\nprint(scream())\n# outputs : 'Yes!'\n\n# More than that, it means you can remove the old name 'shout',\n#\u00a0and the function will still be accessible from 'scream'\n\ndel shout\ntry:\n    print(shout())\nexcept NameError as e:\n    print(e)\n    #outputs: \"name 'shout' is not defined\"\n\nprint(scream())\n# outputs: 'Yes!'\n\n\n\nKeep this in mind. We\u2019ll circle back to it shortly.\n\n\nAnother interesting property of Python functions is they can be defined inside another function!\n\n\ndef talk():\n\n    # You can define a function on the fly in \"talk\" ...\n    def whisper(word=\"yes\"):\n        return word.lower()+\"...\"\n\n    # ... and use it right away!\n    print(whisper())\n\n# You call \"talk\", that defines \"whisper\" EVERY TIME you call it, then\n# \"whisper\" is called in \"talk\". \ntalk()\n# outputs: \n# \"yes...\"\n\n# But \"whisper\" DOES NOT EXIST outside \"talk\":\n\ntry:\n    print(whisper())\nexcept NameError as e:\n    print(e)\n    #outputs : \"name 'whisper' is not defined\"*\n    #Python's functions are objects\n\n\n\nFunctions references\n\n\nOkay, still here? Now the fun part...\n\n\nYou\u2019ve seen that functions are objects. Therefore, functions:\n\n\n\n\ncan be assigned to a variable\n\n\ncan be defined in another function\n\n\n\n\nThat means that \na function can \nreturn\n another function\n.\n\n\ndef getTalk(kind=\"shout\"):\n\n    # We define functions on the fly\n    def shout(word=\"yes\"):\n        return word.capitalize()+\"!\"\n\n    def whisper(word=\"yes\") :\n        return word.lower()+\"...\"\n\n    # Then we return one of them\n    if kind == \"shout\":\n        # We don't use \"()\", we are not calling the function,\n        # we are returning the function object\n        return shout  \n    else:\n        return whisper\n\n# How do you use this strange beast?\n\n# Get the function and assign it to a variable\ntalk = getTalk()      \n\n# You can see that \"talk\" is here a function object:\nprint(talk)\n#outputs : \n\n\n# The object is the one returned by the function:\nprint(talk())\n#outputs : Yes!\n\n# And you can even use it directly if you feel wild:\nprint(getTalk(\"whisper\")())\n#outputs : yes...\n\n\n\nThere\u2019s more!\n\n\nIf you can \nreturn\n a function, you can pass one as a parameter:\n\n\ndef doSomethingBefore(func): \n    print(\"I do something before then I call the function you gave me\")\n    print(func())\n\ndoSomethingBefore(scream)\n#outputs: \n#I do something before then I call the function you gave me\n#Yes!\n\n\n\nWell, you just have everything needed to understand decorators. You see, decorators are \u201cwrappers\u201d, which means that \nthey let you execute code before and after the function they decorate\n without modifying the function itself.\n\n\nHandcrafted decorators\n\n\nHow you\u2019d do it manually:\n\n\n# A decorator is a function that expects ANOTHER function as parameter\ndef my_shiny_new_decorator(a_function_to_decorate):\n\n    # Inside, the decorator defines a function on the fly: the wrapper.\n    # This function is going to be wrapped around the original function\n    # so it can execute code before and after it.\n    def the_wrapper_around_the_original_function():\n\n        # Put here the code you want to be executed BEFORE the original function is called\n        print(\"Before the function runs\")\n\n        # Call the function here (using parentheses)\n        a_function_to_decorate()\n\n        # Put here the code you want to be executed AFTER the original function is called\n        print(\"After the function runs\")\n\n    # At this point, \"a_function_to_decorate\" HAS NEVER BEEN EXECUTED.\n    # We return the wrapper function we have just created.\n    # The wrapper contains the function and the code to execute before and after. It\u2019s ready to use!\n    return the_wrapper_around_the_original_function\n\n# Now imagine you create a function you don't want to ever touch again.\ndef a_stand_alone_function():\n    print(\"I am a stand alone function, don't you dare modify me\")\n\na_stand_alone_function() \n#outputs: I am a stand alone function, don't you dare modify me\n\n# Well, you can decorate it to extend its behavior.\n# Just pass it to the decorator, it will wrap it dynamically in \n# any code you want and return you a new function ready to be used:\n\na_stand_alone_function_decorated = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function_decorated()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n\n\n\nNow, you probably want that every time you call \na_stand_alone_function\n, \na_stand_alone_function_decorated\n is called instead. That\u2019s easy, just overwrite \na_stand_alone_function\n with the function returned by \nmy_shiny_new_decorator\n:\n\n\na_stand_alone_function = my_shiny_new_decorator(a_stand_alone_function)\na_stand_alone_function()\n#outputs:\n#Before the function runs\n#I am a stand alone function, don't you dare modify me\n#After the function runs\n\n# That\u2019s EXACTLY what decorators do!\n\n\n\nDecorators demystified\n\n\nThe previous example, using the decorator syntax:\n\n\n@my_shiny_new_decorator\ndef another_stand_alone_function():\n    print(\"Leave me alone\")\n\nanother_stand_alone_function()  \n#outputs:  \n#Before the function runs\n#Leave me alone\n#After the function runs\n\n\n\nYes, that\u2019s all, it\u2019s that simple. \n@decorator\n is just a shortcut to:\n\n\nanother_stand_alone_function = my_shiny_new_decorator(another_stand_alone_function)\n\n\n\nDecorators are just a pythonic variant of the \ndecorator design pattern\n. There are several classic design patterns embedded in Python to ease development (like iterators).\n\n\nOf course, you can accumulate decorators:\n\n\ndef bread(func):\n    def wrapper():\n        print(\"\n\")\n        func()\n        print(\"<\\______/>\")\n    return wrapper\n\ndef ingredients(func):\n    def wrapper():\n        print(\"#tomatoes#\")\n        func()\n        print(\"~salad~\")\n    return wrapper\n\ndef sandwich(food=\"--ham--\"):\n    print(food)\n\nsandwich()\n#outputs: --ham--\nsandwich = bread(ingredients(sandwich))\nsandwich()\n#outputs:\n#\n\n# #tomatoes#\n# --ham--\n# ~salad~\n#<\\______/>\n\n\n\nUsing the Python decorator syntax:\n\n\n@bread\n@ingredients\ndef sandwich(food=\"--ham--\"):\n    print(food)\n\nsandwich()\n#outputs:\n#\n\n# #tomatoes#\n# --ham--\n# ~salad~\n#<\\______/>\n\n\n\nThe order you set the decorators MATTERS:\n\n\n@ingredients\n@bread\ndef strange_sandwich(food=\"--ham--\"):\n    print(food)\n\nstrange_sandwich()\n#outputs:\n##tomatoes#\n#\n\n# --ham--\n#<\\______/>\n# ~salad~\n\n\n\n\n\nNow: to answer the question...\n\n\nAs a conclusion, you can easily see how to answer the question:\n\n\n# The decorator to make it bold\ndef makebold(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"\n\" + fn() + \"\n\"\n    return wrapper\n\n# The decorator to make it italic\ndef makeitalic(fn):\n    # The new function the decorator returns\n    def wrapper():\n        # Insertion of some code before and after\n        return \"\n\" + fn() + \"\n\"\n    return wrapper\n\n@makebold\n@makeitalic\ndef say():\n    return \"hello\"\n\nprint(say())\n#outputs: \nhello\n\n\n# This is the exact equivalent to \ndef say():\n    return \"hello\"\nsay = makebold(makeitalic(say))\n\nprint(say())\n#outputs: \nhello\n\n\n\n\nYou can now just leave happy, or burn your brain a little bit more and see advanced uses of decorators.\n\n\n\n\nTaking decorators to the next level\n\n\nPassing arguments to the decorated function\n\n\n# It\u2019s not black magic, you just have to let the wrapper \n# pass the argument:\n\ndef a_decorator_passing_arguments(function_to_decorate):\n    def a_wrapper_accepting_arguments(arg1, arg2):\n        print(\"I got args! Look: {0}, {1}\".format(arg1, arg2))\n        function_to_decorate(arg1, arg2)\n    return a_wrapper_accepting_arguments\n\n# Since when you are calling the function returned by the decorator, you are\n# calling the wrapper, passing arguments to the wrapper will let it pass them to \n# the decorated function\n\n@a_decorator_passing_arguments\ndef print_full_name(first_name, last_name):\n    print(\"My name is {0} {1}\".format(first_name, last_name))\n    \nprint_full_name(\"Peter\", \"Venkman\")\n# outputs:\n#I got args! Look: Peter Venkman\n#My name is Peter Venkman\n\n\n\nDecorating methods\n\n\nOne nifty thing about Python is that methods and functions are really the same.  The only difference is that methods expect that their first argument is a reference to the current object (\nself\n).\n\n\nThat means you can build a decorator for methods the same way! Just remember to take \nself\n into consideration:\n\n\ndef method_friendly_decorator(method_to_decorate):\n    def wrapper(self, lie):\n        lie = lie - 3 # very friendly, decrease age even more :-)\n        return method_to_decorate(self, lie)\n    return wrapper\n    \n    \nclass Lucy(object):\n    \n    def __init__(self):\n        self.age = 32\n    \n    @method_friendly_decorator\n    def sayYourAge(self, lie):\n        print(\"I am {0}, what did you think?\".format(self.age + lie))\n        \nl = Lucy()\nl.sayYourAge(-3)\n#outputs: I am 26, what did you think?\n\n\n\nIf you\u2019re making general-purpose decorator--one you\u2019ll apply to any function or method, no matter its arguments--then just use \n*args, **kwargs\n:\n\n\ndef a_decorator_passing_arbitrary_arguments(function_to_decorate):\n    # The wrapper accepts any arguments\n    def a_wrapper_accepting_arbitrary_arguments(*args, **kwargs):\n        print(\"Do I have args?:\")\n        print(args)\n        print(kwargs)\n        # Then you unpack the arguments, here *args, **kwargs\n        # If you are not familiar with unpacking, check:\n        # http://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/\n        function_to_decorate(*args, **kwargs)\n    return a_wrapper_accepting_arbitrary_arguments\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_no_argument():\n    print(\"Python is cool, no argument here.\")\n\nfunction_with_no_argument()\n#outputs\n#Do I have args?:\n#()\n#{}\n#Python is cool, no argument here.\n\n@a_decorator_passing_arbitrary_arguments\ndef function_with_arguments(a, b, c):\n    print(a, b, c)\n    \nfunction_with_arguments(1,2,3)\n#outputs\n#Do I have args?:\n#(1, 2, 3)\n#{}\n#1 2 3 \n \n@a_decorator_passing_arbitrary_arguments\ndef function_with_named_arguments(a, b, c, platypus=\"Why not ?\"):\n    print(\"Do {0}, {1} and {2} like platypus? {3}\".format(a, b, c, platypus))\n\nfunction_with_named_arguments(\"Bill\", \"Linus\", \"Steve\", platypus=\"Indeed!\")\n#outputs\n#Do I have args ? :\n#('Bill', 'Linus', 'Steve')\n#{'platypus': 'Indeed!'}\n#Do Bill, Linus and Steve like platypus? Indeed!\n\nclass Mary(object):\n    \n    def __init__(self):\n        self.age = 31\n    \n    @a_decorator_passing_arbitrary_arguments\n    def sayYourAge(self, lie=-3): # You can now add a default value\n        print(\"I am {0}, what did you think?\".format(self.age + lie))\n\nm = Mary()\nm.sayYourAge()\n#outputs\n# Do I have args?:\n#(<__main__.Mary object at 0xb7d303ac>,)\n#{}\n#I am 28, what did you think?\n\n\n\nPassing arguments to the decorator\n\n\nGreat, now what would you say about passing arguments to the decorator itself?\n\n\nThis can get somewhat twisted, since a decorator must accept a function as an argument. Therefore, you cannot pass the decorated function\u2019s arguments directly to the decorator.\n\n\nBefore rushing to the solution, let\u2019s write a little reminder:\n\n\n# Decorators are ORDINARY functions\ndef my_decorator(func):\n    print(\"I am an ordinary function\")\n    def wrapper():\n        print(\"I am function returned by the decorator\")\n        func()\n    return wrapper\n\n# Therefore, you can call it without any \"@\"\n\ndef lazy_function():\n    print(\"zzzzzzzz\")\n\ndecorated_function = my_decorator(lazy_function)\n#outputs: I am an ordinary function\n            \n# It outputs \"I am an ordinary function\", because that\u2019s just what you do:\n# calling a function. Nothing magic.\n\n@my_decorator\ndef lazy_function():\n    print(\"zzzzzzzz\")\n    \n#outputs: I am an ordinary function\n\n\n\nIt\u2019s exactly the same. \"\nmy_decorator\n\" is called. So when you \n@my_decorator\n, you are telling Python to call the function 'labelled by the variable \"\nmy_decorator\n\"'.\n\n\nThis is important! The label you give can point directly to the decorator\u2014\nor not\n.\n\n\nLet\u2019s get evil. \u263a\n\n\ndef decorator_maker():\n    \n    print(\"I make decorators! I am executed only once: \"\n          \"when you make me create a decorator.\")\n            \n    def my_decorator(func):\n        \n        print(\"I am a decorator! I am executed only when you decorate a function.\")\n               \n        def wrapped():\n            print(\"I am the wrapper around the decorated function. \"\n                  \"I am called when you call the decorated function. \"\n                  \"As the wrapper, I return the RESULT of the decorated function.\")\n            return func()\n        \n        print(\"As the decorator, I return the wrapped function.\")\n        \n        return wrapped\n    \n    print(\"As a decorator maker, I return a decorator\")\n    return my_decorator\n            \n# Let\u2019s create a decorator. It\u2019s just a new function after all.\nnew_decorator = decorator_maker()       \n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n\n# Then we decorate the function\n            \ndef decorated_function():\n    print(\"I am the decorated function.\")\n   \ndecorated_function = new_decorator(decorated_function)\n#outputs:\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function\n     \n# Let\u2019s call the function:\ndecorated_function()\n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n\n\n\nNo surprise here.\n\n\nLet\u2019s do EXACTLY the same thing, but skip all the pesky intermediate variables:\n\n\ndef decorated_function():\n    print(\"I am the decorated function.\")\ndecorated_function = decorator_maker()(decorated_function)\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n# Finally:\ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n\n\n\nLet\u2019s make it \neven shorter\n:\n\n\n@decorator_maker()\ndef decorated_function():\n    print(\"I am the decorated function.\")\n#outputs:\n#I make decorators! I am executed only once: when you make me create a decorator.\n#As a decorator maker, I return a decorator\n#I am a decorator! I am executed only when you decorate a function.\n#As the decorator, I return the wrapped function.\n\n#Eventually: \ndecorated_function()    \n#outputs:\n#I am the wrapper around the decorated function. I am called when you call the decorated function.\n#As the wrapper, I return the RESULT of the decorated function.\n#I am the decorated function.\n\n\n\nHey, did you see that? We used a function call with the \"\n@\n\" syntax! :-)\n\n\nSo, back to decorators with arguments. If we can use functions to generate the decorator on the fly, we can pass arguments to that function, right?\n\n\ndef decorator_maker_with_arguments(decorator_arg1, decorator_arg2):\n    \n    print(\"I make decorators! And I accept arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2))\n            \n    def my_decorator(func):\n        # The ability to pass arguments here is a gift from closures.\n        # If you are not comfortable with closures, you can assume it\u2019s ok,\n        # or read: https://stackoverflow.com/questions/13857/can-you-explain-closures-as-they-relate-to-python\n        print(\"I am the decorator. Somehow you passed me arguments: {0}, {1}\".format(decorator_arg1, decorator_arg2))\n               \n        # Don't confuse decorator arguments and function arguments!\n        def wrapped(function_arg1, function_arg2) :\n            print(\"I am the wrapper around the decorated function.\\n\"\n                  \"I can access all the variables\\n\"\n                  \"\\t- from the decorator: {0} {1}\\n\"\n                  \"\\t- from the function call: {2} {3}\\n\"\n                  \"Then I can pass them to the decorated function\"\n                  .format(decorator_arg1, decorator_arg2,\n                          function_arg1, function_arg2))\n            return func(function_arg1, function_arg2)\n        \n        return wrapped\n    \n    return my_decorator\n\n@decorator_maker_with_arguments(\"Leonard\", \"Sheldon\")\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(\"I am the decorated function and only knows about my arguments: {0}\"\n           \" {1}\".format(function_arg1, function_arg2))\n          \ndecorated_function_with_arguments(\"Rajesh\", \"Howard\")\n#outputs:\n#I make decorators! And I accept arguments: Leonard Sheldon\n#I am the decorator. Somehow you passed me arguments: Leonard Sheldon\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Sheldon \n#   - from the function call: Rajesh Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only knows about my arguments: Rajesh Howard\n\n\n\nHere it is: a decorator with arguments. Arguments can be set as variable:\n\n\nc1 = \"Penny\"\nc2 = \"Leslie\"\n\n@decorator_maker_with_arguments(\"Leonard\", c1)\ndef decorated_function_with_arguments(function_arg1, function_arg2):\n    print(\"I am the decorated function and only knows about my arguments:\"\n           \" {0} {1}\".format(function_arg1, function_arg2))\n\ndecorated_function_with_arguments(c2, \"Howard\")\n#outputs:\n#I make decorators! And I accept arguments: Leonard Penny\n#I am the decorator. Somehow you passed me arguments: Leonard Penny\n#I am the wrapper around the decorated function. \n#I can access all the variables \n#   - from the decorator: Leonard Penny \n#   - from the function call: Leslie Howard \n#Then I can pass them to the decorated function\n#I am the decorated function and only know about my arguments: Leslie Howard\n\n\n\nAs you can see, you can pass arguments to the decorator like any function using this trick. You can even use \n*args, **kwargs\n if you wish. But remember decorators are called \nonly once\n. Just when Python imports the script. You can't dynamically set the arguments afterwards. When you do \"import x\", \nthe function is already decorated\n, so you can't\nchange anything.\n\n\n\n\nLet\u2019s practice: decorating a decorator\n\n\nOkay, as a bonus, I'll give you a snippet to make any decorator accept generically any argument. After all, in order to accept arguments, we created our decorator using another function.\n\n\nWe wrapped the decorator.\n\n\nAnything else we saw recently that wrapped function?\n\n\nOh yes, decorators!\n\n\nLet\u2019s have some fun and write a decorator for the decorators:\n\n\ndef decorator_with_args(decorator_to_enhance):\n    \"\"\" \n    This function is supposed to be used as a decorator.\n    It must decorate an other function, that is intended to be used as a decorator.\n    Take a cup of coffee.\n    It will allow any decorator to accept an arbitrary number of arguments,\n    saving you the headache to remember how to do that every time.\n    \"\"\"\n    \n    # We use the same trick we did to pass arguments\n    def decorator_maker(*args, **kwargs):\n       \n        # We create on the fly a decorator that accepts only a function\n        # but keeps the passed arguments from the maker.\n        def decorator_wrapper(func):\n       \n            # We return the result of the original decorator, which, after all, \n            # IS JUST AN ORDINARY FUNCTION (which returns a function).\n            # Only pitfall: the decorator must have this specific signature or it won't work:\n            return decorator_to_enhance(func, *args, **kwargs)\n        \n        return decorator_wrapper\n    \n    return decorator_maker\n       \n\n\n\nIt can be used as follows:\n\n\n# You create the function you will use as a decorator. And stick a decorator on it :-)\n# Don't forget, the signature is \"decorator(func, *args, **kwargs)\"\n@decorator_with_args \ndef decorated_decorator(func, *args, **kwargs): \n    def wrapper(function_arg1, function_arg2):\n        print(\"Decorated with {0} {1}\".format(args, kwargs))\n        return func(function_arg1, function_arg2)\n    return wrapper\n    \n# Then you decorate the functions you wish with your brand new decorated decorator.\n\n@decorated_decorator(42, 404, 1024)\ndef decorated_function(function_arg1, function_arg2):\n    print(\"Hello {0} {1}\".format(function_arg1, function_arg2))\n\ndecorated_function(\"Universe and\", \"everything\")\n#outputs:\n#Decorated with (42, 404, 1024) {}\n#Hello Universe and everything\n\n# Whoooot!\n\n\n\nI know, the last time you had this feeling, it was after listening a guy saying: \"before understanding recursion, you must first understand recursion\". But now, don't you feel good about mastering this?\n\n\n\n\nBest practices: decorators\n\n\n\n\nDecorators were introduced in Python 2.4, so be sure your code will be run on >= 2.4.\n\n\nDecorators slow down the function call. Keep that in mind.\n\n\nYou cannot un-decorate a function.\n (There \nare\n hacks to create decorators that can be removed, but nobody uses them.) So once a function is decorated, it\u2019s decorated \nfor all the code\n.\n\n\nDecorators wrap functions, which can make them hard to debug.  (This gets better from Python >= 2.5; see below.)\n\n\n\n\nThe \nfunctools\n module was introduced in Python 2.5. It includes the function \nfunctools.wraps()\n, which copies the name, module, and docstring of the decorated function to its wrapper.\n\n\n(Fun fact: \nfunctools.wraps()\n is a decorator! \u263a)\n\n\n# For debugging, the stacktrace prints you the function __name__\ndef foo():\n    print(\"foo\")\n    \nprint(foo.__name__)\n#outputs: foo\n    \n# With a decorator, it gets messy    \ndef bar(func):\n    def wrapper():\n        print(\"bar\")\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(\"foo\")\n\nprint(foo.__name__)\n#outputs: wrapper\n\n# \"functools\" can help for that\n\nimport functools\n\ndef bar(func):\n    # We say that \"wrapper\", is wrapping \"func\"\n    # and the magic begins\n    @functools.wraps(func)\n    def wrapper():\n        print(\"bar\")\n        return func()\n    return wrapper\n\n@bar\ndef foo():\n    print(\"foo\")\n\nprint(foo.__name__)\n#outputs: foo\n\n\n\n\n\nHow can the decorators be useful?\n\n\nNow the big question:\n What can I use decorators for?\n\n\nSeem cool and powerful, but a practical example would be great. Well, there are 1000 possibilities. Classic uses are extending a function behavior from an external lib (you can't modify it), or for debugging (you don't want to modify it because it\u2019s temporary).\n\n\nYou can use them to extend several functions in a DRY\u2019s way, like so:\n\n\ndef benchmark(func):\n    \"\"\"\n    A decorator that prints the time a function takes\n    to execute.\n    \"\"\"\n    import time\n    def wrapper(*args, **kwargs):\n        t = time.clock()\n        res = func(*args, **kwargs)\n        print(\"{0} {1}\".format(func.__name__, time.clock()-t))\n        return res\n    return wrapper\n\n\ndef logging(func):\n    \"\"\"\n    A decorator that logs the activity of the script.\n    (it actually just prints it, but it could be logging!)\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        res = func(*args, **kwargs)\n        print(\"{0} {1} {2}\".format(func.__name__, args, kwargs))\n        return res\n    return wrapper\n\n\ndef counter(func):\n    \"\"\"\n    A decorator that counts and prints the number of times a function has been executed\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        wrapper.count = wrapper.count + 1\n        res = func(*args, **kwargs)\n        print(\"{0} has been used: {1}x\".format(func.__name__, wrapper.count))\n        return res\n    wrapper.count = 0\n    return wrapper\n\n@counter\n@benchmark\n@logging\ndef reverse_string(string):\n    return str(reversed(string))\n\nprint(reverse_string(\"Able was I ere I saw Elba\"))\nprint(reverse_string(\"A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!\"))\n\n#outputs:\n#reverse_string ('Able was I ere I saw Elba',) {}\n#wrapper 0.0\n#wrapper has been used: 1x \n#ablE was I ere I saw elbA\n#reverse_string ('A man, a plan, a canoe, pasta, heros, rajahs, a coloratura, maps, snipe, percale, macaroni, a gag, a banana bag, a tan, a tag, a banana bag again (or a camel), a crepe, pins, Spam, a rut, a Rolo, cash, a jar, sore hats, a peon, a canal: Panama!',) {}\n#wrapper 0.0\n#wrapper has been used: 2x\n#!amanaP :lanac a ,noep a ,stah eros ,raj a ,hsac ,oloR a ,tur a ,mapS ,snip ,eperc a ,)lemac a ro( niaga gab ananab a ,gat a ,nat a ,gab ananab a ,gag a ,inoracam ,elacrep ,epins ,spam ,arutaroloc a ,shajar ,soreh ,atsap ,eonac a ,nalp a ,nam A\n\n\n\nOf course the good thing with decorators is that you can use them right away on almost anything without rewriting. DRY, I said:\n\n\n@counter\n@benchmark\n@logging\ndef get_random_futurama_quote():\n    from urllib import urlopen\n    result = urlopen(\"http://subfusion.net/cgi-bin/quote.pl?quote=futurama\").read()\n    try:\n        value = result.split(\"\n\")[1].split(\"\n\")[0]\n        return value.strip()\n    except:\n        return \"No, I'm ... doesn't!\"\n\n    \nprint(get_random_futurama_quote())\nprint(get_random_futurama_quote())\n\n#outputs:\n#get_random_futurama_quote () {}\n#wrapper 0.02\n#wrapper has been used: 1x\n#The laws of science be a harsh mistress.\n#get_random_futurama_quote () {}\n#wrapper 0.01\n#wrapper has been used: 2x\n#Curse you, merciful Poseidon!\n\n\n\nPython itself provides several decorators: \nproperty\n, \nstaticmethod\n, etc.\n\n\n\n\nDjango uses decorators to manage caching and view permissions.\n\n\nTwisted to fake inlining asynchronous functions calls.\n\n\n\n\nThis really is a large playground.\n\n", "score": 4872}}
{"question": "How do I check if a list is empty?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty", "answer_count": 27, "answers": {"id": 7302987, "body": "I prefer it explicitly:\n\n\nif len(li) == 0:\n    print('the list is empty')\n\n\n\nThis way it's 100% clear that \nli\n is a sequence (list) and we want to test its size. My problem with \nif not li: ...\n is that it gives the false impression that \nli\n is a boolean variable.\n\n", "score": 1138}}
{"question": "How do I check if a list is empty?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty", "answer_count": 27, "answers": {"id": 53752, "body": "The Pythonic way to do it is from the \nPEP 8 style guide\n.\n\n\n\n\nFor sequences, (strings, lists, tuples), use the fact that empty sequences are false:\n\n\n# Correct:\nif not seq:\nif seq:\n\n# Wrong:\nif len(seq):\nif not len(seq):\n\n\n\n\n", "score": 1544}}
{"question": "How do I check if a list is empty?", "tags": ["python", "list"], "link": "https://stackoverflow.com/questions/53513/how-do-i-check-if-a-list-is-empty", "answer_count": 27, "answers": {"id": 53522, "body": "if not a:\n    print(\"List is empty\")\n\n\n\nUsing the \nimplicit booleanness\n of the empty \nlist\n is quite Pythonic.\n\n", "score": 7280}}
{"question": "How do I concatenate two lists in Python?", "tags": ["python", "list", "concatenation"], "link": "https://stackoverflow.com/questions/1720421/how-do-i-concatenate-two-lists-in-python", "answer_count": 31, "answers": {"id": 1724975, "body": "It's also possible to create a generator that simply iterates over the items in both lists using \nitertools.chain()\n. This allows you to chain lists (or any iterable) together for processing without copying the items to a new list:\n\n\nimport itertools\nfor item in itertools.chain(listone, listtwo):\n    # Do something with each list item\n\n\n", "score": 406}}
{"question": "How do I concatenate two lists in Python?", "tags": ["python", "list", "concatenation"], "link": "https://stackoverflow.com/questions/1720421/how-do-i-concatenate-two-lists-in-python", "answer_count": 31, "answers": {"id": 35631185, "body": "Python >= 3.5 alternative: \n[*l1, *l2]\n\n\nAnother alternative has been introduced via the acceptance of \nPEP 448\n which deserves mentioning.\n\n\nThe PEP, titled \nAdditional Unpacking Generalizations\n, generally reduced some syntactic restrictions when using the starred \n*\n expression in Python; with it, joining two lists (applies to any iterable) can now also be done with:\n\n\n>>> l1 = [1, 2, 3]\n>>> l2 = [4, 5, 6]\n>>> joined_list = [*l1, *l2]  # unpack both iterables in a list literal\n>>> print(joined_list)\n[1, 2, 3, 4, 5, 6]\n\n\n\nThis functionality \nwas defined\n for Python 3.5, but it hasn't been backported to previous versions in the 3.x family. In unsupported versions a \nSyntaxError\n is going to be raised.\n\n\nAs with the other approaches, this too \ncreates as shallow copy\n of the elements in the corresponding lists.\n\n\n\n\nThe \nupside\n to this approach is that you really don't need lists in order to perform it; anything that is iterable will do. As stated in the PEP:\n\n\n\n\nThis is also useful as a more readable way of summing iterables into a\nlist, such as \nmy_list + list(my_tuple) + list(my_range)\n which is now\nequivalent to just \n[*my_list, *my_tuple, *my_range]\n.\n\n\n\n\nSo while addition with \n+\n would raise a \nTypeError\n due to type mismatch:\n\n\nl = [1, 2, 3]\nr = range(4, 7)\nres = l + r\n\n\n\nThe following won't:\n\n\nres = [*l, *r]\n\n\n\nbecause it will first unpack the contents of the iterables and then simply create a \nlist\n from the contents.\n\n", "score": 681}}
{"question": "How do I concatenate two lists in Python?", "tags": ["python", "list", "concatenation"], "link": "https://stackoverflow.com/questions/1720421/how-do-i-concatenate-two-lists-in-python", "answer_count": 31, "answers": {"id": 1720432, "body": "Use the \n+\n operator to combine the lists:\n\n\nlistone = [1, 2, 3]\nlisttwo = [4, 5, 6]\n\njoinedlist = listone + listtwo\n\n\n\nOutput:\n\n\n>>> joinedlist\n[1, 2, 3, 4, 5, 6]\n\n\n\nNOTE: This will create a new list with a shallow copy of the items in the first list, followed by a shallow copy of the items in the second list. Use \ncopy.deepcopy()\n to get deep copies of lists.\n\n", "score": 5607}}
{"question": "How do I change the size of figures drawn with Matplotlib?", "tags": ["python", "pandas", "matplotlib", "seaborn", "figsize"], "link": "https://stackoverflow.com/questions/332289/how-do-i-change-the-size-of-figures-drawn-with-matplotlib", "answer_count": 16, "answers": {"id": 41717533, "body": "Using plt.rcParams\n\n\nThere is also this workaround in case you want to change the size without using the figure environment. So in case you are using \nplt.plot()\n for example, you can set a tuple with width and height.\n\n\nimport matplotlib.pyplot as plt\nplt.rcParams[\"figure.figsize\"] = (20,3)\n\n\n\nThis is very useful when you plot inline (e.g., with \nIPython Notebook\n). As \nasmaier noticed\n, it is preferable to not put this statement in the same cell of the imports statements.\n\n\nTo reset the global figure size back to default for subsequent plots:\n\n\nplt.rcParams[\"figure.figsize\"] = plt.rcParamsDefault[\"figure.figsize\"]\n\n\n\nConversion to cm\n\n\nThe \nfigsize\n tuple accepts inches, so if you want to set it in centimetres you have to divide them by 2.54. Have a look at \nthis question\n.\n\n", "score": 802}}
{"question": "How do I change the size of figures drawn with Matplotlib?", "tags": ["python", "pandas", "matplotlib", "seaborn", "figsize"], "link": "https://stackoverflow.com/questions/332289/how-do-i-change-the-size-of-figures-drawn-with-matplotlib", "answer_count": 16, "answers": {"id": 4306340, "body": "If you've already got the figure created, you can use \nfigure.set_size_inches\n to adjust the figure size:\n\n\nfig = matplotlib.pyplot.gcf()\nfig.set_size_inches(18.5, 10.5)\nfig.savefig('test2png.png', dpi=100)\n\n\n\nTo propagate the size change to an existing GUI window, add \nforward=True\n:\n\n\nfig.set_size_inches(18.5, 10.5, forward=True)\n\n\n\nAdditionally as \nErik Shilts\n mentioned in the comments you can also use \nfigure.set_dpi\n to \"[s]et the resolution of the figure in dots-per-inch\"\n\n\nfig.set_dpi(100)\n\n\n", "score": 1189}}
{"question": "How do I change the size of figures drawn with Matplotlib?", "tags": ["python", "pandas", "matplotlib", "seaborn", "figsize"], "link": "https://stackoverflow.com/questions/332289/how-do-i-change-the-size-of-figures-drawn-with-matplotlib", "answer_count": 16, "answers": {"id": 638443, "body": "figure\n tells you the call signature:\n\n\nfrom matplotlib.pyplot import figure\n\nfigure(figsize=(8, 6), dpi=80)\n\n\n\nfigure(figsize=(1,1))\n would create an inch-by-inch image, which would be 80-by-80 pixels unless you also give a different dpi argument.\n\n", "score": 1923}}
{"question": "How do I make a time delay?", "tags": ["python", "delay", "sleep", "timedelay"], "link": "https://stackoverflow.com/questions/510348/how-do-i-make-a-time-delay", "answer_count": 13, "answers": {"id": 44666336, "body": "\n\nHow can I make a time delay in Python?\n\n\n\n\nIn a single thread I suggest the \nsleep function\n:\n\n\n>>> from time import sleep\n\n>>> sleep(4)\n\n\n\nThis function actually suspends the processing of the thread in which it is called by the operating system, allowing other threads and processes to execute while it sleeps.\n\n\nUse it for that purpose, or simply to delay a function from executing. For example:\n\n\n>>> def party_time():\n...     print('hooray!')\n...\n>>> sleep(3); party_time()\nhooray!\n\n\n\n\"hooray!\" is printed 3 seconds after I hit \nEnter\n.\n\n\nExample using \nsleep\n with multiple threads and processes\n\n\nAgain, \nsleep\n suspends your thread - it uses next to zero processing power.\n\n\nTo demonstrate, create a script like this (I first attempted this in an interactive Python 3.5 shell, but sub-processes can't find the \nparty_later\n function for some reason):\n\n\nfrom concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor, as_completed\nfrom time import sleep, time\n\ndef party_later(kind='', n=''):\n    sleep(3)\n    return kind + n + ' party time!: ' + __name__\n\ndef main():\n    with ProcessPoolExecutor() as proc_executor:\n        with ThreadPoolExecutor() as thread_executor:\n            start_time = time()\n            proc_future1 = proc_executor.submit(party_later, kind='proc', n='1')\n            proc_future2 = proc_executor.submit(party_later, kind='proc', n='2')\n            thread_future1 = thread_executor.submit(party_later, kind='thread', n='1')\n            thread_future2 = thread_executor.submit(party_later, kind='thread', n='2')\n            for f in as_completed([\n              proc_future1, proc_future2, thread_future1, thread_future2,]):\n                print(f.result())\n            end_time = time()\n    print('total time to execute four 3-sec functions:', end_time - start_time)\n\nif __name__ == '__main__':\n    main()\n\n\n\nExample output from this script:\n\n\nthread1 party time!: __main__\nthread2 party time!: __main__\nproc1 party time!: __mp_main__\nproc2 party time!: __mp_main__\ntotal time to execute four 3-sec functions: 3.4519670009613037\n\n\n\nMultithreading\n\n\nYou can trigger a function to be called at a later time in a separate thread with the \nTimer\n \nthreading\n object:\n\n\n>>> from threading import Timer\n>>> t = Timer(3, party_time, args=None, kwargs=None)\n>>> t.start()\n>>>\n>>> hooray!\n\n>>>\n\n\n\nThe blank line illustrates that the function printed to my standard output, and I had to hit \nEnter\n to ensure I was on a prompt.\n\n\nThe upside of this method is that while the \nTimer\n thread was waiting, I was able to do other things, in this case, hitting \nEnter\n one time - before the function executed (see the first empty prompt).\n\n\nThere isn't a respective object in the \nmultiprocessing library\n. You can create one, but it probably doesn't exist for a reason. A sub-thread makes a lot more sense for a simple timer than a whole new subprocess.\n\n", "score": 115}}
{"question": "How do I make a time delay?", "tags": ["python", "delay", "sleep", "timedelay"], "link": "https://stackoverflow.com/questions/510348/how-do-i-make-a-time-delay", "answer_count": 13, "answers": {"id": 64486, "body": "Use \nsleep()\n from the \ntime\n module. It can take a float argument for sub-second resolution.\n\n\nfrom time import sleep\nsleep(0.1)  # Time in seconds\n\n\n", "score": 876}}
{"question": "How do I make a time delay?", "tags": ["python", "delay", "sleep", "timedelay"], "link": "https://stackoverflow.com/questions/510348/how-do-i-make-a-time-delay", "answer_count": 13, "answers": {"id": 510351, "body": "This delays for 2.5 seconds:\n\n\nimport time\n\ntime.sleep(2.5)\n\n\n\n\n\nHere is another example where something is run approximately once a minute:\n\n\nimport time\n\nwhile True:\n    print(\"This prints once a minute.\")\n    time.sleep(60) # Delay for 1 minute (60 seconds).\n\n\n", "score": 3532}}
{"question": "Understanding Python super() with __init__() methods", "tags": ["python", "class", "oop", "inheritance", "super"], "link": "https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods", "answer_count": 7, "answers": {"id": 19257335, "body": "It's been noted that in Python 3.0+ you can use\n\n\nsuper().__init__()\n\n\n\nto make your call, which is concise and does not require you to reference the parent OR class names explicitly, which can be handy. I just want to add that for Python 2.7 or under, some people implement a name-insensitive behaviour by writing \nself.__class__\n instead of the class name, i.e.\n\n\nsuper(self.__class__, self).__init__()  # DON'T DO THIS!\n\n\n\nHOWEVER, this breaks calls to \nsuper\n for any classes that inherit from your class, where \nself.__class__\n could return a child class. For example:\n\n\nclass Polygon(object):\n    def __init__(self, id):\n        self.id = id\n\nclass Rectangle(Polygon):\n    def __init__(self, id, width, height):\n        super(self.__class__, self).__init__(id)\n        self.shape = (width, height)\n\nclass Square(Rectangle):\n    pass\n\n\n\nHere I have a class \nSquare\n, which is a sub-class of \nRectangle\n. Say I don't want to write a separate constructor for \nSquare\n because the constructor for \nRectangle\n is good enough, but for whatever reason I want to implement a Square so I can reimplement some other method.\n\n\nWhen I create a \nSquare\n using \nmSquare = Square('a', 10,10)\n, Python calls the constructor for \nRectangle\n because I haven't given \nSquare\n its own constructor. However, in the constructor for \nRectangle\n, the call \nsuper(self.__class__,self)\n is going to return the superclass of \nmSquare\n, so it calls the constructor for \nRectangle\n again. This is how the infinite loop happens, as was mentioned by @S_C. In this case, when I run \nsuper(...).__init__()\n I am calling the constructor for \nRectangle\n but since I give it no arguments, I will get an error.\n\n", "score": 283}}
{"question": "Understanding Python super() with __init__() methods", "tags": ["python", "class", "oop", "inheritance", "super"], "link": "https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods", "answer_count": 7, "answers": {"id": 27134600, "body": "\n\nI'm trying to understand \nsuper()\n\n\n\n\nThe reason we use \nsuper\n is so that child classes that may be using cooperative multiple inheritance will call the correct next parent class function in the Method Resolution Order (MRO).\n\n\nIn Python 3, we can call it like this:\n\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n\n\n\nIn Python 2, we were required to call \nsuper\n like this with the defining class's name and \nself\n, but we'll avoid this from now on because it's redundant, slower (due to the name lookups), and more verbose (so update your Python if you haven't already!):\n\n\n        super(ChildB, self).__init__()\n\n\n\nWithout super, you are limited in your ability to use multiple inheritance because you hard-wire the next parent's call:\n\n\n        Base.__init__(self) # Avoid this.\n\n\n\nI further explain below.\n\n\n\n\n\"What difference is there actually in this code?:\"\n\n\n\n\nclass ChildA(Base):\n    def __init__(self):\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        super().__init__()\n\n\n\nThe primary difference in this code is that in \nChildB\n you get a layer of indirection in the \n__init__\n with \nsuper\n, which uses the class in which it is defined to determine the next class's \n__init__\n to look up in the MRO.\n\n\nI illustrate this difference in an answer at the \ncanonical question, How to use 'super' in Python?\n, which demonstrates \ndependency injection\n and \ncooperative multiple inheritance\n.\n\n\nIf Python didn't have \nsuper\n\n\nHere's code that's actually closely equivalent to \nsuper\n (how it's implemented in C, minus some checking and fallback behavior, and translated to Python):\n\n\nclass ChildB(Base):\n    def __init__(self):\n        mro = type(self).mro()\n        check_next = mro.index(ChildB) + 1 # next after *this* class.\n        while check_next < len(mro):\n            next_class = mro[check_next]\n            if '__init__' in next_class.__dict__:\n                next_class.__init__(self)\n                break\n            check_next += 1\n\n\n\nWritten a little more like native Python:\n\n\nclass ChildB(Base):\n    def __init__(self):\n        mro = type(self).mro()\n        for next_class in mro[mro.index(ChildB) + 1:]: # slice to end\n            if hasattr(next_class, '__init__'):\n                next_class.__init__(self)\n                break\n\n\n\nIf we didn't have the \nsuper\n object, we'd have to write this manual code everywhere (or recreate it!) to ensure that we call the proper next method in the Method Resolution Order!\n\n\nHow does super do this in Python 3 without being told explicitly which class and instance from the method it was called from?\n\n\nIt gets the calling stack frame, and finds the class (implicitly stored as a local free variable, \n__class__\n, making the calling function a closure over the class) and the first argument to that function, which should be the instance or class that informs it which Method Resolution Order (MRO) to use.\n\n\nSince it requires that first argument for the MRO, \nusing \nsuper\n with static methods is impossible as they do not have access to the MRO of the class from which they are called\n.\n\n\nCriticisms of other answers:\n\n\n\n\nsuper()\n lets you avoid referring to the base class explicitly, which can be nice. . But the main advantage comes with multiple inheritance, where all sorts of fun stuff can happen. See the standard docs on super if you haven't already.\n\n\n\n\nIt's rather hand-wavey and doesn't tell us much, but the point of \nsuper\n is not to avoid writing the parent class. The point is to ensure that the next method in line in the method resolution order (MRO) is called. This becomes important in multiple inheritance.\n\n\nI'll explain here.\n\n\nclass Base(object):\n    def __init__(self):\n        print(\"Base init'ed\")\n\nclass ChildA(Base):\n    def __init__(self):\n        print(\"ChildA init'ed\")\n        Base.__init__(self)\n\nclass ChildB(Base):\n    def __init__(self):\n        print(\"ChildB init'ed\")\n        super().__init__()\n\n\n\nAnd let's create a dependency that we want to be called after the Child:\n\n\nclass UserDependency(Base):\n    def __init__(self):\n        print(\"UserDependency init'ed\")\n        super().__init__()\n\n\n\nNow remember, \nChildB\n uses super, \nChildA\n does not:\n\n\nclass UserA(ChildA, UserDependency):\n    def __init__(self):\n        print(\"UserA init'ed\")\n        super().__init__()\n\nclass UserB(ChildB, UserDependency):\n    def __init__(self):\n        print(\"UserB init'ed\")\n        super().__init__()\n\n\n\nAnd \nUserA\n does not call the UserDependency method:\n\n\n>>> UserA()\nUserA init'ed\nChildA init'ed\nBase init'ed\n<__main__.UserA object at 0x0000000003403BA8>\n\n\n\nBut \nUserB\n does in-fact call UserDependency because \nChildB\n invokes \nsuper\n:\n\n\n>>> UserB()\nUserB init'ed\nChildB init'ed\nUserDependency init'ed\nBase init'ed\n<__main__.UserB object at 0x0000000003403438>\n\n\n\nCriticism for another answer\n\n\nIn no circumstance should you do the following, which another answer suggests, as you'll definitely get errors when you subclass ChildB:\n\n\nsuper(self.__class__, self).__init__()  # DON'T DO THIS! EVER.\n\n\n\n(That answer is not clever or particularly interesting, but in spite of direct criticism in the comments and over 17 downvotes, the answerer persisted in suggesting it until a kind editor fixed his problem.)\n\n\nExplanation: Using \nself.__class__\n as a substitute for explicitly passing the class by name in \nsuper()\n will lead to recursion. \nsuper\n lets us look up the next parent in the MRO (see the first section of this answer) for child classes. If we tell \nsuper\n we're in the child's method, it will then lookup the next method in line (probably this same one we are calling it from) resulting in recursion, causing either a logical failure (as in the answerer's example) or a \nRuntimeError\n when the maximum recursion depth is exceeded.\n\n\nclass Polygon(object):\n    def __init__(self, id):\n        self.id = id\n\nclass Rectangle(Polygon):\n    def __init__(self, id, width, height):\n        super(self.__class__, self).__init__(id)\n        self.shape = (width, height)\n\nclass Square(Rectangle):\n    pass\n\n>>> Square('a', 10, 10)\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\n  File \"\n\", line 3, in __init__\nTypeError: __init__() missing 2 required positional arguments: 'width' and 'height'\n\n\n\nPython 3's new \nsuper()\n calling method with no arguments fortunately allows us to sidestep this issue.\n\n", "score": 1292}}
{"question": "Understanding Python super() with __init__() methods", "tags": ["python", "class", "oop", "inheritance", "super"], "link": "https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods", "answer_count": 7, "answers": {"id": 576183, "body": "super()\n lets you avoid referring to the base class explicitly, which can be nice. But the main advantage comes with multiple inheritance, where all sorts of \nfun stuff\n can happen. See the \nstandard docs on super\n if you haven't already.\n\n\nNote that \nthe syntax changed in Python 3.0\n: you can just say \nsuper().__init__()\n instead of \nsuper(ChildB, self).__init__()\n which IMO is quite a bit nicer. The standard docs also refer to a \nguide to using \nsuper()\n which is quite explanatory.\n\n", "score": 2362}}
{"question": "How do I print colored text to the terminal?", "tags": ["python", "terminal", "output", "ansi-colors"], "link": "https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal", "answer_count": 67, "answers": {"id": 3332860, "body": "The answer is \nColorama\n for all cross-platform coloring in Python.\n\n\nIt supports Python 3.5+ as well as Python 2.7.\n\n\nAnd as of January 2023, it is maintained.\n\n\nExample Code:\n\n\nfrom colorama import init as colorama_init\nfrom colorama import Fore\nfrom colorama import Style\n\ncolorama_init()\n\nprint(f\"This is {Fore.GREEN}color{Style.RESET_ALL}!\")\n\n\n\nExample Screenshot:\n\n\n", "score": 1107}}
{"question": "How do I print colored text to the terminal?", "tags": ["python", "terminal", "output", "ansi-colors"], "link": "https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal", "answer_count": 67, "answers": {"id": 293633, "body": "There is also the \nPython termcolor module\n. Usage is pretty simple:\n\n\nfrom termcolor import colored\n\nprint(colored('hello', 'red'), colored('world', 'green'))\n\n\n\nIt may not be sophisticated enough, however, for game programming and the \"colored blocks\" that you want to do...\n\n\nTo get the ANSI codes working on windows, first run\n\n\nos.system('color')\n\n\n", "score": 1214}}
{"question": "How do I print colored text to the terminal?", "tags": ["python", "terminal", "output", "ansi-colors"], "link": "https://stackoverflow.com/questions/287871/how-do-i-print-colored-text-to-the-terminal", "answer_count": 67, "answers": {"id": 287944, "body": "This somewhat depends on what platform you are on. The most common way to do this is by printing ANSI escape sequences. For a simple example, here's some Python code from the \nBlender build scripts\n:\n\n\nclass bcolors:\n    HEADER = '\\033[95m'\n    OKBLUE = '\\033[94m'\n    OKCYAN = '\\033[96m'\n    OKGREEN = '\\033[92m'\n    WARNING = '\\033[93m'\n    FAIL = '\\033[91m'\n    ENDC = '\\033[0m'\n    BOLD = '\\033[1m'\n    UNDERLINE = '\\033[4m'\n\n\n\nTo use code like this, you can do something like:\n\n\nprint(bcolors.WARNING + \"Warning: No active frommets remain. Continue?\" + bcolors.ENDC)\n\n\n\nOr, with Python 3.6+:\n\n\nprint(f\"{bcolors.WARNING}Warning: No active frommets remain. Continue?{bcolors.ENDC}\")\n\n\n\nThis will work on unixes including OS X, Linux and Windows (provided you use \nANSICON\n, or in Windows 10 provided you enable \nVT100 emulation\n). There are ANSI codes for setting the color, moving the cursor, and more.\n\n\nIf you are going to get complicated with this (and it sounds like you are if you are writing a game), you should look into the \"\ncurses\n\" module, which handles a lot of the complicated parts of this for you. The \nPython Curses HowTO\n is a good introduction.\n\n\nIf you are not using extended ASCII (i.e., not on a PC), you are stuck with the ASCII characters below 127, and '#' or '@' is probably your best bet for a block. If you can ensure your terminal is using a IBM \nextended ASCII character set\n, you have many more options. Characters 176, 177, 178 and 219 are the \"block characters\".\n\n\nSome modern text-based programs, such as \"Dwarf Fortress\", emulate text mode in a graphical mode, and use images of the classic PC font. You can find some of these bitmaps that you can use on the \nDwarf Fortress Wiki\n see (\nuser-made tilesets\n).\n\n\nThe \nText Mode Demo Contest\n has more resources for doing graphics in text mode.\n\n", "score": 2998}}
{"question": "Manually raising (throwing) an exception in Python", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python", "answer_count": 11, "answers": {"id": 40493467, "body": "In Python 3 there are four different syntaxes for raising exceptions:\n\n\n\n\nraise exception\n\n\nraise exception (args)\n\n\nraise\n\n\nraise exception (args) from original_exception\n\n\n\n\n1. Raise exception vs. 2. raise exception (args)\n\n\nIf you use \nraise exception (args)\n to raise an exception then the \nargs\n will be printed when you print the exception object - as shown in the example below.\n\n\n# Raise exception (args)\ntry:\n    raise ValueError(\"I have raised an Exception\")\nexcept ValueError as exp:\n    print(\"Error\", exp)     # Output -> Error I have raised an Exception\n\n\n# Raise exception\ntry:\n    raise ValueError\nexcept ValueError as exp:\n    print(\"Error\", exp)     # Output -> Error\n\n\n\n3. Statement \nraise\n\n\nThe \nraise\n statement without any arguments re-raises the last exception.\n\n\nThis is useful if you need to perform some actions after catching the exception and then want to re-raise it. But if there wasn't any exception before, the \nraise\n statement raises  a \nTypeError\n Exception.\n\n\ndef somefunction():\n    print(\"some cleaning\")\n\na = 10\nb = 0\nresult = None\n\ntry:\n    result = a / b\n    print(result)\n\nexcept Exception:            # Output ->\n    somefunction()           # Some cleaning\n    raise                    # Traceback (most recent call last):\n                             # File \"python\", line 9, in \n\n                             # ZeroDivisionError: division by zero\n\n\n\n4. Raise exception (args) from original_exception\n\n\nThis statement is used to create exception chaining in which an exception that is raised in response to another exception can contain the details of the original exception - as shown in the example below.\n\n\nclass MyCustomException(Exception):\n    pass\n\na = 10\nb = 0\nreuslt = None\ntry:\n    try:\n        result = a / b\n\n    except ZeroDivisionError as exp:\n        print(\"ZeroDivisionError -- \",exp)\n        raise MyCustomException(\"Zero Division \") from exp\n\nexcept MyCustomException as exp:\n    print(\"MyException\",exp)\n    print(exp.__cause__)\n\n\n\nOutput:\n\n\nZeroDivisionError --  division by zero\nMyException Zero Division\ndivision by zero\n\n\n", "score": 109}}
{"question": "Manually raising (throwing) an exception in Python", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python", "answer_count": 11, "answers": {"id": 2052396, "body": "\n\nDon't do this\n. Raising a bare \nException\n is absolutely \nnot\n the right thing to do; see \nAaron Hall's excellent answer\n instead.\n\n\n\n\nIt can't get much more Pythonic than this:\n\n\nraise Exception(\"I know Python!\")\n\n\n\nReplace \nException\n with the specific type of exception you want to throw.\n\n\nSee \nthe raise statement documentation\n for Python if you'd like more information.\n\n", "score": 583}}
{"question": "Manually raising (throwing) an exception in Python", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/2052390/manually-raising-throwing-an-exception-in-python", "answer_count": 11, "answers": {"id": 24065533, "body": "\n\nHow do I manually throw/raise an exception in Python?\n\n\n\n\nUse the most specific Exception constructor that semantically fits your issue\n.\n\n\nBe specific in your message, e.g.:\n\n\nraise ValueError('A very specific bad thing happened.')\n\n\n\nDon't raise generic exceptions\n\n\nAvoid raising a generic \nException\n. To catch it, you'll have to catch all other more specific exceptions that subclass it.\n\n\nProblem 1: Hiding bugs\n\n\nraise Exception('I know Python!') # Don't! If you catch, likely to hide bugs.\n\n\n\nFor example:\n\n\ndef demo_bad_catch():\n    try:\n        raise ValueError('Represents a hidden bug, do not catch this')\n        raise Exception('This is the exception you expect to handle')\n    except Exception as error:\n        print('Caught this error: ' + repr(error))\n\n>>> demo_bad_catch()\nCaught this error: ValueError('Represents a hidden bug, do not catch this',)\n\n\n\nProblem 2: Won't catch\n\n\nAnd more specific catches won't catch the general exception:\n\n\ndef demo_no_catch():\n    try:\n        raise Exception('general exceptions not caught by specific handling')\n    except ValueError as e:\n        print('we will not catch exception: Exception')\n \n\n>>> demo_no_catch()\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\n  File \"\n\", line 3, in demo_no_catch\nException: general exceptions not caught by specific handling\n\n\n\nBest Practices: \nraise\n statement\n\n\nInstead, use the most specific Exception constructor that semantically fits your issue\n.\n\n\nraise ValueError('A very specific bad thing happened')\n\n\n\nwhich also handily allows an arbitrary number of arguments to be passed to the constructor:\n\n\nraise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz') \n\n\n\nThese arguments are accessed by the \nargs\n attribute on the \nException\n object. For example:\n\n\ntry:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print(err.args)\n\n\n\nprints\n\n\n('message', 'foo', 'bar', 'baz')    \n\n\n\nIn Python 2.5, an actual \nmessage\n attribute was added to \nBaseException\n in favor of encouraging users to subclass Exceptions and stop using \nargs\n, but \nthe introduction of \nmessage\n and the original deprecation of args has been retracted\n.\n\n\nBest Practices: \nexcept\n clause\n\n\nWhen inside an except clause, you might want to, for example, log that a specific type of error happened, and then re-raise. The best way to do this while preserving the stack trace is to use a bare raise statement. For example:\n\n\nlogger = logging.getLogger(__name__)\n\ntry:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\n    raise                 # just this!\n    # raise AppError      # Don't do this, you'll lose the stack trace!\n\n\n\nDon't modify your errors... but if you insist.\n\n\nYou can preserve the stacktrace (and error value) with \nsys.exc_info()\n, but \nthis is way more error prone\n and \nhas compatibility problems between Python 2 and 3\n, prefer to use a bare \nraise\n to re-raise.\n\n\nTo explain - the \nsys.exc_info()\n returns the type, value, and traceback.\n\n\ntype, value, traceback = sys.exc_info()\n\n\n\nThis is the syntax in Python 2 - note this is not compatible with Python 3:\n\n\nraise AppError, error, sys.exc_info()[2] # avoid this.\n# Equivalently, as error *is* the second object:\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]\n\n\n\nIf you want to, you can modify what happens with your new raise - e.g. setting new \nargs\n for the instance:\n\n\ndef error():\n    raise ValueError('oops!')\n\ndef catch_error_modify_message():\n    try:\n        error()\n    except ValueError:\n        error_type, error_instance, traceback = sys.exc_info()\n        error_instance.args = (error_instance.args[0] + ' \n',)\n        raise error_type, error_instance, traceback\n\n\n\nAnd we have preserved the whole traceback while modifying the args. Note that this is \nnot a best practice\n and it is \ninvalid syntax\n in Python 3 (making keeping compatibility much harder to work around).\n\n\n>>> catch_error_modify_message()\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\n  File \"\n\", line 3, in catch_error_modify_message\n  File \"\n\", line 2, in error\nValueError: oops! \n\n\n\n\nIn \nPython 3\n:\n\n\nraise error.with_traceback(sys.exc_info()[2])\n\n\n\nAgain: avoid manually manipulating tracebacks. It's \nless efficient\n and more error prone. And if you're using threading and \nsys.exc_info\n you may even get the wrong traceback (especially if you're using exception handling for control flow - which I'd personally tend to avoid.)\n\n\nPython 3, Exception chaining\n\n\nIn Python 3, you can chain Exceptions, which preserve tracebacks:\n\n\nraise RuntimeError('specific message') from error\n\n\n\nBe aware:\n\n\n\n\nthis \ndoes\n allow changing the error type raised, and\n\n\nthis is \nnot\n compatible with Python 2.\n\n\n\n\nDeprecated Methods:\n\n\nThese can easily hide and even get into production code. You want to raise an exception, and doing them will raise an exception, \nbut not the one intended!\n\n\nValid in Python 2, but not in Python 3\n is the following:\n\n\nraise ValueError, 'message' # Don't do this, it's deprecated!\n\n\n\nOnly \nvalid in much older versions of Python\n (2.4 and lower), you may still see people raising strings:\n\n\nraise 'message' # really really wrong. don't do this.\n\n\n\nIn all modern versions, this will actually raise a \nTypeError\n, because you're not raising a \nBaseException\n type. If you're not checking for the right exception and don't have a reviewer that's aware of the issue, it could get into production.\n\n\nExample Usage\n\n\nI raise Exceptions to warn consumers of my API if they're using it incorrectly:\n\n\ndef api_func(foo):\n    '''foo should be either 'baz' or 'bar'. returns something very useful.'''\n    if foo not in _ALLOWED_ARGS:\n        raise ValueError('{foo} wrong, use \"baz\" or \"bar\"'.format(foo=repr(foo)))\n\n\n\nCreate your own error types when apropos\n\n\n\n\n\"I want to make an error on purpose, so that it would go into the except\"\n\n\n\n\nYou can create your own error types, if you want to indicate something specific is wrong with your application, just subclass the appropriate point in the exception hierarchy:\n\n\nclass MyAppLookupError(LookupError):\n    '''raise this when there's a lookup error for my app'''\n\n\n\nand usage:\n\n\nif important_key not in resource_dict and not ok_to_be_missing:\n    raise MyAppLookupError('resource is missing, and that is not ok.')\n\n\n", "score": 4305}}
{"question": "How do I pass a variable by reference?", "tags": ["python", "reference", "parameter-passing", "pass-by-reference"], "link": "https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference", "answer_count": 43, "answers": {"id": 25670170, "body": "I found the other answers rather long and complicated, so I created this simple diagram to explain the way Python treats variables and parameters.\n\n\n", "score": 468}}
{"question": "How do I pass a variable by reference?", "tags": ["python", "reference", "parameter-passing", "pass-by-reference"], "link": "https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference", "answer_count": 43, "answers": {"id": 8140747, "body": "The problem comes from a misunderstanding of what variables are in Python. If you're used to most traditional languages, you have a mental model of what happens in the following sequence:\n\n\na = 1\na = 2\n\n\n\nYou believe that \na\n is a memory location that stores the value \n1\n, then is updated to store the value \n2\n. That's not how things work in Python. Rather, \na\n starts as a reference to an object with the value \n1\n, then gets reassigned as a reference to an object with the value \n2\n. Those two objects may continue to coexist even though \na\n doesn't refer to the first one anymore; in fact they may be shared by any number of other references within the program.\n\n\nWhen you call a function with a parameter, a new reference is created that refers to the object passed in. This is separate from the reference that was used in the function call, so there's no way to update that reference and make it refer to a new object. In your example:\n\n\ndef __init__(self):\n    self.variable = 'Original'\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var = 'Changed'\n\n\n\nself.variable\n is a reference to the string object \n'Original'\n. When you call \nChange\n you create a second reference \nvar\n to the object. Inside the function you reassign the reference \nvar\n to a different string object \n'Changed'\n, but the reference \nself.variable\n is separate and does not change.\n\n\nThe only way around this is to pass a mutable object. Because both references refer to the same object, any changes to the object are reflected in both places.\n\n\ndef __init__(self):         \n    self.variable = ['Original']\n    self.Change(self.variable)\n\ndef Change(self, var):\n    var[0] = 'Changed'\n\n\n", "score": 908}}
{"question": "How do I pass a variable by reference?", "tags": ["python", "reference", "parameter-passing", "pass-by-reference"], "link": "https://stackoverflow.com/questions/986006/how-do-i-pass-a-variable-by-reference", "answer_count": 43, "answers": {"id": 986145, "body": "Arguments are \npassed by assignment\n. The rationale behind this is twofold:\n\n\n\n\nthe parameter passed in is actually a \nreference\n to an object (but the reference is passed by value)\n\n\nsome data types are mutable, but others aren't\n\n\n\n\nSo:\n\n\n\n\nIf you pass a \nmutable\n object into a method, the method gets a reference to that same object and you can mutate it to your heart's delight, but if you rebind the reference in the method, the outer scope will know nothing about it, and after you're done, the outer reference will still point at the original object. \n\n\nIf you pass an \nimmutable\n object to a method, you still can't rebind the outer reference, and you can't even mutate the object.\n\n\n\n\nTo make it even more clear, let's have some examples. \n\n\nList - a mutable type\n\n\nLet's try to modify the list that was passed to a method:\n\n\ndef try_to_change_list_contents(the_list):\n    print('got', the_list)\n    the_list.append('four')\n    print('changed to', the_list)\n\nouter_list = ['one', 'two', 'three']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_contents(outer_list)\nprint('after, outer_list =', outer_list)\n\n\n\nOutput:\n\n\nbefore, outer_list = ['one', 'two', 'three']\ngot ['one', 'two', 'three']\nchanged to ['one', 'two', 'three', 'four']\nafter, outer_list = ['one', 'two', 'three', 'four']\n\n\n\nSince the parameter passed in is a reference to \nouter_list\n, not a copy of it, we can use the mutating list methods to change it and have the changes reflected in the outer scope.\n\n\nNow let's see what happens when we try to change the reference that was passed in as a parameter:\n\n\ndef try_to_change_list_reference(the_list):\n    print('got', the_list)\n    the_list = ['and', 'we', 'can', 'not', 'lie']\n    print('set to', the_list)\n\nouter_list = ['we', 'like', 'proper', 'English']\n\nprint('before, outer_list =', outer_list)\ntry_to_change_list_reference(outer_list)\nprint('after, outer_list =', outer_list)\n\n\n\nOutput:\n\n\nbefore, outer_list = ['we', 'like', 'proper', 'English']\ngot ['we', 'like', 'proper', 'English']\nset to ['and', 'we', 'can', 'not', 'lie']\nafter, outer_list = ['we', 'like', 'proper', 'English']\n\n\n\nSince the \nthe_list\n parameter was passed by value, assigning a new list to it had no effect that the code outside the method could see. The \nthe_list\n was a copy of the \nouter_list\n reference, and we had \nthe_list\n point to a new list, but there was no way to change where \nouter_list\n pointed.\n\n\nString - an immutable type\n\n\nIt's immutable, so there's nothing we can do to change the contents of the string\n\n\nNow, let's try to change the reference\n\n\ndef try_to_change_string_reference(the_string):\n    print('got', the_string)\n    the_string = 'In a kingdom by the sea'\n    print('set to', the_string)\n\nouter_string = 'It was many and many a year ago'\n\nprint('before, outer_string =', outer_string)\ntry_to_change_string_reference(outer_string)\nprint('after, outer_string =', outer_string)\n\n\n\nOutput:\n\n\nbefore, outer_string = It was many and many a year ago\ngot It was many and many a year ago\nset to In a kingdom by the sea\nafter, outer_string = It was many and many a year ago\n\n\n\nAgain, since the \nthe_string\n parameter was passed by value, assigning a new string to it had no effect that the code outside the method could see. The \nthe_string\n was a copy of the \nouter_string\n reference, and we had \nthe_string\n point to a new string, but there was no way to change where \nouter_string\n pointed.\n\n\nI hope this clears things up a little.\n\n\nEDIT:\n It's been noted that this doesn't answer the question that @David originally asked, \"Is there something I can do to pass the variable by actual reference?\". Let's work on that.\n\n\nHow do we get around this?\n\n\nAs @Andrea's answer shows, you could return the new value. This doesn't change the way things are passed in, but does let you get the information you want back out:\n\n\ndef return_a_whole_new_string(the_string):\n    new_string = something_to_do_with_the_old_string(the_string)\n    return new_string\n\n# then you could call it like\nmy_string = return_a_whole_new_string(my_string)\n\n\n\nIf you really wanted to avoid using a return value, you could create a class to hold your value and pass it into the function or use an existing class, like a list:\n\n\ndef use_a_wrapper_to_simulate_pass_by_reference(stuff_to_change):\n    new_string = something_to_do_with_the_old_string(stuff_to_change[0])\n    stuff_to_change[0] = new_string\n\n# then you could call it like\nwrapper = [my_string]\nuse_a_wrapper_to_simulate_pass_by_reference(wrapper)\n\ndo_something_with(wrapper[0])\n\n\n\nAlthough this seems a little cumbersome.\n\n", "score": 3583}}
{"question": "How do I clone a list so that it doesn&#39;t change unexpectedly after assignment?", "tags": ["python", "list", "clone", "mutable"], "link": "https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment", "answer_count": 25, "answers": {"id": 17810305, "body": "I've \nbeen told\n that Python 3.3+ \nadds the \nlist.copy()\n method, which should be as fast as slicing:\n\n\nnewlist = old_list.copy()\n\n\n", "score": 186}}
{"question": "How do I clone a list so that it doesn&#39;t change unexpectedly after assignment?", "tags": ["python", "list", "clone", "mutable"], "link": "https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment", "answer_count": 25, "answers": {"id": 2612990, "body": "Felix already provided an excellent answer, but I thought I'd do a speed comparison of the various methods:\n\n\n\n\n10.59 sec (105.9 \u00b5s/itn) -  \ncopy.deepcopy(old_list)\n\n\n10.16 sec (101.6 \u00b5s/itn) - pure Python \nCopy()\n method copying classes with deepcopy\n\n\n1.488 sec (14.88 \u00b5s/itn) - pure Python \nCopy()\n method not copying classes (only dicts/lists/tuples)\n\n\n0.325 sec (3.25 \u00b5s/itn) - \nfor item in old_list: new_list.append(item)\n\n\n0.217 sec (2.17 \u00b5s/itn) - \n[i for i in old_list]\n (a \nlist comprehension\n)\n\n\n0.186 sec (1.86 \u00b5s/itn) - \ncopy.copy(old_list)\n\n\n0.075 sec (0.75 \u00b5s/itn) - \nlist(old_list)\n\n\n0.053 sec (0.53 \u00b5s/itn) - \nnew_list = []; new_list.extend(old_list)\n\n\n0.039 sec (0.39 \u00b5s/itn) - \nold_list[:]\n (\nlist slicing\n)\n\n\n\n\nSo the fastest is list slicing. But be aware that \ncopy.copy()\n, \nlist[:]\n and \nlist(list)\n, unlike \ncopy.deepcopy()\n and the python version don't copy any lists, dictionaries and class instances in the list, so if the originals change, they will change in the copied list too and vice versa.\n\n\n(Here's the script if anyone's interested or wants to raise any issues:)\n\n\nfrom copy import deepcopy\n\nclass old_class:\n    def __init__(self):\n        self.blah = 'blah'\n\nclass new_class(object):\n    def __init__(self):\n        self.blah = 'blah'\n\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\n\n    if t in (list, tuple):\n        if t == tuple:\n            # Convert to a list if a tuple to\n            # allow assigning to when copying\n            is_tuple = True\n            obj = list(obj)\n        else:\n            # Otherwise just do a quick slice copy\n            obj = obj[:]\n            is_tuple = False\n\n        # Copy each item recursively\n        for x in xrange(len(obj)):\n            if type(obj[x]) in dignore:\n                continue\n            obj[x] = Copy(obj[x], use_deepcopy)\n\n        if is_tuple:\n            # Convert back into a tuple again\n            obj = tuple(obj)\n\n    elif t == dict:\n        # Use the fast shallow dict copy() method and copy any\n        # values which aren't immutable (like lists, dicts etc)\n        obj = obj.copy()\n        for k in obj:\n            if type(obj[k]) in dignore:\n                continue\n            obj[k] = Copy(obj[k], use_deepcopy)\n\n    elif t in dignore:\n        # Numeric or string/unicode?\n        # It's immutable, so ignore it!\n        pass\n\n    elif use_deepcopy:\n        obj = deepcopy(obj)\n    return obj\n\nif __name__ == '__main__':\n    import copy\n    from time import time\n\n    num_times = 100000\n    L = [None, 'blah', 1, 543.4532,\n         ['foo'], ('bar',), {'blah': 'blah'},\n         old_class(), new_class()]\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L)\n    print 'Custom Copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        Copy(L, use_deepcopy=False)\n    print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.copy(L)\n    print 'copy.copy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        copy.deepcopy(L)\n    print 'copy.deepcopy:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        L[:]\n    print 'list slicing [:]:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        list(L)\n    print 'list(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        [i for i in L]\n    print 'list expression(L):', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(L)\n    print 'list extend:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        for y in L:\n            a.append(y)\n    print 'list append:', time()-t\n\n    t = time()\n    for i in xrange(num_times):\n        a = []\n        a.extend(i for i in L)\n    print 'generator expression extend:', time()-t\n\n\n", "score": 767}}
{"question": "How do I clone a list so that it doesn&#39;t change unexpectedly after assignment?", "tags": ["python", "list", "clone", "mutable"], "link": "https://stackoverflow.com/questions/2612802/how-do-i-clone-a-list-so-that-it-doesnt-change-unexpectedly-after-assignment", "answer_count": 25, "answers": {"id": 2612815, "body": "new_list = my_list\n doesn't actually create a second list. The assignment just copies the reference to the list, not the actual list, so both \nnew_list\n and \nmy_list\n refer to the same list after the assignment.\n\n\nTo actually copy the list, you have several options:\n\n\n\n\nYou can use the built-in \nlist.copy()\n method (available since Python 3.3):\n\n\nnew_list = old_list.copy()\n\n\n\n\n\nYou can slice it:\n\n\nnew_list = old_list[:]\n\n\n\nAlex Martelli\n's opinion (at least \nback in 2007\n) about this is, that \nit is a weird syntax and it does not make sense to use it ever\n. ;) (In his opinion, the next one is more readable).\n\n\n\n\nYou can use the built-in \nlist()\n constructor:\n\n\nnew_list = list(old_list)\n\n\n\n\n\nYou can use generic \ncopy.copy()\n:\n\n\nimport copy\nnew_list = copy.copy(old_list)\n\n\n\nThis is a little slower than \nlist()\n because it has to find out the datatype of \nold_list\n first.\n\n\n\n\nIf you need to copy the elements of the list as well, use generic \ncopy.deepcopy()\n:\n\n\nimport copy\nnew_list = copy.deepcopy(old_list)\n\n\n\nObviously the slowest and most memory-needing method, but sometimes unavoidable. This operates recursively; it will handle any number of levels of nested lists (or other containers).\n\n\n\n\n\n\nExample:\n\n\nimport copy\n\nclass Foo(object):\n    def __init__(self, val):\n         self.val = val\n\n    def __repr__(self):\n        return f'Foo({self.val!r})'\n\nfoo = Foo(1)\n\na = ['foo', foo]\nb = a.copy()\nc = a[:]\nd = list(a)\ne = copy.copy(a)\nf = copy.deepcopy(a)\n\n# edit orignal list and instance \na.append('baz')\nfoo.val = 5\n\nprint(f'original: {a}\\nlist.copy(): {b}\\nslice: {c}\\nlist(): {d}\\ncopy: {e}\\ndeepcopy: {f}')\n\n\n\nResult:\n\n\noriginal: ['foo', Foo(5), 'baz']\nlist.copy(): ['foo', Foo(5)]\nslice: ['foo', Foo(5)]\nlist(): ['foo', Foo(5)]\ncopy: ['foo', Foo(5)]\ndeepcopy: ['foo', Foo(1)]\n\n\n", "score": 4141}}
{"question": "How do I sort a dictionary by value?", "tags": ["python", "sorting", "dictionary"], "link": "https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value", "answer_count": 34, "answers": {"id": 2258273, "body": "You could use:\n\n\nsorted(d.items(), key=lambda x: x[1])\n\n\n\nThis will sort the dictionary by the values of each entry within the dictionary from smallest to largest.\n\n\nTo sort it in descending order just add \nreverse=True\n:\n\n\nsorted(d.items(), key=lambda x: x[1], reverse=True)\n\n\n\nInput:\n\n\nd = {'one':1,'three':3,'five':5,'two':2,'four':4}\na = sorted(d.items(), key=lambda x: x[1])    \nprint(a)\n\n\n\nOutput:\n\n\n[('one', 1), ('two', 2), ('three', 3), ('four', 4), ('five', 5)]\n\n\n", "score": 1164}}
{"question": "How do I sort a dictionary by value?", "tags": ["python", "sorting", "dictionary"], "link": "https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value", "answer_count": 34, "answers": {"id": 3177911, "body": "As simple as: \nsorted(dict1, key=dict1.get)\n\n\nWell, it is actually possible to do a \"sort by dictionary values\". Recently I had to do that in a Code Golf (Stack Overflow question \nCode golf: Word frequency chart\n). Abridged, the problem was of the kind: given a text, count how often each word is encountered and display a list of the top words, sorted by decreasing frequency. \n\n\nIf you construct a dictionary with the words as keys and the number of occurrences of each word as value, simplified here as:\n\n\nfrom collections import defaultdict\nd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1\n\n\n\nthen you can get a list of the words, ordered by frequency of use with \nsorted(d, key=d.get)\n - the sort iterates over the dictionary keys, using the number of word occurrences as a sort key . \n\n\nfor w in sorted(d, key=d.get, reverse=True):\n    print(w, d[w])\n\n\n\nI am writing this detailed explanation to illustrate what people often mean by \"I can easily sort a dictionary by key, but how do I sort by value\" - and I think the original post was trying to address such an issue. And the solution is to do sort of list of the keys, based on the values, as shown above.\n\n", "score": 1639}}
{"question": "How do I sort a dictionary by value?", "tags": ["python", "sorting", "dictionary"], "link": "https://stackoverflow.com/questions/613183/how-do-i-sort-a-dictionary-by-value", "answer_count": 34, "answers": {"id": 613218, "body": "Python 3.7+ or CPython 3.6\n\n\nDicts preserve insertion order in Python 3.7+. Same in CPython 3.6, but \nit's an implementation detail\n.\n\n\n>>> x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\n>>> {k: v for k, v in sorted(x.items(), key=lambda item: item[1])}\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n\n\n\nor\n\n\n>>> dict(sorted(x.items(), key=lambda item: item[1]))\n{0: 0, 2: 1, 1: 2, 4: 3, 3: 4}\n\n\n\nOlder Python\n\n\nIt is not possible to sort a dictionary, only to get a representation of a dictionary that is sorted. Dictionaries are inherently orderless, but other types, such as lists and tuples, are not. So you need an ordered data type to represent sorted values, which will be a list\u2014probably a list of tuples.\n\n\nFor instance,\n\n\nimport operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))\n\n\n\nsorted_x\n will be a list of tuples sorted by the second element in each tuple. \ndict(sorted_x) == x\n.\n\n\nAnd for those wishing to sort on keys instead of values:\n\n\nimport operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))\n\n\n\nIn Python3 since \nunpacking is not allowed\n we can use\n\n\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0}\nsorted_x = sorted(x.items(), key=lambda kv: kv[1])\n\n\n\nIf you want the output as a dict, you can use \ncollections.OrderedDict\n:\n\n\nimport collections\n\nsorted_dict = collections.OrderedDict(sorted_x)\n\n\n", "score": 7056}}
{"question": "How can I access environment variables in Python?", "tags": ["python", "environment-variables"], "link": "https://stackoverflow.com/questions/4906977/how-can-i-access-environment-variables-in-python", "answer_count": 17, "answers": {"id": 49211023, "body": "Actually it can be done this way:\n\n\nimport os\n\nfor key, value in os.environ.items():\n    print(f'{key}: {value}')\n\n\n\nOr simply:\n\n\nfor key, value in os.environ.items():\n    print('{}: {}'.format(key, value))\n\n\n\nor:\n\n\nfor i, j in os.environ.items():\n    print(i, j)\n\n\n\nFor viewing the value in the parameter:\n\n\nprint(os.environ['HOME'])\n\n\n\nOr:\n\n\nprint(os.environ.get('HOME'))\n\n\n\nTo set the value:\n\n\nos.environ['HOME'] = '/new/value'\n\n\n", "score": 110}}
{"question": "How can I access environment variables in Python?", "tags": ["python", "environment-variables"], "link": "https://stackoverflow.com/questions/4906977/how-can-i-access-environment-variables-in-python", "answer_count": 17, "answers": {"id": 11447648, "body": "To check if the key exists (returns \nTrue\n or \nFalse\n)\n\n\n'HOME' in os.environ\n\n\n\nYou can also use \nget()\n when printing the key; useful if you want to use a default.\n\n\nprint(os.environ.get('HOME', '/home/username/'))\n\n\n\nwhere \n/home/username/\n is the default\n\n", "score": 380}}
{"question": "How can I access environment variables in Python?", "tags": ["python", "environment-variables"], "link": "https://stackoverflow.com/questions/4906977/how-can-i-access-environment-variables-in-python", "answer_count": 17, "answers": {"id": 4907053, "body": "Environment variables are accessed through \nos.environ\n:\n\n\nimport os\nprint(os.environ['HOME'])\n\n\n\nTo see a list of all environment variables:\n\n\nprint(os.environ)\n\n\n\n\n\nIf a key is not present, attempting to access it will raise a \nKeyError\n. To avoid this:\n\n\n# Returns `None` if the key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST'))\n\n# Returns `default_value` if the key doesn't exist\nprint(os.environ.get('KEY_THAT_MIGHT_EXIST', default_value))\n\n# Returns `default_value` if the key doesn't exist\nprint(os.getenv('KEY_THAT_MIGHT_EXIST', default_value))\n\n\n", "score": 4798}}
{"question": "How do I list all files of a directory?", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory", "answer_count": 21, "answers": {"id": 41447012, "body": "list in the current directory\n\n\nWith \nlistdir\n in \nos\n module you get the files and the folders in the current dir\n\n\nimport os\n\narr = os.listdir()\n\n\n\nLooking in a directory\n\n\narr = os.listdir('c:\\\\files')\n\n\n\nwith \nglob\n you can specify a type of file to list like this\n\n\nimport glob\n\ntxtfiles = []\nfor file in glob.glob(\"*.txt\"):\n    txtfiles.append(file)\n\n\n\nor\n\n\nmylist = [f for f in glob.glob(\"*.txt\")]\n\n\n\nget the full path of only files in the current directory\n\n\nimport os\nfrom os import listdir\nfrom os.path import isfile, join\n\ncwd = os.getcwd()\nonlyfiles = [os.path.join(cwd, f) for f in os.listdir(cwd) if \nos.path.isfile(os.path.join(cwd, f))]\nprint(onlyfiles) \n\n['G:\\\\getfilesname\\\\getfilesname.py', 'G:\\\\getfilesname\\\\example.txt']\n\n\n\nGetting the full path name with \nos.path.abspath\n\n\nYou get the full path in return\n\n\n import os\n files_path = [os.path.abspath(x) for x in os.listdir()]\n print(files_path)\n \n ['F:\\\\documenti\\applications.txt', 'F:\\\\documenti\\collections.txt']\n\n\n\nWalk: going through sub directories\n\n\nos.walk returns the root, the directories list and the files list, that is why I unpacked them in r, d, f in the for loop; it, then, looks for other files and directories in the subfolders of the root and so on until there are no subfolders.\n\n\nimport os\n\n# Getting the current work directory (cwd)\nthisdir = os.getcwd()\n\n# r=root, d=directories, f = files\nfor r, d, f in os.walk(thisdir):\n    for file in f:\n        if file.endswith(\".docx\"):\n            print(os.path.join(r, file))\n\n\n\nTo go up in the directory tree\n\n\n# Method 1\nx = os.listdir('..')\n\n# Method 2\nx= os.listdir('/')\n\n\n\nGet files of a particular subdirectory with \nos.listdir()\n\n\nimport os\n\nx = os.listdir(\"./content\")\n\n\n\nos.walk('.') - current directory\n\n\n import os\n arr = next(os.walk('.'))[2]\n print(arr)\n \n >>> ['5bs_Turismo1.pdf', '5bs_Turismo1.pptx', 'esperienza.txt']\n\n\n\nnext(os.walk('.')) and os.path.join('dir', 'file')\n\n\n import os\n arr = []\n for d,r,f in next(os.walk(\"F:\\\\_python\")):\n     for file in f:\n         arr.append(os.path.join(r,file))\n\n for f in arr:\n     print(files)\n\n>>> F:\\\\_python\\\\dict_class.py\n>>> F:\\\\_python\\\\programmi.txt\n\n\n\nnext... walk\n\n\n [os.path.join(r,file) for r,d,f in next(os.walk(\"F:\\\\_python\")) for file in f]\n \n >>> ['F:\\\\_python\\\\dict_class.py', 'F:\\\\_python\\\\programmi.txt']\n\n\n\nos.walk\n\n\nx = [os.path.join(r,file) for r,d,f in os.walk(\"F:\\\\_python\") for file in f]\nprint(x)\n\n>>> ['F:\\\\_python\\\\dict.py', 'F:\\\\_python\\\\progr.txt', 'F:\\\\_python\\\\readl.py']\n\n\n\nos.listdir() - get only txt files\n\n\n arr_txt = [x for x in os.listdir() if x.endswith(\".txt\")]\n \n\n\n\nUsing \nglob\n to get the full path of the files\n\n\nfrom path import path\nfrom glob import glob\n\nx = [path(f).abspath() for f in glob(\"F:\\\\*.txt\")]\n\n\n\nUsing \nos.path.isfile\n to avoid directories in the list\n\n\nimport os.path\nlistOfFiles = [f for f in os.listdir() if os.path.isfile(f)]\n\n\n\nUsing \npathlib\n from Python 3.4\n\n\nimport pathlib\n\nflist = []\nfor p in pathlib.Path('.').iterdir():\n    if p.is_file():\n        print(p)\n        flist.append(p)\n\n\n\nWith \nlist comprehension\n:\n\n\nflist = [p for p in pathlib.Path('.').iterdir() if p.is_file()]\n\n\n\nUse glob method in pathlib.Path()\n\n\nimport pathlib\n\npy = pathlib.Path().glob(\"*.py\")\n\n\n\nGet all and only files with os.walk: checks only in the third element returned, i.e. the list of the files\n\n\nimport os\nx = [i[2] for i in os.walk('.')]\ny=[]\nfor t in x:\n    for f in t:\n        y.append(f)\n\n\n\nGet only files with next in a directory: returns only the file in the root folder\n\n\n import os\n x = next(os.walk('F://python'))[2]\n\n\n\nGet only directories with next and walk in a directory, because in the [1] element there are the folders only\n\n\n import os\n next(os.walk('F://python'))[1] # for the current dir use ('.')\n \n >>> ['python3','others']\n\n\n\nGet all the \nsubdir\n names with \nwalk\n\n\nfor r,d,f in os.walk(\"F:\\\\_python\"):\n    for dirs in d:\n        print(dirs)\n\n\n\nos.scandir()\n from Python 3.5 and greater\n\n\nimport os\nx = [f.name for f in os.scandir() if f.is_file()]\n\n# Another example with `scandir` (a little variation from docs.python.org)\n# This one is more efficient than `os.listdir`.\n# In this case, it shows the files only in the current directory\n# where the script is executed.\n\nimport os\nwith os.scandir() as i:\n    for entry in i:\n        if entry.is_file():\n            print(entry.name)\n\n\n", "score": 1593}}
{"question": "How do I list all files of a directory?", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory", "answer_count": 21, "answers": {"id": 3215392, "body": "I prefer using the \nglob\n module, as it does pattern matching and expansion.\n\n\nimport glob\nprint(glob.glob(\"/home/adam/*\"))\n\n\n\nIt does pattern matching intuitively\n\n\nimport glob\n# All files and directories ending with .txt and that don't begin with a dot:\nprint(glob.glob(\"/home/adam/*.txt\")) \n# All files and directories ending with .txt with depth of 2 folders, ignoring names beginning with a dot:\nprint(glob.glob(\"/home/adam/*/*.txt\")) \n\n\n\nIt will return a list with the queried files and directories:\n\n\n['/home/adam/file1.txt', '/home/adam/file2.txt', .... ]\n\n\n\nNote that \nglob\n ignores files and directories that begin with a dot \n.\n, as those are considered hidden files and directories, unless the pattern is something like \n.*\n.\n\n\nUse \nglob.escape\n to escape strings that are not meant to be patterns:\n\n\nprint(glob.glob(glob.escape(directory_name) + \"/*.txt\"))\n\n\n", "score": 2634}}
{"question": "How do I list all files of a directory?", "tags": ["python", "directory"], "link": "https://stackoverflow.com/questions/3207219/how-do-i-list-all-files-of-a-directory", "answer_count": 21, "answers": {"id": 3207973, "body": "os.listdir()\n returns everything inside a directory -- including both \nfiles\n and \ndirectories\n.\n\n\nos.path\n's \nisfile()\n can be used to only list files:\n\n\nfrom os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]\n\n\n\nAlternatively, \nos.walk()\n \nyields two lists\n for each directory it visits -- one for \nfiles\n and one for \ndirs\n. If you only want the top directory you can break the first time it yields:\n\n\nfrom os import walk\n\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\n    break\n\n\n\nor, shorter:\n\n\nfrom os import walk\n\nfilenames = next(walk(mypath), (None, None, []))[2]  # [] if no file\n\n\n", "score": 6552}}
{"question": "What does ** (double star/asterisk) and * (star/asterisk) do for parameters?", "tags": ["python", "syntax", "parameter-passing", "variadic-functions", "argument-unpacking"], "link": "https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters", "answer_count": 28, "answers": {"id": 36911, "body": "The single * means that there can be any number of extra positional arguments. \nfoo()\n can be invoked like \nfoo(1,2,3,4,5)\n. In the body of foo() param2 is a sequence containing 2-5.\n\n\nThe double ** means there can be any number of extra named parameters. \nbar()\n can be invoked like \nbar(1, a=2, b=3)\n. In the body of bar() param2 is a dictionary containing {'a':2, 'b':3 }\n\n\nWith the following code:\n\n\ndef foo(param1, *param2):\n    print(param1)\n    print(param2)\n\ndef bar(param1, **param2):\n    print(param1)\n    print(param2)\n\nfoo(1,2,3,4,5)\nbar(1,a=2,b=3)\n\n\n\nthe output is\n\n\n1\n(2, 3, 4, 5)\n1\n{'a': 2, 'b': 3}\n\n\n", "score": 225}}
{"question": "What does ** (double star/asterisk) and * (star/asterisk) do for parameters?", "tags": ["python", "syntax", "parameter-passing", "variadic-functions", "argument-unpacking"], "link": "https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters", "answer_count": 28, "answers": {"id": 36926, "body": "It's also worth noting that you can use \n*\n and \n**\n when calling functions as well. This is a shortcut that allows you to pass multiple arguments to a function directly using either a list/tuple or a dictionary. For example, if you have the following function:\n\n\ndef foo(x,y,z):\n    print(\"x=\" + str(x))\n    print(\"y=\" + str(y))\n    print(\"z=\" + str(z))\n\n\n\nYou can do things like:\n\n\n>>> mylist = [1,2,3]\n>>> foo(*mylist)\nx=1\ny=2\nz=3\n\n>>> mydict = {'x':1,'y':2,'z':3}\n>>> foo(**mydict)\nx=1\ny=2\nz=3\n\n>>> mytuple = (1, 2, 3)\n>>> foo(*mytuple)\nx=1\ny=2\nz=3\n\n\n\nNote: The keys in \nmydict\n have to be named exactly like the parameters of function \nfoo\n. Otherwise it will throw a \nTypeError\n:\n\n\n>>> mydict = {'x':1,'y':2,'z':3,'badnews':9}\n>>> foo(**mydict)\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nTypeError: foo() got an unexpected keyword argument 'badnews'\n\n\n", "score": 846}}
{"question": "What does ** (double star/asterisk) and * (star/asterisk) do for parameters?", "tags": ["python", "syntax", "parameter-passing", "variadic-functions", "argument-unpacking"], "link": "https://stackoverflow.com/questions/36901/what-does-double-star-asterisk-and-star-asterisk-do-for-parameters", "answer_count": 28, "answers": {"id": 36908, "body": "The \n*args\n and \n**kwargs\n are common idioms to allow an arbitrary number of arguments to functions, as described in the section \nmore on defining functions\n in the Python tutorial.\n\n\nThe \n*args\n will give you all positional arguments \nas a tuple\n:\n\n\ndef foo(*args):\n    for a in args:\n        print(a)        \n\nfoo(1)\n# 1\n\nfoo(1, 2, 3)\n# 1\n# 2\n# 3\n\n\n\nThe \n**kwargs\n will give you all\nkeyword arguments as a dictionary:\n\n\ndef bar(**kwargs):\n    for a in kwargs:\n        print(a, kwargs[a])  \n\nbar(name='one', age=27)\n# name one\n# age 27\n\n\n\nBoth idioms can be mixed with normal arguments to allow a set of fixed and some variable arguments:\n\n\ndef foo(kind, *args, bar=None, **kwargs):\n    print(kind, args, bar, kwargs)\n\nfoo(123, 'a', 'b', apple='red')\n# 123 ('a', 'b') None {'apple': 'red'}\n\n\n\nIt is also possible to use this the other way around:\n\n\ndef foo(a, b, c):\n    print(a, b, c)\n\nobj = {'b':10, 'c':'lee'}\n\nfoo(100, **obj)\n# 100 10 lee\n\n\n\nAnother usage of the \n*l\n idiom is to \nunpack argument lists\n when calling a function.\n\n\ndef foo(bar, lee):\n    print(bar, lee)\n\nbaz = [1, 2]\n\nfoo(*baz)\n# 1 2\n\n\n\nIn Python 3 it is possible to use \n*l\n on the left side of an assignment (\nExtended Iterable Unpacking\n), though it gives a list instead of a tuple in this context:\n\n\nfirst, *rest = [1, 2, 3, 4]\n# first = 1\n# rest = [2, 3, 4]\n\n\n\nAlso Python 3 adds a new semantic (refer \nPEP 3102\n):\n\n\ndef func(arg1, arg2, arg3, *, kwarg1, kwarg2):\n    pass\n\n\n\nSuch function accepts only 3 positional arguments, and everything after \n*\n can only be passed as keyword arguments.\n\n\nNote:\n\n\nA Python \ndict\n, semantically used for keyword argument passing, is arbitrarily ordered. However, in Python 3.6+, keyword arguments are guaranteed to remember insertion order.\n\"The order of elements in \n**kwargs\n now corresponds to the order in which keyword arguments were passed to the function.\" - \nWhat\u2019s New In Python 3.6\n.\nIn fact, all dicts in CPython 3.6 will remember insertion order as an implementation detail, and this becomes standard in Python 3.7.\n\n", "score": 3319}}
{"question": "&quot;Least Astonishment&quot; and the Mutable Default Argument", "tags": ["python", "language-design", "default-parameters", "least-astonishment"], "link": "https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument", "answer_count": 34, "answers": {"id": 11416002, "body": "The relevant part of the \ndocumentation\n:\n\n\n\n\nDefault parameter values are evaluated from left to right when the function definition is executed.\n This means that the expression is evaluated once, when the function is defined, and that the same \u201cpre-computed\u201d value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use \nNone\n as the default, and explicitly test for it in the body of the function, e.g.:\n\n\ndef whats_on_the_telly(penguin=None):\n    if penguin is None:\n        penguin = []\n    penguin.append(\"property of the zoo\")\n    return penguin\n\n\n\n\n", "score": 325}}
{"question": "&quot;Least Astonishment&quot; and the Mutable Default Argument", "tags": ["python", "language-design", "default-parameters", "least-astonishment"], "link": "https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument", "answer_count": 34, "answers": {"id": 1133013, "body": "Suppose you have the following code\n\n\nfruits = (\"apples\", \"bananas\", \"loganberries\")\n\ndef eat(food=fruits):\n    ...\n\n\n\nWhen I see the declaration of eat, the least astonishing thing is to think that if the first parameter is not given, that it will be equal to the tuple \n(\"apples\", \"bananas\", \"loganberries\")\n\n\nHowever, suppose later on in the code, I do something like\n\n\ndef some_random_function():\n    global fruits\n    fruits = (\"blueberries\", \"mangos\")\n\n\n\nthen if default parameters were bound at function execution rather than function declaration, I would be astonished (in a very bad way) to discover that fruits had been changed. This would be more astonishing IMO than discovering that your \nfoo\n function above was mutating the list.\n\n\nThe real problem lies with mutable variables, and all languages have this problem to some extent. Here's a question: suppose in Java I have the following code:\n\n\nStringBuffer s = new StringBuffer(\"Hello World!\");\nMap\n counts = new HashMap\n();\ncounts.put(s, 5);\ns.append(\"!!!!\");\nSystem.out.println( counts.get(s) );  // does this work?\n\n\n\nNow, does my map use the value of the \nStringBuffer\n key when it was placed into the map, or does it store the key by reference? Either way, someone is astonished; either the person who tried to get the object out of the \nMap\n using a value identical to the one they put it in with, or the person who can't seem to retrieve their object even though the key they're using is literally the same object that was used to put it into the map (this is actually why Python doesn't allow its mutable built-in data types to be used as dictionary keys).\n\n\nYour example is a good one of a case where Python newcomers will be surprised and bitten. But I'd argue that if we \"fixed\" this, then that would only create a different situation where they'd be bitten instead, and that one would be even less intuitive. Moreover, this is always the case when dealing with mutable variables; you always run into cases where someone could intuitively expect one or the opposite behavior depending on what code they're writing.\n\n\nI personally like Python's current approach: default function arguments are evaluated when the function is defined and that object is always the default. I suppose they could special-case using an empty list, but that kind of special casing would cause even more astonishment, not to mention be backwards incompatible.\n\n", "score": 338}}
{"question": "&quot;Least Astonishment&quot; and the Mutable Default Argument", "tags": ["python", "language-design", "default-parameters", "least-astonishment"], "link": "https://stackoverflow.com/questions/1132941/least-astonishment-and-the-mutable-default-argument", "answer_count": 34, "answers": {"id": 1145781, "body": "Actually, this is not a design flaw, and it is not because of internals or performance. It comes simply from the fact that functions in Python are \nfirst-class objects\n, and not only a piece of code.\n\n\nAs soon as you think of it this way, then it completely makes sense: a function is an \nobject\n being evaluated on its definition; default parameters are kind of \n\"member data\"\n and therefore their state may change from one call to the other - exactly as in any other object.\n\n\nIn any case, the Effbot (\nFredrik Lundh\n) has a very nice explanation of the reasons for this behavior in \nDefault Parameter Values in Python\n. I found it very clear, and I really suggest reading it for a better knowledge of how function objects work.\n\n", "score": 1953}}
{"question": "How can I delete a file or folder in Python?", "tags": ["python", "file-io", "directory", "delete-file"], "link": "https://stackoverflow.com/questions/6996603/how-can-i-delete-a-file-or-folder-in-python", "answer_count": 18, "answers": {"id": 6996662, "body": "Use \n\n\nshutil.rmtree(path[, ignore_errors[, onerror]])\n\n\n\n(See complete documentation on \nshutil\n) and/or\n\n\nos.remove\n\n\n\nand\n\n\nos.rmdir\n\n\n\n(Complete documentation on \nos\n.)\n\n", "score": 129}}
{"question": "How can I delete a file or folder in Python?", "tags": ["python", "file-io", "directory", "delete-file"], "link": "https://stackoverflow.com/questions/6996603/how-can-i-delete-a-file-or-folder-in-python", "answer_count": 18, "answers": {"id": 42641792, "body": "Python syntax to delete a file\n\n\nimport os\nos.remove(\"/tmp/\n.txt\")\n\n\n\nor\n\n\nimport os\nos.unlink(\"/tmp/\n.txt\")\n\n\n\nor\n\n\npathlib\n Library for Python version >= 3.4\n\n\nfile_to_rem = pathlib.Path(\"/tmp/\n.txt\")\nfile_to_rem.unlink()\n\n\n\nPath.unlink(missing_ok=False)\n\n\nUnlink method used to remove the file or the symbolik link.\n\n\n\n\n\n\nIf missing_ok is false (the default), FileNotFoundError is raised if    the path does not exist.\n\n\nIf missing_ok is true, FileNotFoundError exceptions will be ignored    (same behavior as the POSIX rm -f command).\n\n\nChanged in version 3.8: The missing_ok parameter was added.\n\n\n\n\n\n\nBest practice\n\n\nFirst, check if the file or folder exists and then delete it. You can achieve this in two ways:\n\n\n\n\nos.path.isfile(\"/path/to/file\")\n\n\nUse \nexception handling.\n\n\n\n\nEXAMPLE\n for \nos.path.isfile\n\n\n#!/usr/bin/python\nimport os\n\nmyfile = \"/tmp/foo.txt\"\n# If file exists, delete it.\nif os.path.isfile(myfile):\n    os.remove(myfile)\nelse:\n    # If it fails, inform the user.\n    print(\"Error: %s file not found\" % myfile)\n\n\n\nException Handling\n\n\n#!/usr/bin/python\nimport os\n\n# Get input.\nmyfile = raw_input(\"Enter file name to delete: \")\n\n# Try to delete the file.\ntry:\n    os.remove(myfile)\nexcept OSError as e:\n    # If it fails, inform the user.\n    print(\"Error: %s - %s.\" % (e.filename, e.strerror))\n\n\n\nRespective output\n\n\n\nEnter file name to delete : demo.txt\nError: demo.txt - No such file or directory.\n\nEnter file name to delete : rrr.txt\nError: rrr.txt - Operation not permitted.\n\nEnter file name to delete : foo.txt\n\n\n\nPython syntax to delete a folder\n\n\nshutil.rmtree()\n\n\n\nExample for \nshutil.rmtree()\n\n\n#!/usr/bin/python\nimport os\nimport sys\nimport shutil\n\n# Get directory name\nmydir = raw_input(\"Enter directory name: \")\n\n# Try to remove the tree; if it fails, throw an error using try...except.\ntry:\n    shutil.rmtree(mydir)\nexcept OSError as e:\n    print(\"Error: %s - %s.\" % (e.filename, e.strerror))\n\n\n", "score": 780}}
{"question": "How can I delete a file or folder in Python?", "tags": ["python", "file-io", "directory", "delete-file"], "link": "https://stackoverflow.com/questions/6996603/how-can-i-delete-a-file-or-folder-in-python", "answer_count": 18, "answers": {"id": 6996628, "body": "Use one of these methods:\n\n\n\n\npathlib.Path.unlink()\n removes a file or symbolic link.\n\n\n\n\npathlib.Path.rmdir()\n removes an empty directory.\n\n\n\n\nshutil.rmtree()\n deletes a directory and all its contents.\n\n\n\n\n\n\n\n\nOn Python 3.3 and below, you can use these methods instead of the \npathlib\n ones:\n\n\n\n\nos.remove()\n removes a file.\n\n\n\n\nos.unlink()\n removes a symbolic link.\n\n\n\n\nos.rmdir()\n removes an empty directory.\n\n\n\n\n\n", "score": 5008}}
{"question": "Does Python have a string &#39;contains&#39; substring method?", "tags": ["python", "string", "substring", "contains"], "link": "https://stackoverflow.com/questions/3437059/does-python-have-a-string-contains-substring-method", "answer_count": 10, "answers": {"id": 27138045, "body": "\n\nDoes Python have a string contains substring method?\n\n\n\n\n99%\n of use cases will be covered using the keyword, \nin\n, which returns \nTrue\n or \nFalse\n:\n\n\n'substring' in any_string\n\n\n\nFor the use case of getting the index, use \nstr.find\n (which returns -1 on failure, and has optional positional arguments):\n\n\nstart = 0\nstop = len(any_string)\nany_string.find('substring', start, stop)\n\n\n\nor \nstr.index\n (like \nfind\n but raises ValueError on failure):\n\n\nstart = 100 \nend = 1000\nany_string.index('substring', start, end)\n\n\n\nExplanation\n\n\nUse the \nin\n comparison operator because\n\n\n\n\nthe language intends its usage, and\n\n\nother Python programmers will expect you to use it.\n\n\n\n\n>>> 'foo' in '**foo**'\nTrue\n\n\n\nThe opposite (complement), which the original question asked for, is \nnot in\n:\n\n\n>>> 'foo' not in '**foo**' # returns False\nFalse\n\n\n\nThis is semantically the same as \nnot 'foo' in '**foo**'\n but it's much more readable and explicitly provided for in the language as a readability improvement.\n\n\nAvoid using \n__contains__\n\n\nThe \"contains\" method implements the behavior for \nin\n. This example,\n\n\nstr.__contains__('**foo**', 'foo')\n\n\n\nreturns \nTrue\n. You could also call this function from the instance of the superstring:\n\n\n'**foo**'.__contains__('foo')\n\n\n\nBut don't. Methods that start with underscores are considered semantically non-public. The only reason to use this is when implementing or extending the \nin\n and \nnot in\n functionality (e.g. if subclassing \nstr\n):\n\n\nclass NoisyString(str):\n    def __contains__(self, other):\n        print(f'testing if \"{other}\" in \"{self}\"')\n        return super(NoisyString, self).__contains__(other)\n\nns = NoisyString('a string with a substring inside')\n\n\n\nand now:\n\n\n>>> 'substring' in ns\ntesting if \"substring\" in \"a string with a substring inside\"\nTrue\n\n\n\nDon't use \nfind\n and \nindex\n to test for \"contains\"\n\n\nDon't use the following string methods to test for \"contains\":\n\n\n>>> '**foo**'.index('foo')\n2\n>>> '**foo**'.find('foo')\n2\n\n>>> '**oo**'.find('foo')\n-1\n>>> '**oo**'.index('foo')\n\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\n    '**oo**'.index('foo')\nValueError: substring not found\n\n\n\nOther languages may have no methods to directly test for substrings, and so you would have to use these types of methods, but with Python, it is much more efficient to use the \nin\n comparison operator.\n\n\nAlso, these are not drop-in replacements for \nin\n. You may have to handle the exception or \n-1\n cases, and if they return \n0\n (because they found the substring at the beginning) the boolean interpretation is \nFalse\n instead of \nTrue\n.\n\n\nIf you really mean \nnot any_string.startswith(substring)\n then say it.\n\n\nPerformance comparisons\n\n\nWe can compare various ways of accomplishing the same goal.\n\n\nimport timeit\n\ndef in_(s, other):\n    return other in s\n\ndef contains(s, other):\n    return s.__contains__(other)\n\ndef find(s, other):\n    return s.find(other) != -1\n\ndef index(s, other):\n    try:\n        s.index(other)\n    except ValueError:\n        return False\n    else:\n        return True\n\n\n\nperf_dict = {\n'in:True': min(timeit.repeat(lambda: in_('superstring', 'str'))),\n'in:False': min(timeit.repeat(lambda: in_('superstring', 'not'))),\n'__contains__:True': min(timeit.repeat(lambda: contains('superstring', 'str'))),\n'__contains__:False': min(timeit.repeat(lambda: contains('superstring', 'not'))),\n'find:True': min(timeit.repeat(lambda: find('superstring', 'str'))),\n'find:False': min(timeit.repeat(lambda: find('superstring', 'not'))),\n'index:True': min(timeit.repeat(lambda: index('superstring', 'str'))),\n'index:False': min(timeit.repeat(lambda: index('superstring', 'not'))),\n}\n\n\n\nAnd now we see that using \nin\n is much faster than the others.\nLess time to do an equivalent operation is better:\n\n\n>>> perf_dict\n{'in:True': 0.16450627865128808,\n 'in:False': 0.1609668098178645,\n '__contains__:True': 0.24355481654697542,\n '__contains__:False': 0.24382793854783813,\n 'find:True': 0.3067379407923454,\n 'find:False': 0.29860888058124146,\n 'index:True': 0.29647137792585454,\n 'index:False': 0.5502287584545229}\n\n\n\nHow can \nin\n be faster than \n__contains__\n if \nin\n uses \n__contains__\n?\n\n\nThis is a fine follow-on question.\n\n\nLet's disassemble functions with the methods of interest:\n\n\n>>> from dis import dis\n>>> dis(lambda: 'a' in 'b')\n  1           0 LOAD_CONST               1 ('a')\n              2 LOAD_CONST               2 ('b')\n              4 COMPARE_OP               6 (in)\n              6 RETURN_VALUE\n>>> dis(lambda: 'b'.__contains__('a'))\n  1           0 LOAD_CONST               1 ('b')\n              2 LOAD_METHOD              0 (__contains__)\n              4 LOAD_CONST               2 ('a')\n              6 CALL_METHOD              1\n              8 RETURN_VALUE\n\n\n\nso we see that the \n.__contains__\n method has to be separately looked up and then called from the Python virtual machine - this should adequately explain the difference.\n\n", "score": 560}}
{"question": "Does Python have a string &#39;contains&#39; substring method?", "tags": ["python", "string", "substring", "contains"], "link": "https://stackoverflow.com/questions/3437059/does-python-have-a-string-contains-substring-method", "answer_count": 10, "answers": {"id": 3437068, "body": "You can use \nstr.find\n:\n\n\ns = \"This be a string\"\nif s.find(\"is\") == -1:\n    print(\"Not found\")\nelse:\n    print(\"Found\")\n\n\n\n\n\nThe \nfind()\n method should be used only if you need to know the position of sub. To check if sub is a substring or not, use the \nin\n operator. (c) Python reference\n\n\n\n", "score": 940}}
{"question": "Does Python have a string &#39;contains&#39; substring method?", "tags": ["python", "string", "substring", "contains"], "link": "https://stackoverflow.com/questions/3437059/does-python-have-a-string-contains-substring-method", "answer_count": 10, "answers": {"id": 3437070, "body": "Use the \nin\n operator\n:\n\n\nif \"blah\" not in somestring: \n    continue\n\n\n\nNote: This is case-sensitive.\n\n", "score": 8606}}
{"question": "How can I add new keys to a dictionary?", "tags": ["python", "dictionary", "key", "lookup"], "link": "https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary", "answer_count": 20, "answers": {"id": 1165836, "body": "To add multiple keys simultaneously, use \ndict.update()\n:\n\n\n>>> x = {1:2}\n>>> print(x)\n{1: 2}\n\n>>> d = {3:4, 5:6, 7:8}\n>>> x.update(d)\n>>> print(x)\n{1: 2, 3: 4, 5: 6, 7: 8}\n\n\n\nFor adding a single key, the accepted answer has less computational overhead.\n\n", "score": 1237}}
{"question": "How can I add new keys to a dictionary?", "tags": ["python", "dictionary", "key", "lookup"], "link": "https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary", "answer_count": 20, "answers": {"id": 8381589, "body": "I feel like consolidating info about Python dictionaries:\n\n\nCreating an empty dictionary\n\n\ndata = {}\n# OR\ndata = dict()\n\n\n\nCreating a dictionary with initial values\n\n\ndata = {'a': 1, 'b': 2, 'c': 3}\n# OR\ndata = dict(a=1, b=2, c=3)\n# OR\ndata = {k: v for k, v in (('a', 1), ('b',2), ('c',3))}\n\n\n\nInserting/Updating a single value\n\n\ndata['a'] = 1  # Updates if 'a' exists, else adds 'a'\n# OR\ndata.update({'a': 1})\n# OR\ndata.update(dict(a=1))\n# OR\ndata.update(a=1)\n\n\n\nInserting/Updating multiple values\n\n\ndata.update({'c':3,'d':4})  # Updates 'c' and adds 'd'\n\n\n\nPython\u00a03.9+:\n\n\nThe \nupdate operator\n \n|=\n now works for dictionaries:\n\n\ndata |= {'c':3,'d':4}\n\n\n\nCreating a merged dictionary without modifying originals\n\n\ndata3 = {}\ndata3.update(data)  # Modifies data3, not data\ndata3.update(data2)  # Modifies data3, not data2\n\n\n\nPython\u00a03.5+:\n\n\nThis uses a new feature called \ndictionary unpacking\n.\n\n\ndata = {**data1, **data2, **data3}\n\n\n\nPython\u00a03.9+:\n\n\nThe \nmerge operator\n \n|\n now works for dictionaries:\n\n\ndata = data1 | {'c':3,'d':4}\n\n\n\nDeleting items in dictionary\n\n\ndel data[key]  # Removes specific element in a dictionary\ndata.pop(key)  # Removes the key & returns the value\ndata.clear()  # Clears entire dictionary\n\n\n\nCheck if a key is already in dictionary\n\n\nkey in data\n\n\n\nIterate through pairs in a dictionary\n\n\nfor key in data: # Iterates just through the keys, ignoring the values\nfor key, value in d.items(): # Iterates through the pairs\nfor key in d.keys(): # Iterates just through key, ignoring the values\nfor value in d.values(): # Iterates just through value, ignoring the keys\n\n\n\nCreate a dictionary from two lists\n\n\ndata = dict(zip(list_with_keys, list_with_values))\n\n\n", "score": 1354}}
{"question": "How can I add new keys to a dictionary?", "tags": ["python", "dictionary", "key", "lookup"], "link": "https://stackoverflow.com/questions/1024847/how-can-i-add-new-keys-to-a-dictionary", "answer_count": 20, "answers": {"id": 1024851, "body": "You create a new key/value pair on a dictionary by assigning a value to that key\n\n\nd = {'key': 'value'}\nprint(d)  # {'key': 'value'}\n\nd['mynewkey'] = 'mynewvalue'\n\nprint(d)  # {'key': 'value', 'mynewkey': 'mynewvalue'}\n\n\n\nIf the key doesn't exist, it's added and points to that value. If it exists, the current value it points to is overwritten.\n\n", "score": 4447}}
{"question": "How do I select rows from a DataFrame based on column values?", "tags": ["python", "pandas", "dataframe", "indexing", "filter"], "link": "https://stackoverflow.com/questions/17071871/how-do-i-select-rows-from-a-dataframe-based-on-column-values", "answer_count": 20, "answers": {"id": 31296878, "body": "tl;dr\n\n\nThe Pandas equivalent to\n\n\nselect * from table where column_name = some_value\n\n\n\nis\n\n\ntable[table.column_name == some_value]\n\n\n\nMultiple conditions:\n\n\ntable[(table.column_name == some_value) | (table.column_name2 == some_value2)]\n\n\n\nor\n\n\ntable.query('column_name == some_value | column_name2 == some_value2')\n\n\n\nCode example\n\n\nimport pandas as pd\n\n# Create data set\nd = {'foo':[100, 111, 222],\n     'bar':[333, 444, 555]}\ndf = pd.DataFrame(d)\n\n# Full dataframe:\ndf\n\n# Shows:\n#    bar   foo\n# 0  333   100\n# 1  444   111\n# 2  555   222\n\n# Output only the row(s) in df where foo is 222:\ndf[df.foo == 222]\n\n# Shows:\n#    bar  foo\n# 2  555  222\n\n\n\nIn the above code it is the line \ndf[df.foo == 222]\n that gives the rows based on the column value, \n222\n in this case.\n\n\nMultiple conditions are also possible:\n\n\ndf[(df.foo == 222) | (df.bar == 444)]\n#    bar  foo\n# 1  444  111\n# 2  555  222\n\n\n\nBut at that point I would recommend using the \nquery\n function, since it's less verbose and yields the same result:\n\n\ndf.query('foo == 222 | bar == 444')\n\n\n", "score": 354}}
{"question": "How do I select rows from a DataFrame based on column values?", "tags": ["python", "pandas", "dataframe", "indexing", "filter"], "link": "https://stackoverflow.com/questions/17071871/how-do-i-select-rows-from-a-dataframe-based-on-column-values", "answer_count": 20, "answers": {"id": 46165056, "body": "There are several ways to select rows from a Pandas dataframe:\n\n\n\n\nBoolean indexing (\ndf[df['col'] == value\n] )\n\n\nPositional indexing (\ndf.iloc[...]\n)\n\n\nLabel indexing (\ndf.xs(...)\n)\n\n\ndf.query(...)\n API\n\n\n\n\nBelow I show you examples of each, with advice when to use certain techniques. Assume our criterion is column \n'A'\n == \n'foo'\n\n\n(Note on performance: For each base type, we can keep things simple by using the Pandas API or we can venture outside the API, usually into NumPy, and speed things up.)\n\n\n\n\nSetup\n\n\nThe first thing we'll need is to identify a condition that will act as our criterion for selecting rows. We'll start with the OP's case \ncolumn_name == some_value\n, and include some other common use cases.\n\n\nBorrowing from @unutbu:\n\n\nimport pandas as pd, numpy as np\n\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\n\n\n\n\n\n1. Boolean indexing\n\n\n... Boolean indexing requires finding the true value of each row's \n'A'\n column being equal to \n'foo'\n, then using those truth values to identify which rows to keep.  Typically, we'd name this series, an array of truth values, \nmask\n.  We'll do so here as well.\n\n\nmask = df['A'] == 'foo'\n\n\n\nWe can then use this mask to slice or index the data frame\n\n\ndf[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\nThis is one of the simplest ways to accomplish this task and if performance or intuitiveness isn't an issue, this should be your chosen method.  However, if performance is a concern, then you might want to consider an alternative way of creating the \nmask\n.\n\n\n\n\n2. Positional indexing\n\n\nPositional indexing (\ndf.iloc[...]\n) has its use cases, but this isn't one of them.  In order to identify where to slice, we first need to perform the same boolean analysis we did above.  This leaves us performing one extra step to accomplish the same task.\n\n\nmask = df['A'] == 'foo'\npos = np.flatnonzero(mask)\ndf.iloc[pos]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n3. Label indexing\n\n\nLabel\n indexing can be very handy, but in this case, we are again doing more work for no benefit\n\n\ndf.set_index('A', append=True, drop=False).xs('foo', level=1)\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n4. \ndf.query()\n API\n\n\npd.DataFrame.query\n is a very elegant/intuitive way to perform this task, but is often slower. \nHowever\n, if you pay attention to the timings below, for large data, the query is very efficient. More so than the standard approach and of similar magnitude as my best suggestion.\n\n\ndf.query('A == \"foo\"')\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n\n\nMy preference is to use the \nBoolean\n \nmask\n\n\nActual improvements can be made by modifying how we create our \nBoolean\n \nmask\n.\n\n\nmask\n alternative 1\n\n\nUse the underlying NumPy array and forgo the overhead of creating another \npd.Series\n\n\nmask = df['A'].values == 'foo'\n\n\n\nI'll show more complete time tests at the end, but just take a look at the performance gains we get using the sample data frame.  First, we look at the difference in creating the \nmask\n\n\n%timeit mask = df['A'].values == 'foo'\n%timeit mask = df['A'] == 'foo'\n\n5.84 \u00b5s \u00b1 195 ns per loop (mean \u00b1 std. dev. of 7 runs, 100000 loops each)\n166 \u00b5s \u00b1 4.45 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\n\n\nEvaluating the \nmask\n with the NumPy array is ~ 30 times faster.  This is partly due to NumPy evaluation often being faster. It is also partly due to the lack of overhead necessary to build an index and a corresponding \npd.Series\n object.\n\n\nNext, we'll look at the timing for slicing with one \nmask\n versus the other.\n\n\nmask = df['A'].values == 'foo'\n%timeit df[mask]\nmask = df['A'] == 'foo'\n%timeit df[mask]\n\n219 \u00b5s \u00b1 12.3 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n239 \u00b5s \u00b1 7.03 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n\n\n\nThe performance gains aren't as pronounced.  We'll see if this holds up over more robust testing.\n\n\n\n\nmask\n alternative 2\n\nWe could have reconstructed the data frame as well.  There is a big caveat when reconstructing a dataframe\u2014you must take care of the \ndtypes\n when doing so!\n\n\nInstead of \ndf[mask]\n we will do this\n\n\npd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)\n\n\n\nIf the data frame is of mixed type, which our example is, then when we get \ndf.values\n the resulting array is of \ndtype\n \nobject\n and consequently, all columns of the new data frame will be of \ndtype\n \nobject\n.  Thus requiring the \nastype(df.dtypes)\n and killing any potential performance gains.\n\n\n%timeit df[m]\n%timeit pd.DataFrame(df.values[mask], df.index[mask], df.columns).astype(df.dtypes)\n\n216 \u00b5s \u00b1 10.4 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n1.43 ms \u00b1 39.6 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 1000 loops each)\n\n\n\nHowever, if the data frame is not of mixed type, this is a very useful way to do it.\n\n\nGiven\n\n\nnp.random.seed([3,1415])\nd1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))\n\nd1\n\n   A  B  C  D  E\n0  0  2  7  3  8\n1  7  0  6  8  6\n2  0  2  0  4  9\n3  7  3  2  4  3\n4  3  6  7  7  4\n5  5  3  7  5  9\n6  8  7  6  4  7\n7  6  2  6  6  5\n8  2  8  7  5  8\n9  4  7  6  1  5\n\n\n\n\n\n%%timeit\nmask = d1['A'].values == 7\nd1[mask]\n\n179 \u00b5s \u00b1 8.73 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\n\n\nVersus\n\n\n%%timeit\nmask = d1['A'].values == 7\npd.DataFrame(d1.values[mask], d1.index[mask], d1.columns)\n\n87 \u00b5s \u00b1 5.12 \u00b5s per loop (mean \u00b1 std. dev. of 7 runs, 10000 loops each)\n\n\n\nWe cut the time in half.\n\n\n\n\nmask\n alternative 3\n\n\n@unutbu also shows us how to use \npd.Series.isin\n to account for each element of \ndf['A']\n being in a set of values.  This evaluates to the same thing if our set of values is a set of one value, namely \n'foo'\n.  But it also generalizes to include larger sets of values if needed.  Turns out, this is still pretty fast even though it is a more general solution.  The only real loss is in intuitiveness for those not familiar with the concept.\n\n\nmask = df['A'].isin(['foo'])\ndf[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\nHowever, as before, we can utilize NumPy to improve performance while sacrificing virtually nothing. We'll use \nnp.in1d\n\n\nmask = np.in1d(df['A'].values, ['foo'])\ndf[mask]\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n\n\nTiming\n\n\nI'll include other concepts mentioned in other posts as well for reference.\n\n\nCode Below\n\n\nEach \ncolumn\n in this table represents a different length data frame over which we test each function. Each column shows relative time taken, with the fastest function given a base index of \n1.0\n.\n\n\nres.div(res.min())\n\n                         10        30        100       300       1000      3000      10000     30000\nmask_standard         2.156872  1.850663  2.034149  2.166312  2.164541  3.090372  2.981326  3.131151\nmask_standard_loc     1.879035  1.782366  1.988823  2.338112  2.361391  3.036131  2.998112  2.990103\nmask_with_values      1.010166  1.000000  1.005113  1.026363  1.028698  1.293741  1.007824  1.016919\nmask_with_values_loc  1.196843  1.300228  1.000000  1.000000  1.038989  1.219233  1.037020  1.000000\nquery                 4.997304  4.765554  5.934096  4.500559  2.997924  2.397013  1.680447  1.398190\nxs_label              4.124597  4.272363  5.596152  4.295331  4.676591  5.710680  6.032809  8.950255\nmask_with_isin        1.674055  1.679935  1.847972  1.724183  1.345111  1.405231  1.253554  1.264760\nmask_with_in1d        1.000000  1.083807  1.220493  1.101929  1.000000  1.000000  1.000000  1.144175\n\n\n\nYou'll notice that the fastest times seem to be shared between \nmask_with_values\n and \nmask_with_in1d\n.\n\n\nres.T.plot(loglog=True)\n\n\n\n\n\nFunctions\n\n\ndef mask_standard(df):\n    mask = df['A'] == 'foo'\n    return df[mask]\n\ndef mask_standard_loc(df):\n    mask = df['A'] == 'foo'\n    return df.loc[mask]\n\ndef mask_with_values(df):\n    mask = df['A'].values == 'foo'\n    return df[mask]\n\ndef mask_with_values_loc(df):\n    mask = df['A'].values == 'foo'\n    return df.loc[mask]\n\ndef query(df):\n    return df.query('A == \"foo\"')\n\ndef xs_label(df):\n    return df.set_index('A', append=True, drop=False).xs('foo', level=-1)\n\ndef mask_with_isin(df):\n    mask = df['A'].isin(['foo'])\n    return df[mask]\n\ndef mask_with_in1d(df):\n    mask = np.in1d(df['A'].values, ['foo'])\n    return df[mask]\n\n\n\n\n\nTesting\n\n\nres = pd.DataFrame(\n    index=[\n        'mask_standard', 'mask_standard_loc', 'mask_with_values', 'mask_with_values_loc',\n        'query', 'xs_label', 'mask_with_isin', 'mask_with_in1d'\n    ],\n    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    dtype=float\n)\n\nfor j in res.columns:\n    d = pd.concat([df] * j, ignore_index=True)\n    for i in res.index:a\n        stmt = '{}(d)'.format(i)\n        setp = 'from __main__ import d, {}'.format(i)\n        res.at[i, j] = timeit(stmt, setp, number=50)\n\n\n\n\n\nSpecial Timing\n\n\nLooking at the special case when we have a single non-object \ndtype\n for the entire data frame.\n\n\nCode Below\n\n\nspec.div(spec.min())\n\n                     10        30        100       300       1000      3000      10000     30000\nmask_with_values  1.009030  1.000000  1.194276  1.000000  1.236892  1.095343  1.000000  1.000000\nmask_with_in1d    1.104638  1.094524  1.156930  1.072094  1.000000  1.000000  1.040043  1.027100\nreconstruct       1.000000  1.142838  1.000000  1.355440  1.650270  2.222181  2.294913  3.406735\n\n\n\nTurns out, reconstruction isn't worth it past a few hundred rows.\n\n\nspec.T.plot(loglog=True)\n\n\n\n\n\nFunctions\n\n\nnp.random.seed([3,1415])\nd1 = pd.DataFrame(np.random.randint(10, size=(10, 5)), columns=list('ABCDE'))\n\ndef mask_with_values(df):\n    mask = df['A'].values == 'foo'\n    return df[mask]\n\ndef mask_with_in1d(df):\n    mask = np.in1d(df['A'].values, ['foo'])\n    return df[mask]\n\ndef reconstruct(df):\n    v = df.values\n    mask = np.in1d(df['A'].values, ['foo'])\n    return pd.DataFrame(v[mask], df.index[mask], df.columns)\n\nspec = pd.DataFrame(\n    index=['mask_with_values', 'mask_with_in1d', 'reconstruct'],\n    columns=[10, 30, 100, 300, 1000, 3000, 10000, 30000],\n    dtype=float\n)\n\n\n\nTesting\n\n\nfor j in spec.columns:\n    d = pd.concat([df] * j, ignore_index=True)\n    for i in spec.index:\n        stmt = '{}(d)'.format(i)\n        setp = 'from __main__ import d, {}'.format(i)\n        spec.at[i, j] = timeit(stmt, setp, number=50)\n\n\n", "score": 845}}
{"question": "How do I select rows from a DataFrame based on column values?", "tags": ["python", "pandas", "dataframe", "indexing", "filter"], "link": "https://stackoverflow.com/questions/17071871/how-do-i-select-rows-from-a-dataframe-based-on-column-values", "answer_count": 20, "answers": {"id": 17071908, "body": "To select rows whose column value equals a scalar, \nsome_value\n, use \n==\n:\n\n\ndf.loc[df['column_name'] == some_value]\n\n\n\nTo select rows whose column value is in an iterable, \nsome_values\n, use \nisin\n:\n\n\ndf.loc[df['column_name'].isin(some_values)]\n\n\n\nCombine multiple conditions with \n&\n:\n\n\ndf.loc[(df['column_name'] >= A) & (df['column_name'] <= B)]\n\n\n\nNote the parentheses. Due to Python's \noperator precedence rules\n, \n&\n binds more tightly than \n<=\n and \n>=\n. Thus, the parentheses in the last example are necessary. Without the parentheses\n\n\ndf['column_name'] >= A & df['column_name'] <= B\n\n\n\nis parsed as\n\n\ndf['column_name'] >= (A & df['column_name']) <= B\n\n\n\nwhich results in a \nTruth value of a Series is ambiguous error\n.\n\n\n\n\nTo select rows whose column value \ndoes not equal\n \nsome_value\n, use \n!=\n:\n\n\ndf.loc[df['column_name'] != some_value]\n\n\n\nThe \nisin\n returns a boolean Series, so to select rows whose value is \nnot\n in \nsome_values\n, negate the boolean Series using \n~\n:\n\n\ndf = df.loc[~df['column_name'].isin(some_values)] # .loc is not in-place replacement\n\n\n\n\n\nFor example,\n\n\nimport pandas as pd\nimport numpy as np\ndf = pd.DataFrame({'A': 'foo bar foo bar foo bar foo foo'.split(),\n                   'B': 'one one two three two two one three'.split(),\n                   'C': np.arange(8), 'D': np.arange(8) * 2})\nprint(df)\n#      A      B  C   D\n# 0  foo    one  0   0\n# 1  bar    one  1   2\n# 2  foo    two  2   4\n# 3  bar  three  3   6\n# 4  foo    two  4   8\n# 5  bar    two  5  10\n# 6  foo    one  6  12\n# 7  foo  three  7  14\n\nprint(df.loc[df['A'] == 'foo'])\n\n\n\nyields\n\n\n     A      B  C   D\n0  foo    one  0   0\n2  foo    two  2   4\n4  foo    two  4   8\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n\n\nIf you have multiple values you want to include, put them in a\nlist (or more generally, any iterable) and use \nisin\n:\n\n\nprint(df.loc[df['B'].isin(['one','three'])])\n\n\n\nyields\n\n\n     A      B  C   D\n0  foo    one  0   0\n1  bar    one  1   2\n3  bar  three  3   6\n6  foo    one  6  12\n7  foo  three  7  14\n\n\n\n\n\nNote, however, that if you wish to do this many times, it is more efficient to\nmake an index first, and then use \ndf.loc\n:\n\n\ndf = df.set_index(['B'])\nprint(df.loc['one'])\n\n\n\nyields\n\n\n       A  C   D\nB              \none  foo  0   0\none  bar  1   2\none  foo  6  12\n\n\n\nor, to include multiple values from the index use \ndf.index.isin\n:\n\n\ndf.loc[df.index.isin(['one','two'])]\n\n\n\nyields\n\n\n       A  C   D\nB              \none  foo  0   0\none  bar  1   2\ntwo  foo  2   4\ntwo  foo  4   8\ntwo  bar  5  10\none  foo  6  12\n\n\n", "score": 6606}}
{"question": "What is the difference between __str__ and __repr__?", "tags": ["python", "magic-methods", "repr"], "link": "https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr", "answer_count": 29, "answers": {"id": 1436756, "body": "Unless you specifically act to ensure otherwise, most classes don't have helpful results for either:\n\n\n>>> class Sic(object): pass\n... \n>>> print(str(Sic()))\n<__main__.Sic object at 0x8b7d0>\n>>> print(repr(Sic()))\n<__main__.Sic object at 0x8b7d0>\n\n\n\nAs you see -- no difference, and no info beyond the class and object's \nid\n.  If you only override one of the two:\n\n\n>>> class Sic(object): \n...   def __repr__(self): return 'foo'\n... \n>>> print(str(Sic()))\nfoo\n>>> print(repr(Sic()))\nfoo\n>>> class Sic(object):\n...   def __str__(self): return 'foo'\n... \n>>> print(str(Sic()))\nfoo\n>>> print(repr(Sic()))\n<__main__.Sic object at 0x2617f0>\n\n\n\nAs you see, if you override \n__repr__\n, that's ALSO used for \n__str__\n, but not vice versa.\n\n\nOther crucial tidbits to know: \n__str__\n on a built-on container uses the \n__repr__\n, NOT the \n__str__\n, for the items it contains. And, despite the words on the subject found in typical docs, hardly anybody bothers making the \n__repr__\n of objects be a string that \neval\n may use to build an equal object (it's just too hard, AND not knowing how the relevant module was actually imported makes it actually flat out impossible).\n\n\nSo, my advice: focus on making \n__str__\n reasonably human-readable, and \n__repr__\n as unambiguous as you possibly can, even if that interferes with the fuzzy unattainable goal of making \n__repr__\n's returned value acceptable as input to \neval\n!\n\n", "score": 556}}
{"question": "What is the difference between __str__ and __repr__?", "tags": ["python", "magic-methods", "repr"], "link": "https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr", "answer_count": 29, "answers": {"id": 1438297, "body": "My rule of thumb:  \n__repr__\n is for developers, \n__str__\n is for customers.\n\n", "score": 840}}
{"question": "What is the difference between __str__ and __repr__?", "tags": ["python", "magic-methods", "repr"], "link": "https://stackoverflow.com/questions/1436703/what-is-the-difference-between-str-and-repr", "answer_count": 29, "answers": {"id": 2626364, "body": "\n\nAlex Martelli summarized well\n but, surprisingly, was too succinct.\n\n\nFirst, let me reiterate the main points in \nAlex\n\u2019s post:\n\n\n\n\nThe default implementation is useless (it\u2019s hard to think of one which wouldn\u2019t be, but yeah)\n\n\n__repr__\n goal is to be unambiguous\n\n\n__str__\n goal is to be readable\n\n\nContainer\u2019s \n__str__\n uses contained objects\u2019 \n__repr__\n\n\n\n\nDefault implementation is useless\n\n\nThis is mostly a surprise because Python\u2019s defaults tend to be fairly useful. However, in this case, having a default for \n__repr__\n which would act like:\n\n\nreturn \"%s(%r)\" % (self.__class__, self.__dict__)\n\n\n\nOr in new f-string formatting:\n\n\nreturn f\"{self.__class__!s}({self.__dict__!r})\"\n\n\n\nwould have been too dangerous (for example, too easy to get into infinite recursion if objects reference each other). So Python cops out. Note that there is one default which is true: if \n__repr__\n is defined, and \n__str__\n is not, the object will behave as though \n__str__=__repr__\n.\n\n\nThis means, in simple terms: almost every object you implement should have a functional \n__repr__\n that\u2019s usable for understanding the object. Implementing \n__str__\n is optional: do that if you need a \u201cpretty print\u201d functionality (for example, used by a report generator).\n\n\nThe goal of \n__repr__\n is to be unambiguous\n\n\nLet me come right out and say it \u2014 I do not believe in debuggers. I don\u2019t really know how to use any debugger, and have never used one seriously. Furthermore, I believe that the big fault in debuggers is their basic nature \u2014 most failures I debug happened a long long time ago, in a galaxy far far away. This means that I do believe, with religious fervor, in logging. Logging is the lifeblood of any decent fire-and-forget server system. Python makes it easy to log: with maybe some project specific wrappers, all you need is a\n\n\nlog(INFO, \"I am in the weird function and a is\", a, \"and b is\", b, \"but I got a null C \u2014 using default\", default_c)\n\n\n\nBut you have to do the last step \u2014 make sure every object you implement has a useful repr, so code like that can just work. This is why the \u201ceval\u201d thing comes up: if you have enough information so \neval(repr(c))==c\n, that means you know everything there is to know about \nc\n. If that\u2019s easy enough, at least in a fuzzy way, do it. If not, make sure you have enough information about \nc\n anyway. I usually use an eval-like format: \n\"MyClass(this=%r,that=%r)\" % (self.this,self.that)\n. It does not mean that you can actually construct MyClass, or that those are the right constructor arguments \u2014 but it is a useful form to express \u201cthis is everything you need to know about this instance\u201d.\n\n\nNote: I used \n%r\n above, not \n%s\n. You always want to use \nrepr()\n [or \n%r\n formatting character, equivalently] inside \n__repr__\n implementation, or you\u2019re defeating the goal of repr. You want to be able to differentiate \nMyClass(3)\n and \nMyClass(\"3\")\n.\n\n\nThe goal of \n__str__\n is to be readable\n\n\nSpecifically, it is not intended to be unambiguous \u2014 notice that \nstr(3)==str(\"3\")\n. Likewise, if you implement an IP abstraction, having the str of it look like 192.168.1.1 is just fine. When implementing a date/time abstraction, the str can be \"2010/4/12 15:35:22\", etc. The goal is to represent it in a way that a user, not a programmer, would want to read it. Chop off useless digits, pretend to be some other class \u2014 as long is it supports readability, it is an improvement.\n\n\nContainer\u2019s \n__str__\n uses contained objects\u2019 \n__repr__\n\n\nThis seems surprising, doesn\u2019t it? It is a little, but how readable would it be if it used their \n__str__\n?\n\n\n[moshe is, 3, hello\nworld, this is a list, oh I don't know, containing just 4 elements]\n\n\n\nNot very. Specifically, the strings in a container would find it way too easy to disturb its string representation. In the face of ambiguity, remember, Python resists the temptation to guess. If you want the above behavior when you\u2019re printing a list, just\n\n\nprint(\"[\" + \", \".join(lst) + \"]\")\n\n\n\n(you can probably also figure out what to do about dictionaries).\n\n\nSummary\n\n\nImplement \n__repr__\n for any class you implement. This should be second nature. Implement \n__str__\n if you think it would be useful to have a string version which errs on the side of readability.\n\n", "score": 3590}}
{"question": "Convert bytes to a string in Python 3", "tags": ["python", "string", "python-3.x"], "link": "https://stackoverflow.com/questions/606191/convert-bytes-to-a-string-in-python-3", "answer_count": 23, "answers": {"id": 12073686, "body": "This joins together a list of bytes into a string:\n\n\n>>> bytes_data = [112, 52, 52]\n>>> \"\".join(map(chr, bytes_data))\n'p44'\n\n\n", "score": 264}}
{"question": "Convert bytes to a string in Python 3", "tags": ["python", "string", "python-3.x"], "link": "https://stackoverflow.com/questions/606191/convert-bytes-to-a-string-in-python-3", "answer_count": 23, "answers": {"id": 606205, "body": "Decode the byte string and turn it in to a character (Unicode) string.\n\n\n\n\nPython 3:\n\n\nencoding = 'utf-8'\nb'hello'.decode(encoding)\n\n\n\nor\n\n\nstr(b'hello', encoding)\n\n\n\n\n\nPython 2:\n\n\nencoding = 'utf-8'\n'hello'.decode(encoding)\n\n\n\nor\n\n\nunicode('hello', encoding)\n\n\n", "score": 428}}
{"question": "Convert bytes to a string in Python 3", "tags": ["python", "string", "python-3.x"], "link": "https://stackoverflow.com/questions/606191/convert-bytes-to-a-string-in-python-3", "answer_count": 23, "answers": {"id": 606199, "body": "Decode the \nbytes\n object\n to produce a string:\n\n\n>>> b\"abcde\".decode(\"utf-8\")\n'abcde'\n\n\n\nThe above example \nassumes\n that the \nbytes\n object is in UTF-8, because it is a common encoding. However, you should use the encoding your data is actually in!\n\n", "score": 5844}}
{"question": "What is __init__.py for?", "tags": ["python", "module", "package", "python-packaging"], "link": "https://stackoverflow.com/questions/448271/what-is-init-py-for", "answer_count": 14, "answers": {"id": 18979314, "body": "In addition to labeling a directory as a Python package and defining \n__all__\n, \n__init__.py\n allows you to define any variable at the package level.\n Doing so is often convenient if a package defines something that will be imported frequently, in an API-like fashion. This pattern promotes adherence to the Pythonic \"flat is better than nested\" philosophy.\n\n\nAn example\n\n\nHere is an example from one of my projects, in which I frequently import a \nsessionmaker\n called \nSession\n to interact with my database. I wrote a \"database\" package with a few modules:\n\n\ndatabase/\n    __init__.py\n    schema.py\n    insertions.py\n    queries.py\n\n\n\nMy \n__init__.py\n contains the following code:\n\n\nimport os\n\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import create_engine\n\nengine = create_engine(os.environ['DATABASE_URL'])\nSession = sessionmaker(bind=engine)\n\n\n\nSince I define \nSession\n here, I can start a new session using the syntax below. This code would be the same executed from inside or outside of the \"database\" package directory.\n\n\nfrom database import Session\nsession = Session()\n\n\n\nOf course, this is a small convenience -- the alternative would be to define \nSession\n in a new file like \"create_session.py\" in my database package, and start new sessions using:\n\n\nfrom database.create_session import Session\nsession = Session()\n\n\n\nFurther reading\n\n\nThere is a pretty interesting reddit thread covering appropriate uses of \n__init__.py\n here:\n\n\nhttp://www.reddit.com/r/Python/comments/1bbbwk/whats_your_opinion_on_what_to_include_in_init_py/\n\n\nThe majority opinion seems to be that \n__init__.py\n files should be very thin to avoid violating the \"explicit is better than implicit\" philosophy.\n\n", "score": 687}}
{"question": "What is __init__.py for?", "tags": ["python", "module", "package", "python-packaging"], "link": "https://stackoverflow.com/questions/448271/what-is-init-py-for", "answer_count": 14, "answers": {"id": 4116384, "body": "Files named \n__init__.py\n are used to mark directories on disk as Python package directories.\nIf you have the files\n\n\nmydir/spam/__init__.py\nmydir/spam/module.py\n\n\n\nand \nmydir\n is on your path, you can import the code in \nmodule.py\n as\n\n\nimport spam.module\n\n\n\nor\n\n\nfrom spam import module\n\n\n\nIf you remove the \n__init__.py\n file, Python will no longer look for submodules inside that directory, so attempts to import the module will fail.\n\n\nThe \n__init__.py\n file is usually empty, but can be used to export selected portions of the package under more convenient name, hold convenience functions, etc.\nGiven the example above, the contents of the init module can be accessed as\n\n\nimport spam\n\n\n\nThis answer is based on \nthis webpage\n.\n\n", "score": 1333}}
{"question": "What is __init__.py for?", "tags": ["python", "module", "package", "python-packaging"], "link": "https://stackoverflow.com/questions/448271/what-is-init-py-for", "answer_count": 14, "answers": {"id": 448279, "body": "It used to be a required part of a package (\nold, pre-3.3 \"regular package\"\n, not \nnewer 3.3+ \"namespace package\"\n).\n\n\nHere's the documentation.\n\n\n\n\nPython defines two types of packages, regular packages and namespace packages. Regular packages are traditional packages as they existed in Python 3.2 and earlier. A regular package is typically implemented as a directory containing an \n__init__.py\n file. When a regular package is imported, this \n__init__.py\n file is implicitly executed, and the objects it defines are bound to names in the package\u2019s namespace. The \n__init__.py\n file can contain the same Python code that any other module can contain, and Python will add some additional attributes to the module when it is imported.\n\n\n\n\nBut just click the link, it contains an example, more information, and an explanation of namespace packages, the kind of packages without \n__init__.py\n.\n\n", "score": 2086}}
{"question": "How do I copy a file?", "tags": ["python", "file", "copy", "filesystems", "file-copying"], "link": "https://stackoverflow.com/questions/123198/how-do-i-copy-a-file", "answer_count": 21, "answers": {"id": 123238, "body": "copy2(src,dst)\n is often more useful than \ncopyfile(src,dst)\n because:\n\n\n\n\nit allows \ndst\n to be a \ndirectory\n (instead of the complete target filename), in which case the \nbasename\n of \nsrc\n is used for creating the new file;\n\n\nit preserves the original modification and access info (mtime and atime) in the file metadata (however, this comes with a slight overhead).\n\n\n\n\nHere is a short example:\n\n\nimport shutil\nshutil.copy2('/src/dir/file.ext', '/dst/dir/newname.ext') # complete target filename given\nshutil.copy2('/src/file.ext', '/dst/dir') # target filename is /dst/dir/file.ext\n\n\n", "score": 1000}}
{"question": "How do I copy a file?", "tags": ["python", "file", "copy", "filesystems", "file-copying"], "link": "https://stackoverflow.com/questions/123198/how-do-i-copy-a-file", "answer_count": 21, "answers": {"id": 30359308, "body": "\n\n\n\n\n\n\n\nFunction\n\n\nCopies\nmetadata\n\n\nCopies\npermissions\n\n\nUses file object\n\n\nDestination\nmay be directory\n\n\n\n\n\n\n\n\n\n\nshutil.copy\n\n\nNo\n\n\nYes\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nshutil.copyfile\n\n\nNo\n\n\nNo\n\n\nNo\n\n\nNo\n\n\n\n\n\n\nshutil.copy2\n\n\nYes\n\n\nYes\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nshutil.copyfileobj\n\n\nNo\n\n\nNo\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n", "score": 2196}}
{"question": "How do I copy a file?", "tags": ["python", "file", "copy", "filesystems", "file-copying"], "link": "https://stackoverflow.com/questions/123198/how-do-i-copy-a-file", "answer_count": 21, "answers": {"id": 123212, "body": "shutil\n has many methods you can use. One of which is:\n\n\nimport shutil\n\nshutil.copyfile(src, dst)\n\n# 2nd option\nshutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp\n\n\n\n\n\nCopy the contents of the file named \nsrc\n to a file named \ndst\n. Both \nsrc\n and \ndst\n need to be the entire filename of the files, including path.\n\n\nThe destination location must be writable; otherwise, an \nIOError\n exception will be raised.\n\n\nIf \ndst\n already exists, it will be replaced.\n\n\nSpecial files such as character or block devices and pipes cannot be copied with this function.\n\n\nWith \ncopy\n, \nsrc\n and \ndst\n are path names given as \nstr\ns.\n\n\n\n\nAnother \nshutil\n method to look at is \nshutil.copy2()\n. It's similar but preserves more metadata (e.g. time stamps).\n\n\nIf you use \nos.path\n operations, use \ncopy\n rather than \ncopyfile\n. \ncopyfile\n will only accept strings.\n\n", "score": 4833}}
{"question": "How can I catch multiple exceptions in one line? (in the &quot;except&quot; block)", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/6470428/how-can-i-catch-multiple-exceptions-in-one-line-in-the-except-block", "answer_count": 6, "answers": {"id": 26650022, "body": "From \nPython documentation -> 8.3 Handling Exceptions\n:\n\n\n\n\nA \ntry\n statement may have more than one except clause, to specify\n  handlers for different exceptions. At most one handler will be\n  executed. Handlers only handle exceptions that occur in the\n  corresponding try clause, not in other handlers of the same try\n  statement. An except clause may name multiple exceptions as a\n  parenthesized tuple, for example:\n\n\nexcept (RuntimeError, TypeError, NameError):\n    pass\n\n\n\nNote that the parentheses around this tuple are required, because\n  except \nValueError, e:\n was the syntax used for what is normally\n  written as \nexcept ValueError as e:\n in modern Python (described\n  below). The old syntax is still supported for backwards compatibility.\n  This means \nexcept RuntimeError, TypeError\n is not equivalent to\n  \nexcept (RuntimeError, TypeError):\n but to \nexcept RuntimeError as\n\n\nTypeError:\n which is not what you want.\n\n\n\n", "score": 76}}
{"question": "How can I catch multiple exceptions in one line? (in the &quot;except&quot; block)", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/6470428/how-can-i-catch-multiple-exceptions-in-one-line-in-the-except-block", "answer_count": 6, "answers": {"id": 24338247, "body": "\n\nHow do I catch multiple exceptions in one line (except block)\n\n\n\n\nDo this:\n\n\ntry:\n    may_raise_specific_errors():\nexcept (SpecificErrorOne, SpecificErrorTwo) as error:\n    handle(error) # might log or have some other default behavior...\n\n\n\nThe parentheses are required due to older syntax that used the commas to assign the error object to a name. The \nas\n keyword is used for the assignment. You can use any name for the error object, I prefer \nerror\n personally.\n\n\nBest Practice\n\n\nTo do this in a manner currently and forward compatible with Python, you need to separate the Exceptions with commas and wrap them with parentheses to differentiate from earlier syntax that assigned the exception instance to a variable name by following the Exception type to be caught with a comma. \n\n\nHere's an example of simple usage:\n\n\nimport sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError): # the parens are necessary\n    sys.exit(0)\n\n\n\nI'm specifying only these exceptions to avoid hiding bugs, which if I encounter I expect the full stack trace from.\n\n\nThis is documented here: \nhttps://docs.python.org/tutorial/errors.html\n\n\nYou can assign the exception to a variable, (\ne\n is common, but you might prefer a more verbose variable if you have long exception handling or your IDE only highlights selections larger than that, as mine does.) The instance has an args attribute. Here is an example:\n\n\nimport sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError) as err: \n    print(err)\n    print(err.args)\n    sys.exit(0)\n\n\n\nNote that in Python 3, the \nerr\n object falls out of scope when the \nexcept\n block is concluded.\n\n\nDeprecated\n\n\nYou may see code that assigns the error with a comma. This usage, the only form available in Python 2.5 and earlier, is deprecated, and if you wish your code to be forward compatible in Python 3, you should update the syntax to use the new form:\n\n\nimport sys\n\ntry:\n    mainstuff()\nexcept (KeyboardInterrupt, EOFError), err: # don't do this in Python 2.6+\n    print err\n    print err.args\n    sys.exit(0)\n\n\n\nIf you see the comma name assignment in your codebase, and you're using Python 2.5 or higher, switch to the new way of doing it so your code remains compatible when you upgrade.\n\n\nThe \nsuppress\n context manager\n\n\nThe accepted answer is really 4 lines of code, minimum:\n\n\ntry:\n    do_something()\nexcept (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n\n\n\nThe \ntry\n, \nexcept\n, \npass\n lines can be handled in a single line with the \nsuppress context manager, available in Python 3.4\n:\n\n\nfrom contextlib import suppress\n\nwith suppress(IDontLikeYouException, YouAreBeingMeanException):\n     do_something()\n\n\n\nSo when you want to \npass\n on certain exceptions, use \nsuppress\n.\n\n", "score": 548}}
{"question": "How can I catch multiple exceptions in one line? (in the &quot;except&quot; block)", "tags": ["python", "exception"], "link": "https://stackoverflow.com/questions/6470428/how-can-i-catch-multiple-exceptions-in-one-line-in-the-except-block", "answer_count": 6, "answers": {"id": 6470452, "body": "From \nPython Documentation\n:\n\n\n\n\nAn except clause may name multiple exceptions as a parenthesized tuple, for example\n\n\n\n\nexcept (IDontLikeYouException, YouAreBeingMeanException) as e:\n    pass\n\n\n\nOr, for Python 2 only:\n\n\nexcept (IDontLikeYouException, YouAreBeingMeanException), e:\n    pass\n\n\n\nSeparating the exception from the variable with a comma will still work in Python 2.6 and 2.7, but is now deprecated and does not work in Python 3; now you should be using \nas\n.\n\n", "score": 5242}}
{"question": "How do I get the current time in Python?", "tags": ["python", "datetime", "time"], "link": "https://stackoverflow.com/questions/415511/how-do-i-get-the-current-time-in-python", "answer_count": 54, "answers": {"id": 14229023, "body": "from datetime import datetime\ndatetime.now().strftime('%Y-%m-%d %H:%M:%S')\n\n\n\nExample output: \n'2013-09-18 11:16:32'\n\n\nSee list of \nstrftime\n directives\n.\n\n", "score": 886}}
{"question": "How do I get the current time in Python?", "tags": ["python", "datetime", "time"], "link": "https://stackoverflow.com/questions/415511/how-do-i-get-the-current-time-in-python", "answer_count": 54, "answers": {"id": 415525, "body": "Use \ntime.strftime()\n:\n\n\n>>> from time import gmtime, strftime\n>>> strftime(\"%Y-%m-%d %H:%M:%S\", gmtime())\n'2009-01-05 22:14:39'\n\n\n", "score": 1233}}
{"question": "How do I get the current time in Python?", "tags": ["python", "datetime", "time"], "link": "https://stackoverflow.com/questions/415511/how-do-i-get-the-current-time-in-python", "answer_count": 54, "answers": {"id": 415519, "body": "Use \ndatetime\n:\n\n\n>>> import datetime\n>>> now = datetime.datetime.now()\n>>> now\ndatetime.datetime(2009, 1, 6, 15, 8, 24, 78915)\n>>> print(now)\n2009-01-06 15:08:24.789150\n\n\n\nFor just the clock time without the date:\n\n\n>>> now.time()\ndatetime.time(15, 8, 24, 78915)\n>>> print(now.time())\n15:08:24.789150\n\n\n\n\n\nTo save typing, you can import the \ndatetime\n object from the \ndatetime\n module:\n\n\n>>> from datetime import datetime\n\n\n\nThen remove the prefix \ndatetime.\n from all of the above.\n\n", "score": 4006}}
{"question": "How can I use a global variable in a function?", "tags": ["python", "global-variables", "scope"], "link": "https://stackoverflow.com/questions/423379/how-can-i-use-a-global-variable-in-a-function", "answer_count": 27, "answers": {"id": 423401, "body": "You may want to explore the notion of \nnamespaces\n. In Python, the \nmodule\n is the natural place for \nglobal\n data:\n\n\n\n\nEach module has its own private symbol table, which is used as the global symbol table by all functions defined in the module. Thus, the author of a module can use global variables in the module without worrying about accidental clashes with a user\u2019s global variables. On the other hand, if you know what you are doing you can touch a module\u2019s global variables with the same notation used to refer to its functions, \nmodname.itemname\n.\n\n\n\n\nA specific use of global-in-a-module is described here - \nHow do I share global variables across modules?\n, and for completeness the contents are shared here:\n\n\n\n\nThe canonical way to share information across modules within a single program is to create a special configuration module (often called \nconfig\n or \ncfg\n). Just import the configuration module in all modules of your application; the module then becomes available as a global name. Because there is only one instance of each module, any changes made to the module object get reflected everywhere. For example:\n\n\n\n\n\n\nFile: config.py\n\n\n\n\n\n\nx = 0   # Default value of the 'x' configuration setting\n\n\n\n\n\n\n\nFile: mod.py\n\n\n\n\nimport config\nconfig.x = 1\n\n\n\n\n\nFile: main.py\n\n\n\n\nimport config\nimport mod\nprint config.x\n\n\n", "score": 283}}
{"question": "How can I use a global variable in a function?", "tags": ["python", "global-variables", "scope"], "link": "https://stackoverflow.com/questions/423379/how-can-i-use-a-global-variable-in-a-function", "answer_count": 27, "answers": {"id": 423668, "body": "If I'm understanding your situation correctly, what you're seeing is the result of how Python handles local (function) and global (module) namespaces.\n\n\nSay you've got a module like this:\n\n\n# sample.py\n_my_global = 5\n\ndef func1():\n    _my_global = 42\n\ndef func2():\n    print _my_global\n\nfunc1()\nfunc2()\n\n\n\nYou might be expecting this to print 42, but instead, it prints 5.  As has already been mentioned, if you add a '\nglobal\n' declaration to \nfunc1()\n, then \nfunc2()\n will print 42.\n\n\ndef func1():\n    global _my_global \n    _my_global = 42\n\n\n\nWhat's going on here is that Python assumes that any name that is \nassigned to\n, anywhere within a function, is local to that function unless explicitly told otherwise.  If it is only \nreading\n from a name, and the name doesn't exist locally, it will try to look up the name in any containing scopes (e.g. the module's global scope).\n\n\nWhen you assign 42 to the name \n_my_global\n, therefore, Python creates a local variable that shadows the global variable of the same name.  That local goes out of scope and is \ngarbage-collected\n when \nfunc1()\n returns; meanwhile, \nfunc2()\n can never see anything other than the (unmodified) global name.  Note that this namespace decision happens at compile time, not at runtime -- if you were to read the value of \n_my_global\n inside \nfunc1()\n before you assign to it, you'd get an \nUnboundLocalError\n, because Python has already decided that it must be a local variable but it has not had any value associated with it yet.  But by using the '\nglobal\n' statement, you tell Python that it should look elsewhere for the name instead of assigning to it locally.\n\n\n(I believe that this behavior originated largely through optimization of local namespaces -- without this behavior,  Python's VM would need to perform at least three name lookups each time a new name is assigned to inside a function (to ensure that the name didn't already exist at module/builtin level), which would significantly slow down a very common operation.)\n\n", "score": 928}}
{"question": "How can I use a global variable in a function?", "tags": ["python", "global-variables", "scope"], "link": "https://stackoverflow.com/questions/423379/how-can-i-use-a-global-variable-in-a-function", "answer_count": 27, "answers": {"id": 423596, "body": "You can use a global variable within other functions by declaring it as \nglobal\n \nwithin each function that assigns a value to it\n:\n\n\nglobvar = 0\n\ndef set_globvar_to_one():\n    global globvar    # Needed to modify global copy of globvar\n    globvar = 1\n\ndef print_globvar():\n    print(globvar)     # No need for global declaration to read value of globvar\n\nset_globvar_to_one()\nprint_globvar()       # Prints 1\n\n\n\nSince it's unclear whether \nglobvar = 1\n is creating a local variable or changing a global variable, Python defaults to creating a local variable, and makes you explicitly choose the other behavior with the \nglobal\n keyword.\n\n\nSee other answers if you want to share a global variable across modules.\n\n", "score": 5268}}
{"question": "How can I iterate over rows in a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe", "loops"], "link": "https://stackoverflow.com/questions/16476924/how-can-i-iterate-over-rows-in-a-pandas-dataframe", "answer_count": 35, "answers": {"id": 41022840, "body": "First consider if you really need to \niterate\n over rows in a DataFrame. See \ncs95's answer\n for alternatives.\n\n\nIf you still need to iterate over rows, you can use methods below. Note some  \nimportant caveats\n which are not mentioned in any of the other answers.\n\n\n\n\nDataFrame.iterrows()\n\n\nfor index, row in df.iterrows():\n    print(row[\"c1\"], row[\"c2\"])\n\n\n\n\n\nDataFrame.itertuples()\n\n\nfor row in df.itertuples(index=True, name='Pandas'):\n    print(row.c1, row.c2)\n\n\n\n\n\n\n\nitertuples()\n is supposed to be faster than \niterrows()\n\n\nBut be aware, according to the docs (pandas 0.24.2 at the moment):\n\n\n\n\niterrows: \ndtype\n might not match from row to row\n\n\n\nBecause iterrows returns a Series for each row, it \ndoes not preserve\n dtypes across the rows (dtypes are preserved across columns for DataFrames). To preserve dtypes while iterating over the rows, it is better to use itertuples() which returns namedtuples of the values and which is generally much faster than iterrows()\n\n\n\n\n\n\n\n\n\n\niterrows: Do not modify rows\n\n\n\n\nYou should \nnever modify\n something you are iterating over. This is not guaranteed to work in all cases. Depending on the data types, the iterator returns a copy and not a view, and writing to it will have no effect.\n\n\n\n\nUse \nDataFrame.apply()\n instead:\n\n\nnew_df = df.apply(lambda x: x * 2, axis=1)\n\n\n\n\n\nitertuples:\n\n\n\n\nThe column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore. With a large number of columns (>255), regular tuples are returned.\n\n\n\n\n\n\n\n\nSee \npandas docs on iteration\n for more details.\n\n", "score": 579}}
{"question": "How can I iterate over rows in a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe", "loops"], "link": "https://stackoverflow.com/questions/16476924/how-can-i-iterate-over-rows-in-a-pandas-dataframe", "answer_count": 35, "answers": {"id": 55557758, "body": "\n\nHow to iterate over rows in a DataFrame in Pandas\n\n\n\n\nAnswer: DON'T\n*\n!\n\n\nIteration in Pandas is an anti-pattern and is something you should only do when you have exhausted every other option. You should not use any function with \"\niter\n\" in its name for more than a few thousand rows or you will have to get used to a \nlot\n of waiting.\n\n\nDo you want to print a DataFrame? Use \nDataFrame.to_string()\n.\n\n\nDo you want to compute something? In that case, search for methods in this order (list modified from \nhere\n):\n\n\n\n\nVectorization\n\n\nCython\n routines\n\n\nList Comprehensions (vanilla \nfor\n loop)\n\n\nDataFrame.apply()\n: i) \u00a0Reductions that can be performed in Cython, ii) Iteration in Python space\n\n\nitems()\n \niteritems()\n \n(deprecated since v1.5.0)\n\n\nDataFrame.itertuples()\n\n\nDataFrame.iterrows()\n\n\n\n\niterrows\n and \nitertuples\n (both receiving many votes in answers to this question) should be used in very rare circumstances, such as generating row objects/nametuples for sequential processing, which is really the only thing these functions are useful for.\n\n\nAppeal to Authority\n\n\nThe documentation page\n on iteration has a huge red warning box that says:\n\n\n\n\nIterating through pandas objects is generally slow. In many cases, iterating manually over the rows is not needed [...].\n\n\n\n\n* It's actually a little more complicated than \"don't\". \ndf.iterrows()\n is the correct answer to this question, but \"vectorize your ops\" is the better one. I will concede that there are circumstances where iteration cannot be avoided (for example, some operations where the result depends on the value computed for the previous row). However, it takes some familiarity with the library to know when. If you're not sure whether you need an iterative solution, you probably don't. PS: To know more about my rationale for writing this answer, skip to the very bottom.\n\n\n\n\nFaster than Looping: \nVectorization\n, \nCython\n\n\nA good number of basic operations and computations are \"vectorised\" by pandas (either through NumPy, or through Cythonized functions). This includes arithmetic, comparisons, (most) reductions, reshaping (such as pivoting), joins, and groupby operations. Look through the documentation on \nEssential Basic Functionality\n to find a suitable vectorised method for your problem.\n\n\nIf none exists, feel free to write your own using custom \nCython extensions\n.\n\n\n\n\nNext Best Thing: \nList Comprehensions\n*\n\n\nList comprehensions should be your next port of call if 1) there is no vectorized solution available, 2) performance is important, but not important enough to go through the hassle of cythonizing your code, and 3) you're trying to perform elementwise transformation on your code. There is a \ngood amount of evidence\n to suggest that list comprehensions are sufficiently fast (and even sometimes faster) for many common Pandas tasks.\n\n\nThe formula is simple,\n\n\n# Iterating over one column - `f` is some function that processes your data\nresult = [f(x) for x in df['col']]\n\n# Iterating over two columns, use `zip`\nresult = [f(x, y) for x, y in zip(df['col1'], df['col2'])]\n\n# Iterating over multiple columns - same data type\nresult = [f(row[0], ..., row[n]) for row in df[['col1', ...,'coln']].to_numpy()]\n\n# Iterating over multiple columns - differing data type\nresult = [f(row[0], ..., row[n]) for row in zip(df['col1'], ..., df['coln'])]\n\n\n\nIf you can encapsulate your business logic into a function, you can use a list comprehension that calls it. You can make arbitrarily complex things work through the simplicity and speed of raw Python code.\n\n\nCaveats\n\n\nList comprehensions assume that your data is easy to work with - what that means is your data types are consistent and you don't have NaNs, but this cannot always be guaranteed.\n\n\n\n\nThe first one is more obvious, but when dealing with NaNs, prefer in-built pandas methods if they exist (because they have much better corner-case handling logic), or ensure your business logic includes appropriate NaN handling logic.\n\n\nWhen dealing with mixed data types you should iterate over \nzip(df['A'], df['B'], ...)\n instead of \ndf[['A', 'B']].to_numpy()\n as the latter implicitly upcasts data to the most common type. As an example if A is numeric and B is string, \nto_numpy()\n will cast the entire array to string, which may not be what you want. Fortunately \nzip\nping your columns together is the most straightforward workaround to this.\n\n\n\n\n*Your mileage may vary for the reasons outlined in the \nCaveats\n section above.\n\n\n\n\nAn Obvious Example\n\n\nLet's demonstrate the difference with a simple example of adding two pandas columns \nA + B\n. This is a vectorizable operation, so it will be easy to contrast the performance of the methods discussed above.\n\n\n\n\nBenchmarking code, for your reference\n. The line at the bottom measures a function written in numpandas, a style of Pandas that mixes heavily with NumPy to squeeze out maximum performance. Writing numpandas code should be avoided unless you know what you're doing. Stick to the API where you can (i.e., prefer \nvec\n over \nvec_numpy\n).\n\n\nI should mention, however, that it isn't always this cut and dry. Sometimes the answer to \"what is the best method for an operation\" is \"it depends on your data\". My advice is to test out different approaches on your data before settling on one.\n\n\n\n\nMy Personal Opinion \n*\n\n\nMost of the analyses performed on the various alternatives to the iter family has been through the lens of performance. However, in most situations you will typically be working on a reasonably sized dataset (nothing beyond a few thousand or 100K rows) and performance will come second to simplicity/readability of the solution.\n\n\nHere is my personal preference when selecting a method to use for a problem.\n\n\nFor the novice:\n\n\n\n\nVectorization\n (when possible)\n; \napply()\n; List Comprehensions; \nitertuples()\n/\niteritems()\n; \niterrows()\n; Cython\n\n\n\n\nFor the more experienced:\n\n\n\n\nVectorization\n (when possible)\n; \napply()\n; List Comprehensions; Cython; \nitertuples()\n/\niteritems()\n; \niterrows()\n\n\n\n\nVectorization prevails as the most idiomatic method for any problem that can be vectorized. Always seek to vectorize! When in doubt, consult the docs, or look on Stack Overflow for an existing question on your particular task.\n\n\nI do tend to go on about how bad \napply\n is in a lot of my posts, but I do concede it is easier for a beginner to wrap their head around what it's doing. Additionally, there are quite a few use cases for \napply\n has explained in \nthis post of mine\n.\n\n\nCython ranks lower down on the list because it takes more time and effort to pull off correctly. You will usually never need to write code with pandas that demands this level of performance that even a list comprehension cannot satisfy.\n\n\n* As with any personal opinion, please take with heaps of salt!\n\n\n\n\nFurther Reading\n\n\n\n\n10 Minutes to pandas\n, and \nEssential Basic Functionality\n - Useful links that introduce you to Pandas and its library of vectorized*/cythonized functions.\n\n\n\n\nEnhancing Performance\n - A primer from the documentation on enhancing standard Pandas operations\n\n\n\n\nAre for-loops in pandas really bad? When should I care?\n - a detailed write-up by me on list comprehensions and their suitability for various operations (mainly ones involving non-numeric data)\n\n\n\n\nWhen should I (not) want to use pandas apply() in my code?\n - \napply\n is slow (but not as slow as the \niter*\n family. There are, however, situations where one can (or should) consider \napply\n as a serious alternative, especially in some \nGroupBy\n operations).\n\n\n\n\n\n\n* Pandas string methods are \"vectorized\" in the sense that they are specified on the series but operate on each element. The underlying mechanisms are still iterative, because string operations are inherently hard to vectorize.\n\n\n\n\nWhy I Wrote this Answer\n\n\nA common trend I notice from new users is to ask questions of the form \"How can I iterate over my df to do X?\". Showing code that calls \niterrows()\n while doing something inside a \nfor\n loop. Here is why. A new user to the library who has not been introduced to the concept of vectorization will likely envision the code that solves their problem as iterating over their data to do something. Not knowing how to iterate over a DataFrame, the first thing they do is Google it and end up here, at this question. They then see the accepted answer telling them how to, and they close their eyes and run this code without ever first questioning if iteration is the right thing to do.\n\n\nThe aim of this answer is to help new users understand that iteration is not necessarily the solution to every problem, and that better, faster and more idiomatic solutions could exist, and that it is worth investing time in exploring them. I'm not trying to start a war of iteration vs. vectorization, but I want new users to be informed when developing solutions to their problems with this library.\n\n\nAnd finally ... a TLDR to summarize this post\n\n\n\n", "score": 2515}}
{"question": "How can I iterate over rows in a Pandas DataFrame?", "tags": ["python", "pandas", "dataframe", "loops"], "link": "https://stackoverflow.com/questions/16476924/how-can-i-iterate-over-rows-in-a-pandas-dataframe", "answer_count": 35, "answers": {"id": 16476974, "body": "DataFrame.iterrows\n is a generator which yields both the index and row (as a Series):\n\n\nimport pandas as pd\n\ndf = pd.DataFrame({'c1': [10, 11, 12], 'c2': [100, 110, 120]})\ndf = df.reset_index()  # make sure indexes pair with number of rows\n\nfor index, row in df.iterrows():\n    print(row['c1'], row['c2'])\n\n\n\n10 100\n11 110\n12 120\n\n\n\n\n\nObligatory disclaimer from the \ndocumentation\n\n\n\n\nIterating through pandas objects is generally \nslow\n. In many cases, iterating manually over the rows is not needed and can be avoided with one of the following approaches:\n\n\n\n\nLook for a \nvectorized\n solution: many operations can be performed using built-in methods or NumPy functions, (boolean) indexing, \u2026\n\n\nWhen you have a function that cannot work on the full DataFrame/Series at once, it is better to use \napply()\n instead of iterating over the values. See the docs on \nfunction application\n.\n\n\nIf you need to do iterative manipulations on the values but performance is important, consider writing the inner loop with cython or numba. See the \nenhancing performance\n section for some examples of this approach.\n\n\n\n\n\n\nOther answers in this thread delve into greater depth on alternatives to iter* functions if you are interested to learn more.\n\n", "score": 5479}}
{"question": "Iterating over dictionaries using &#39;for&#39; loops", "tags": ["python", "loops", "dictionary", "key"], "link": "https://stackoverflow.com/questions/3294889/iterating-over-dictionaries-using-for-loops", "answer_count": 17, "answers": {"id": 3295662, "body": "Iterating over a \ndict\n iterates through its keys in no particular order, as you can see here:\n\n\n(This is practically \nno longer the case since Python 3.6\n, but note that it's only guaranteed behaviour since Python 3.7.)\n\n\n>>> d = {'x': 1, 'y': 2, 'z': 3}\n>>> list(d)\n['y', 'x', 'z']\n>>> d.keys()\n['y', 'x', 'z']\n\n\n\nFor your example, it is a better idea to use \ndict.items()\n:\n\n\n>>> d.items()\n[('y', 2), ('x', 1), ('z', 3)]\n\n\n\nThis gives you a list of tuples. When you loop over them like this, each tuple is unpacked into \nk\n and \nv\n automatically:\n\n\nfor k,v in d.items():\n    print(k, 'corresponds to', v)\n\n\n\nUsing \nk\n and \nv\n as variable names when looping over a \ndict\n is quite common if the body of the loop is only a few lines. For more complicated loops it may be a good idea to use more descriptive names:\n\n\nfor letter, number in d.items():\n    print(letter, 'corresponds to', number)\n\n\n\nIt's a good idea to get into the habit of using format strings:\n\n\nfor letter, number in d.items():\n    print('{0} corresponds to {1}'.format(letter, number))\n\n\n", "score": 277}}
{"question": "Iterating over dictionaries using &#39;for&#39; loops", "tags": ["python", "loops", "dictionary", "key"], "link": "https://stackoverflow.com/questions/3294889/iterating-over-dictionaries-using-for-loops", "answer_count": 17, "answers": {"id": 3295295, "body": "It's not that key is a special word, but that dictionaries implement the iterator protocol.  You could do this in your class, e.g. see \nthis question\n for how to build class iterators.\n\n\nIn the case of dictionaries, it's implemented at the C level.  The details are available in \nPEP 234\n.  In particular, the section titled \"Dictionary Iterators\":\n\n\n\n\n\n\nDictionaries implement a tp_iter slot that returns an efficient\n  iterator that iterates over the keys of the dictionary. [...] This \n  means that we can write\n\n\nfor k in dict: ...\n\n\n\nwhich is equivalent to, but much faster than\n\n\nfor k in dict.keys(): ...\n\n\n\nas long as the restriction on modifications to the dictionary\n  (either by the loop or by another thread) are not violated.\n\n\nAdd methods to dictionaries that return different kinds of\n  iterators explicitly:\n\n\nfor key in dict.iterkeys(): ...\n\nfor value in dict.itervalues(): ...\n\nfor key, value in dict.iteritems(): ...\n\n\n\nThis means that \nfor x in dict\n is shorthand for \nfor x in\n   dict.iterkeys()\n.\n\n\n\n\n\n\nIn Python 3, \ndict.iterkeys()\n, \ndict.itervalues()\n and \ndict.iteritems()\n are no longer supported. Use \ndict.keys()\n, \ndict.values()\n and \ndict.items()\n instead.\n\n", "score": 565}}
{"question": "Iterating over dictionaries using &#39;for&#39; loops", "tags": ["python", "loops", "dictionary", "key"], "link": "https://stackoverflow.com/questions/3294889/iterating-over-dictionaries-using-for-loops", "answer_count": 17, "answers": {"id": 3294899, "body": "key\n is just a variable name.  \n\n\nfor key in d:\n\n\n\nwill simply loop over the keys in the dictionary, rather than the keys and values.  To loop over both key and value you can use the following:\n\n\nFor Python 3.x:\n\n\nfor key, value in d.items():\n\n\n\nFor Python 2.x:\n\n\nfor key, value in d.iteritems():\n\n\n\nTo test for yourself, change the word \nkey\n to \npoop\n.\n\n\nIn Python 3.x, \niteritems()\n was replaced with simply \nitems()\n, which returns a set-like view backed by the dict, like \niteritems()\n but even better. \nThis is also available in 2.7 as \nviewitems()\n. \n\n\nThe operation \nitems()\n will work for both 2 and 3, but in 2 it will return a list of the dictionary's \n(key, value)\n pairs, which will not reflect changes to the dict that happen after the \nitems()\n call. If you want the 2.x behavior in 3.x, you can call \nlist(d.items())\n.\n\n", "score": 6990}}
{"question": "How can I find the index for a given item in a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/176918/how-can-i-find-the-index-for-a-given-item-in-a-list", "answer_count": 47, "answers": {"id": 17300987, "body": "To get all indexes:\n\n\nindexes = [i for i, x in enumerate(xs) if x == 'foo']\n\n\n", "score": 246}}
{"question": "How can I find the index for a given item in a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/176918/how-can-i-find-the-index-for-a-given-item-in-a-list", "answer_count": 47, "answers": {"id": 17202481, "body": "The majority of answers explain how to find \na single index\n, but their methods do not return multiple indexes if the item is in the list multiple times. Use \nenumerate()\n:\n\n\nfor i, j in enumerate(['foo', 'bar', 'baz']):\n    if j == 'bar':\n        print(i)\n\n\n\nThe \nindex()\n function only returns the first occurrence, while \nenumerate()\n returns all occurrences.\n\n\nAs a list comprehension:\n\n\n[i for i, j in enumerate(['foo', 'bar', 'baz']) if j == 'bar']\n\n\n\n\n\nHere's also another small solution with \nitertools.count()\n (which is pretty much the same approach as enumerate):\n\n\nfrom itertools import izip as zip, count # izip for maximum efficiency\n[i for i, j in zip(count(), ['foo', 'bar', 'baz']) if j == 'bar']\n\n\n\nThis is more efficient for larger lists than using \nenumerate()\n:\n\n\n$ python -m timeit -s \"from itertools import izip as zip, count\" \"[i for i, j in zip(count(), ['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 174 usec per loop\n$ python -m timeit \"[i for i, j in enumerate(['foo', 'bar', 'baz']*500) if j == 'bar']\"\n10000 loops, best of 3: 196 usec per loop\n\n\n", "score": 722}}
{"question": "How can I find the index for a given item in a list?", "tags": ["python", "list", "indexing"], "link": "https://stackoverflow.com/questions/176918/how-can-i-find-the-index-for-a-given-item-in-a-list", "answer_count": 47, "answers": {"id": 176921, "body": ">>> [\"foo\", \"bar\", \"baz\"].index(\"bar\")\n1\n\n\n\nSee \nthe documentation\n for the built-in \n.index()\n method of the list:\n\n\n\n\nlist.index(x[, start[, end]])\n\n\n\nReturn zero-based index in the list of the first item whose value is equal to \nx\n. Raises a \nValueError\n if there is no such item.\n\n\nThe optional arguments \nstart\n and \nend\n are interpreted as in the \nslice notation\n and are used to limit the search to a particular subsequence of the list. The returned index is computed relative to the beginning of the full sequence rather than the start argument.\n\n\n\n\nCaveats\n\n\nLinear time-complexity in list length\n\n\nAn \nindex\n call checks every element of the list in order, until it finds a match. If the list is long, and if there is no guarantee that the value will be near the beginning, this can slow down the code.\n\n\nThis problem can only be completely avoided by using a different data structure. However, if the element is known to be within a certain part of the list, the \nstart\n and \nend\n parameters can be used to narrow the search.\n\n\nFor example:\n\n\n>>> import timeit\n>>> timeit.timeit('l.index(999_999)', setup='l = list(range(0, 1_000_000))', number=1000)\n9.356267921015387\n>>> timeit.timeit('l.index(999_999, 999_990, 1_000_000)', setup='l = list(range(0, 1_000_000))', number=1000)\n0.0004404920036904514\n\n\n\nThe second call is orders of magnitude faster, because it only has to search through 10 elements, rather than all 1 million.\n\n\nOnly the index of the \nfirst match\n is returned\n\n\nA call to \nindex\n searches through the list in order until it finds a match, and \nstops there.\n If there could be more than one occurrence of the value, and all indices are needed, \nindex\n cannot solve the problem:\n\n\n>>> [1, 1].index(1) # the `1` index is not found.\n0\n\n\n\nInstead, use a \nlist comprehension or generator expression to do the search\n, with \nenumerate\n to get indices\n:\n\n\n>>> # A list comprehension gives a list of indices directly:\n>>> [i for i, e in enumerate([1, 2, 1]) if e == 1]\n[0, 2]\n>>> # A generator comprehension gives us an iterable object...\n>>> g = (i for i, e in enumerate([1, 2, 1]) if e == 1)\n>>> # which can be used in a `for` loop, or manually iterated with `next`:\n>>> next(g)\n0\n>>> next(g)\n2\n\n\n\nThe list comprehension and generator expression techniques still work if there is only one match, and are more generalizable.\n\n\nRaises an exception if there is no match\n\n\nAs noted in the documentation above, using \n.index\n will raise an exception if the searched-for value is not in the list:\n\n\n>>> [1, 1].index(2)\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nValueError: 2 is not in list\n\n\n\nIf this is a concern, either \nexplicitly check first\n using \nitem in my_list\n, or handle the exception with \ntry\n/\nexcept\n as appropriate.\n\n\nThe explicit check is simple and readable, but it must iterate the list a second time. See \nWhat is the EAFP principle in Python?\n for more guidance on this choice.\n\n", "score": 6084}}
{"question": "How slicing in Python works", "tags": ["python", "slice", "sequence"], "link": "https://stackoverflow.com/questions/509211/how-slicing-in-python-works", "answer_count": 38, "answers": {"id": 509377, "body": "Enumerating the possibilities allowed by the grammar for the sequence \nx\n:\n\n\n>>> x[:]                # [x[0],   x[1],          ..., x[-1]    ]\n>>> x[low:]             # [x[low], x[low+1],      ..., x[-1]    ]\n>>> x[:high]            # [x[0],   x[1],          ..., x[high-1]]\n>>> x[low:high]         # [x[low], x[low+1],      ..., x[high-1]]\n>>> x[::stride]         # [x[0],   x[stride],     ..., x[-1]    ]\n>>> x[low::stride]      # [x[low], x[low+stride], ..., x[-1]    ]\n>>> x[:high:stride]     # [x[0],   x[stride],     ..., x[high-1]]\n>>> x[low:high:stride]  # [x[low], x[low+stride], ..., x[high-1]]\n\n\n\nOf course, if \n(high-low)%stride != 0\n, then the end point will be a little lower than \nhigh-1\n.\n\n\nIf \nstride\n is negative, the ordering is changed a bit since we're counting down:\n\n\n>>> x[::-stride]        # [x[-1],   x[-1-stride],   ..., x[0]    ]\n>>> x[high::-stride]    # [x[high], x[high-stride], ..., x[0]    ]\n>>> x[:low:-stride]     # [x[-1],   x[-1-stride],   ..., x[low+1]]\n>>> x[high:low:-stride] # [x[high], x[high-stride], ..., x[low+1]]\n\n\n\nExtended slicing (with commas and ellipses) are mostly used only by special data structures (like NumPy); the basic sequences don't support them.\n\n\n>>> class slicee:\n...     def __getitem__(self, item):\n...         return repr(item)\n...\n>>> slicee()[0, 1:2, ::5, ...]\n'(0, slice(1, 2, None), slice(None, None, 5), Ellipsis)'\n\n\n", "score": 560}}
{"question": "How slicing in Python works", "tags": ["python", "slice", "sequence"], "link": "https://stackoverflow.com/questions/509211/how-slicing-in-python-works", "answer_count": 38, "answers": {"id": 509297, "body": "The \nPython tutorial\n talks about it (scroll down a bit until you get to the part about slicing).\n\n\nThe ASCII art diagram is helpful too for remembering how slices work:\n\n\n +---+---+---+---+---+---+\n | P | y | t | h | o | n |\n +---+---+---+---+---+---+\n   0   1   2   3   4   5\n  -6  -5  -4  -3  -2  -1\n\n\n\n\n\nOne way to remember how slices work is to think of the indices as pointing \nbetween\n characters, with the left edge of the first character numbered 0. Then the right edge of the last character of a string of \nn\n characters has index \nn\n.\n\n\n\n", "score": 724}}
{"question": "How slicing in Python works", "tags": ["python", "slice", "sequence"], "link": "https://stackoverflow.com/questions/509211/how-slicing-in-python-works", "answer_count": 38, "answers": {"id": 509295, "body": "The syntax is:\n\n\na[start:stop]  # items start through stop-1\na[start:]      # items start through the rest of the array\na[:stop]       # items from the beginning through stop-1\na[:]           # a copy of the whole array\n\n\n\nThere is also the \nstep\n value, which can be used with any of the above:\n\n\na[start:stop:step] # start through not past stop, by step\n\n\n\nThe key point to remember is that the \n:stop\n value represents the first value that is \nnot\n in the selected slice. So, the difference between \nstop\n and \nstart\n is the number of elements selected (if \nstep\n is 1, the default).\n\n\nThe other feature is that \nstart\n or \nstop\n may be a \nnegative\n number, which means it counts from the end of the array instead of the beginning. So:\n\n\na[-1]    # last item in the array\na[-2:]   # last two items in the array\na[:-2]   # everything except the last two items\n\n\n\nSimilarly, \nstep\n may be a negative number:\n\n\na[::-1]    # all items in the array, reversed\na[1::-1]   # the first two items, reversed\na[:-3:-1]  # the last two items, reversed\na[-3::-1]  # everything except the last two items, reversed\n\n\n\nPython is kind to the programmer if there are fewer items than you ask for. For example, if you ask for \na[:-2]\n and \na\n only contains one element, you get an empty list instead of an error. Sometimes you would prefer the error, so you have to be aware that this may happen.\n\n\nRelationship with the \nslice\n object\n\n\nA \nslice\n object\n can represent a slicing operation, i.e.:\n\n\na[start:stop:step]\n\n\n\nis equivalent to:\n\n\na[slice(start, stop, step)]\n\n\n\nSlice objects also behave slightly differently depending on the number of arguments, similar to \nrange()\n, i.e. both \nslice(stop)\n and \nslice(start, stop[, step])\n are supported.\nTo skip specifying a given argument, one might use \nNone\n, so that e.g. \na[start:]\n is equivalent to \na[slice(start, None)]\n or \na[::-1]\n is equivalent to \na[slice(None, None, -1)]\n.\n\n\nWhile the \n:\n-based notation is very helpful for simple slicing, the explicit use of \nslice()\n objects simplifies the programmatic generation of slicing.\n\n", "score": 6621}}
{"question": "What is the difference between @staticmethod and @classmethod in Python?", "tags": ["python", "oop", "static-methods", "python-decorators", "class-method"], "link": "https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python", "answer_count": 36, "answers": {"id": 136149, "body": "Basically \n@classmethod\n makes a method whose first argument is the class it's called from (rather than the class instance), \n@staticmethod\n does not have any implicit arguments.\n\n", "score": 206}}
{"question": "What is the difference between @staticmethod and @classmethod in Python?", "tags": ["python", "oop", "static-methods", "python-decorators", "class-method"], "link": "https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python", "answer_count": 36, "answers": {"id": 136138, "body": "A \nstaticmethod\n is a method that knows nothing about the class or instance it was called on. It just gets the arguments that were passed, no implicit first argument.\n\n\nA \nclassmethod\n, on the other hand, is a method that gets passed the class it was called on, or the class of the instance it was called on, as first argument. This is useful when you want the method to be a factory for the class: since it gets the actual class it was called on as first argument, you can always instantiate the right class, even when subclasses are involved. Observe for instance how \ndict.fromkeys()\n, a classmethod, returns an instance of the subclass when called on a subclass:\n\n\n>>> class DictSubclass(dict):\n...     def __repr__(self):\n...         return \"DictSubclass\"\n... \n>>> dict.fromkeys(\"abc\")\n{'a': None, 'c': None, 'b': None}\n>>> DictSubclass.fromkeys(\"abc\")\nDictSubclass\n>>> \n\n\n", "score": 979}}
{"question": "What is the difference between @staticmethod and @classmethod in Python?", "tags": ["python", "oop", "static-methods", "python-decorators", "class-method"], "link": "https://stackoverflow.com/questions/136097/what-is-the-difference-between-staticmethod-and-classmethod-in-python", "answer_count": 36, "answers": {"id": 1669524, "body": "Maybe a bit of example code will help: Notice the difference in the call signatures of \nfoo\n, \nclass_foo\n and \nstatic_foo\n:\n\n\nclass A(object):\n    def foo(self, x):\n        print(f\"executing foo({self}, {x})\")\n\n    @classmethod\n    def class_foo(cls, x):\n        print(f\"executing class_foo({cls}, {x})\")\n\n    @staticmethod\n    def static_foo(x):\n        print(f\"executing static_foo({x})\")\n\na = A()\n\n\n\nBelow is the usual way an object instance calls a method. The object instance, \na\n, is implicitly passed as the first argument.\n\n\na.foo(1)\n# executing foo(<__main__.A object at 0xb7dbef0c>, 1)\n\n\n\n\n\nWith classmethods\n, the class of the object instance is implicitly passed as the first argument instead of \nself\n.\n\n\na.class_foo(1)\n# executing class_foo(\n, 1)\n\n\n\nYou can also call \nclass_foo\n using the class. In fact, if you define something to be\na classmethod, it is probably because you intend to call it from the class rather than from a class instance. \nA.foo(1)\n would have raised a TypeError, but \nA.class_foo(1)\n works just fine:\n\n\nA.class_foo(1)\n# executing class_foo(\n, 1)\n\n\n\nOne use people have found for class methods is to create \ninheritable alternative constructors\n.\n\n\n\n\nWith staticmethods\n, neither \nself\n (the object instance) nor  \ncls\n (the class) is implicitly passed as the first argument. They behave like plain functions except that you can call them from an instance or the class:\n\n\na.static_foo(1)\n# executing static_foo(1)\n\nA.static_foo('hi')\n# executing static_foo(hi)\n\n\n\nStaticmethods are used to group functions which have some logical connection with a class to the class.\n\n\n\n\nfoo\n is just a function, but when you call \na.foo\n you don't just get the function,\nyou get a \"partially applied\" version of the function with the object instance \na\n bound as the first argument to the function. \nfoo\n expects 2 arguments, while \na.foo\n only expects 1 argument.\n\n\na\n is bound to \nfoo\n. That is what is meant by the term \"bound\" below:\n\n\nprint(a.foo)\n# \n>\n\n\n\nWith \na.class_foo\n, \na\n is not bound to \nclass_foo\n, rather the class \nA\n is bound to \nclass_foo\n.\n\n\nprint(a.class_foo)\n# \n>\n\n\n\nHere, with a staticmethod, even though it is a method, \na.static_foo\n just returns\na good 'ole function with no arguments bound. \nstatic_foo\n expects 1 argument, and\n\na.static_foo\n expects 1 argument too.\n\n\nprint(a.static_foo)\n# \n\n\n\n\nAnd of course the same thing happens when you call \nstatic_foo\n with the class \nA\n instead.\n\n\nprint(A.static_foo)\n# \n\n\n\n", "score": 3990}}
{"question": "How do I make a flat list out of a list of lists?", "tags": ["python", "list", "multidimensional-array", "flatten"], "link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists", "answer_count": 34, "answers": {"id": 952946, "body": "Note from the author\n: This is very inefficient. But fun, because \nmonoids\n are awesome.\n\n\n>>> xss = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\n>>> sum(xss, [])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\n\nsum\n sums the elements of the iterable \nxss\n, and uses the second argument as the initial value \n[]\n for the sum. (The default initial value is \n0\n, which is not a list.)\n\n\nBecause you are summing nested lists, you actually get \n[1,3]+[2,4]\n as a result of \nsum([[1,3],[2,4]],[])\n, which is equal to \n[1,3,2,4]\n.\n\n\nNote that only works on lists of lists. For lists of lists of lists, you'll need another solution.\n\n", "score": 1438}}
{"question": "How do I make a flat list out of a list of lists?", "tags": ["python", "list", "multidimensional-array", "flatten"], "link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists", "answer_count": 34, "answers": {"id": 953097, "body": "You can use \nitertools.chain()\n:\n\n\n>>> import itertools\n>>> list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n>>> merged = list(itertools.chain(*list2d))\n\n\n\nOr you can use \nitertools.chain.from_iterable()\n which doesn't require unpacking the list with the \n*\n operator:\n\n\n>>> import itertools\n>>> list2d = [[1,2,3], [4,5,6], [7], [8,9]]\n>>> merged = list(itertools.chain.from_iterable(list2d))\n\n\n\nThis approach is arguably more readable than \n[item for sublist in l for item in sublist]\n and appears to be faster too:\n\n\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;import itertools' 'list(itertools.chain.from_iterable(l))'\n20000 loops, best of 5: 10.8 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' '[item for sublist in l for item in sublist]'\n10000 loops, best of 5: 21.7 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99' 'sum(l, [])'\n1000 loops, best of 5: 258 usec per loop\n$ python3 -mtimeit -s'l=[[1,2,3],[4,5,6], [7], [8,9]]*99;from functools import reduce' 'reduce(lambda x,y: x+y,l)'\n1000 loops, best of 5: 292 usec per loop\n$ python3 --version\nPython 3.7.5rc1\n\n\n", "score": 2442}}
{"question": "How do I make a flat list out of a list of lists?", "tags": ["python", "list", "multidimensional-array", "flatten"], "link": "https://stackoverflow.com/questions/952914/how-do-i-make-a-flat-list-out-of-a-list-of-lists", "answer_count": 34, "answers": {"id": 952952, "body": "A list of lists named \nxss\n can be flattened using a nested \nlist comprehension\n:\n\n\nflat_list = [\n    x\n    for xs in xss\n    for x in xs\n]\n\n\n\nThe above is equivalent to:\n\n\nflat_list = []\n\nfor xs in xss:\n    for x in xs:\n        flat_list.append(x)\n\n\n\nHere is the corresponding function:\n\n\ndef flatten(xss):\n    return [x for xs in xss for x in xs]\n\n\n\nThis is the fastest method.\nAs evidence, using the \ntimeit\n module in the standard library, we see:\n\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' '[x for xs in xss for x in xs]'\n10000 loops, best of 3: 143 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'sum(xss, [])'\n1000 loops, best of 3: 969 usec per loop\n\n$ python -mtimeit -s'xss=[[1,2,3],[4,5,6],[7],[8,9]]*99' 'reduce(lambda xs, ys: xs + ys, xss)'\n1000 loops, best of 3: 1.1 msec per loop\n\n\n\nExplanation: the methods based on \n+\n (including the implied use in \nsum\n) are, of necessity, \nO(L**2)\n when there are L sublists -- as the intermediate result list keeps getting longer, at each step a new intermediate result list object gets allocated, and all the items in the previous intermediate result must be copied over (as well as a few new ones added at the end). So, for simplicity and without actual loss of generality, say you have L sublists of M items each: the first M items are copied back and forth \nL-1\n times, the second M items \nL-2\n times, and so on; total number of copies is M times the sum of x for x from 1 to L excluded, i.e., \nM * (L**2)/2\n.\n\n\nThe list comprehension just generates one list, once, and copies each item over (from its original place of residence to the result list) also exactly once.\n\n", "score": 7460}}
{"question": "How can I access the index value in a &#39;for&#39; loop?", "tags": ["python", "loops", "list"], "link": "https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop", "answer_count": 28, "answers": {"id": 23886515, "body": "It's pretty simple to start it from \n1\n other than \n0\n:\n\n\nfor index, item in enumerate(iterable, start=1):\n   print index, item  # Used to print in python<3.x\n   print(index, item) # Migrate to print() after 3.x+\n   \n\n\n", "score": 269}}
{"question": "How can I access the index value in a &#39;for&#39; loop?", "tags": ["python", "loops", "list"], "link": "https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop", "answer_count": 28, "answers": {"id": 28072982, "body": "\n\nUsing a for loop, how do I access the loop index, from 1 to 5 in this case?\n\n\n\n\nUse \nenumerate\n to get the index with the element as you iterate:\n\n\nfor index, item in enumerate(items):\n    print(index, item)\n\n\n\nAnd note that Python's indexes start at zero, so you would get 0 to 4 with the above. If you want the count, 1 to 5, do this:\n\n\ncount = 0 # in case items is empty and you need it after the loop\nfor count, item in enumerate(items, start=1):\n    print(count, item)\n\n\n\nUnidiomatic control flow\n\n\nWhat you are asking for is the Pythonic equivalent of the following, which is the algorithm most programmers of lower-level languages would use:\n\n\n\n\nindex = 0            # Python's indexing starts at zero\nfor item in items:   # Python's for loops are a \"for each\" loop \n    print(index, item)\n    index += 1\n\n\n\n\n\nOr in languages that do not have a for-each loop:\n\n\n\n\nindex = 0\nwhile index < len(items):\n    print(index, items[index])\n    index += 1\n\n\n\n\n\nor sometimes more commonly (but unidiomatically) found in Python:\n\n\n\n\nfor index in range(len(items)):\n    print(index, items[index])\n\n\n\n\n\nUse the Enumerate Function\n\n\nPython's \nenumerate\n function\n reduces the visual clutter by hiding the accounting for the indexes, and encapsulating the iterable into another iterable (an \nenumerate\n object) that yields a two-item tuple of the index and the item that the original iterable would provide. That looks like this:\n\n\nfor index, item in enumerate(items, start=0):   # default is zero\n    print(index, item)\n\n\n\nThis code sample is fairly well the \ncanonical\n example of the difference between code that is idiomatic of Python and code that is not. Idiomatic code is sophisticated (but not complicated) Python, written in the way that it was intended to be used. Idiomatic code is expected by the designers of the language, which means that usually this code is not just more readable, but also more efficient.\n\n\nGetting a count\n\n\nEven if you don't need indexes as you go, but you need a count of the iterations (sometimes desirable) you can start with \n1\n and the final number will be your count.\n\n\ncount = 0 # in case items is empty\nfor count, item in enumerate(items, start=1):   # default is zero\n    print(item)\n\nprint('there were {0} items printed'.format(count))\n\n\n\nThe count seems to be more what you intend to ask for (as opposed to index) when you said you wanted from 1 to 5.\n\n\n\n\nBreaking it down - a step by step explanation\n\n\nTo break these examples down, say we have a list of items that we want to iterate over with an index:\n\n\nitems = ['a', 'b', 'c', 'd', 'e']\n\n\n\nNow we pass this iterable to enumerate, creating an enumerate object:\n\n\nenumerate_object = enumerate(items) # the enumerate object\n\n\n\nWe can pull the first item out of this iterable that we would get in a loop with the \nnext\n function:\n\n\niteration = next(enumerate_object) # first iteration from enumerate\nprint(iteration)\n\n\n\nAnd we see we get a tuple of \n0\n, the first index, and \n'a'\n, the first item:\n\n\n(0, 'a')\n\n\n\nwe can use what is referred to as \"\nsequence unpacking\n\" to extract the elements from this two-tuple:\n\n\nindex, item = iteration\n#   0,  'a' = (0, 'a') # essentially this.\n\n\n\nand when we inspect \nindex\n, we find it refers to the first index, 0, and \nitem\n refers to the first item, \n'a'\n.\n\n\n>>> print(index)\n0\n>>> print(item)\na\n\n\n\nConclusion\n\n\n\n\nPython indexes start at zero\n\n\nTo get these indexes from an iterable as you iterate over it, use the enumerate function\n\n\nUsing enumerate in the idiomatic way (along with tuple unpacking) creates code that is more readable and maintainable:\n\n\n\n\nSo do this:\n\n\nfor index, item in enumerate(items, start=0):   # Python indexes start at zero\n    print(index, item)\n\n\n", "score": 1355}}
{"question": "How can I access the index value in a &#39;for&#39; loop?", "tags": ["python", "loops", "list"], "link": "https://stackoverflow.com/questions/522563/how-can-i-access-the-index-value-in-a-for-loop", "answer_count": 28, "answers": {"id": 522578, "body": "Use the built-in function \nenumerate()\n:\n\n\nfor idx, x in enumerate(xs):\n    print(idx, x)\n\n\n\nIt is \nnon-Pythonic\n to manually index via \nfor i in range(len(xs)): x = xs[i]\n or manually manage an additional state variable.\n\n\nCheck out \nPEP 279\n for more.\n\n", "score": 9186}}
{"question": "How do I create a directory, and any missing parent directories?", "tags": ["python", "exception", "path", "directory", "operating-system"], "link": "https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories", "answer_count": 27, "answers": {"id": 5032238, "body": "Using try except and the right error code from errno module gets rid of the race condition and is cross-platform:\n\n\nimport os\nimport errno\n\ndef make_sure_path_exists(path):\n    try:\n        os.makedirs(path)\n    except OSError as exception:\n        if exception.errno != errno.EEXIST:\n            raise\n\n\n\nIn other words, we try to create the directories, but if they already exist we ignore the error. On the other hand, any other error gets reported. For example, if you create dir 'a' beforehand and remove all permissions from it, you will get an \nOSError\n raised with \nerrno.EACCES\n (Permission denied, error 13).\n\n", "score": 663}}
{"question": "How do I create a directory, and any missing parent directories?", "tags": ["python", "exception", "path", "directory", "operating-system"], "link": "https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories", "answer_count": 27, "answers": {"id": 14364249, "body": "Python 3.5+:\n\n\nimport pathlib\npathlib.Path('/my/directory').mkdir(parents=True, exist_ok=True) \n\n\n\npathlib.Path.mkdir\n as used above recursively creates the directory and does not raise an exception if the directory already exists. If you don't need or want the parents to be created, skip the \nparents\n argument.\n\n\nPython 3.2+:\n\n\nUsing \npathlib\n:\n\n\nIf you can, install the current \npathlib\n backport named \npathlib2\n. Do not install the older unmaintained backport named \npathlib\n. Next, refer to the Python 3.5+ section above and use it the same.\n\n\nIf using Python 3.4, even though it comes with \npathlib\n, it is missing the useful \nexist_ok\n option. The backport is intended to offer a newer and superior implementation of \nmkdir\n which includes this missing option.\n\n\nUsing \nos\n:\n\n\nimport os\nos.makedirs(path, exist_ok=True)\n\n\n\nos.makedirs\n as used above recursively creates the directory and does not raise an exception if the directory already exists. It has the optional \nexist_ok\n argument only if using Python 3.2+, with a default value of \nFalse\n. This argument does not exist in Python 2.x up to 2.7. As such, there is no need for manual exception handling as with Python 2.7.\n\n\nPython 2.7+:\n\n\nUsing \npathlib\n:\n\n\nIf you can, install the current \npathlib\n backport named \npathlib2\n. Do not install the older unmaintained backport named \npathlib\n. Next, refer to the Python 3.5+ section above and use it the same.\n\n\nUsing \nos\n:\n\n\nimport os\ntry: \n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise\n\n\n\nWhile a naive solution may first use \nos.path.isdir\n followed by \nos.makedirs\n, the solution above reverses the order of the two operations. In doing so, it prevents a common race condition having to do with a duplicated attempt at creating the directory, and also disambiguates files from directories.\n\n\nNote that capturing the exception and using \nerrno\n is of limited usefulness because \nOSError: [Errno 17] File exists\n, i.e. \nerrno.EEXIST\n, is raised for both files and directories. It is more reliable simply to check if the directory exists.\n\n\nAlternative:\n\n\nmkpath\n creates the nested directory, and does nothing if the directory already exists. This works in both Python 2 and 3. Note however that \ndistutils\n has been deprecated, and is scheduled for removal in Python 3.12.\n\n\nimport distutils.dir_util\ndistutils.dir_util.mkpath(path)\n\n\n\nPer \nBug 10948\n, a severe limitation of this alternative is that it works only once per python process for a given path. In other words, if you use it to create a directory, then delete the directory from inside or outside Python, then use \nmkpath\n again to recreate the same directory, \nmkpath\n will simply silently use its invalid cached info of having previously created the directory, and will not actually make the directory again. In contrast, \nos.makedirs\n doesn't rely on any such cache. This limitation may be okay for some applications.\n\n\n\n\nWith regard to the directory's \nmode\n, please refer to the documentation if you care about it.\n\n", "score": 1576}}
{"question": "How do I create a directory, and any missing parent directories?", "tags": ["python", "exception", "path", "directory", "operating-system"], "link": "https://stackoverflow.com/questions/273192/how-do-i-create-a-directory-and-any-missing-parent-directories", "answer_count": 27, "answers": {"id": 273227, "body": "On Python \u2265 3.5, use \npathlib.Path.mkdir\n:\n\n\nfrom pathlib import Path\nPath(\"/my/directory\").mkdir(parents=True, exist_ok=True)\n\n\n\nFor older versions of Python, I see two answers with good qualities, each with a small flaw, so I will give my take on it:\n\n\nTry \nos.path.exists\n, and consider \nos.makedirs\n for the creation.\n\n\nimport os\nif not os.path.exists(directory):\n    os.makedirs(directory)\n\n\n\nAs noted in comments and elsewhere, there's a race condition \u2013 if the directory is created between the \nos.path.exists\n and the \nos.makedirs\n calls, the \nos.makedirs\n will fail with an \nOSError\n. Unfortunately, blanket-catching \nOSError\n and continuing is not foolproof, as it will ignore a failure to create the directory due to other factors, such as insufficient permissions, full disk, etc.\n\n\nOne option would be to trap the \nOSError\n and examine the embedded error code (see \nIs there a cross-platform way of getting information from Python\u2019s OSError\n):\n\n\nimport os, errno\n\ntry:\n    os.makedirs(directory)\nexcept OSError as e:\n    if e.errno != errno.EEXIST:\n        raise\n\n\n\nAlternatively, there could be a second \nos.path.exists\n, but suppose another created the directory after the first check, then removed it before the second one \u2013 we could still be fooled. \n\n\nDepending on the application, the danger of concurrent operations may be more or less than the danger posed by other factors such as file permissions. The developer would have to know more about the particular application being developed and its expected environment before choosing an implementation.\n\n\nModern versions of Python improve this code quite a bit, both by exposing \nFileExistsError\n (in 3.3+)...\n\n\ntry:\n    os.makedirs(\"path/to/directory\")\nexcept FileExistsError:\n    # directory already exists\n    pass\n\n\n\n...and by allowing \na keyword argument to \nos.makedirs\n called \nexist_ok\n (in 3.2+).\n\n\nos.makedirs(\"path/to/directory\", exist_ok=True)  # succeeds even if directory exists.\n\n\n", "score": 7257}}
{"question": "How do I execute a program or call a system command?", "tags": ["python", "shell", "terminal", "subprocess", "command"], "link": "https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command", "answer_count": 66, "answers": {"id": 95246, "body": "Typical implementation:\n\n\nimport subprocess\n\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()\n\n\n\nYou are free to do what you want with the \nstdout\n data in the pipe.  In fact, you can simply omit those parameters (\nstdout=\n and \nstderr=\n) and it'll behave like \nos.system()\n.\n\n", "score": 444}}
{"question": "How do I execute a program or call a system command?", "tags": ["python", "shell", "terminal", "subprocess", "command"], "link": "https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command", "answer_count": 66, "answers": {"id": 92395, "body": "Here is a summary of ways to call external programs, including their advantages and disadvantages:\n\n\n\n\nos.system\n passes the command and arguments to your system's shell. This is nice because you can actually run multiple commands at once in this manner and set up pipes and input/output redirection. For example:\n\n\nos.system(\"some_command < input_file | another_command > output_file\")  \n\n\n\nHowever, while this is convenient, you have to manually handle the escaping of shell characters such as spaces, et cetera. On the other hand, this also lets you run commands which are simply shell commands and not actually external programs.\n\n\n\n\nos.popen\n will do the same thing as \nos.system\n except that it gives you a file-like object that you can use to access standard input/output for that process. There are 3 other variants of popen that all handle the i/o slightly differently. If you pass everything as a string, then your command is passed to the shell; if you pass them as a list then you don't need to worry about escaping anything. Example:\n\n\nprint(os.popen(\"ls -l\").read())\n\n\n\n\n\nsubprocess.Popen\n. This is intended as a replacement for \nos.popen\n, but has the downside of being slightly more complicated by virtue of being so comprehensive. For example, you'd say:\n\n\nprint subprocess.Popen(\"echo Hello World\", shell=True, stdout=subprocess.PIPE).stdout.read()\n\n\n\ninstead of\n\n\nprint os.popen(\"echo Hello World\").read()\n\n\n\nbut it is nice to have all of the options there in one unified class instead of 4 different popen functions. See \nthe documentation\n.\n\n\n\n\nsubprocess.call\n. This is basically just like the \nPopen\n class and takes all of the same arguments, but it simply waits until the command completes and gives you the return code. For example:\n\n\nreturn_code = subprocess.call(\"echo Hello World\", shell=True)\n\n\n\n\n\nsubprocess.run\n. Python 3.5+ only. Similar to the above but even more flexible and returns a \nCompletedProcess\n object when the command finishes executing.\n\n\n\n\nos.fork\n, \nos.exec\n, \nos.spawn\n are similar to their C language counterparts, but I don't recommend using them directly.\n\n\n\n\n\n\nThe \nsubprocess\n module should probably be what you use.\n\n\nFinally, please be aware that for all methods where you pass the final command to be executed by the shell as a string and you are responsible for escaping it. \nThere are serious security implications\n if any part of the string that you pass can not be fully trusted. For example, if a user is entering some/any part of the string. If you are unsure, only use these methods with constants. To give you a hint of the implications consider this code:\n\n\nprint subprocess.Popen(\"echo %s \" % user_input, stdout=PIPE).stdout.read()\n\n\n\nand imagine that the user enters something \"\nmy mama didnt love me && rm -rf /\n\" which could erase the whole filesystem.\n\n", "score": 3653}}
{"question": "How do I execute a program or call a system command?", "tags": ["python", "shell", "terminal", "subprocess", "command"], "link": "https://stackoverflow.com/questions/89228/how-do-i-execute-a-program-or-call-a-system-command", "answer_count": 66, "answers": {"id": 89243, "body": "Use \nsubprocess.run\n:\n\n\nimport subprocess\n\nsubprocess.run([\"ls\", \"-l\"]) \n\n\n\nAnother common way is \nos.system\n but you shouldn't use it because it is unsafe if any parts of the command come from outside your program or can contain spaces or other special characters, also \nsubprocess.run\n is generally more flexible (you can get the \nstdout\n, \nstderr\n, the \n\"real\" status code\n, better \nerror handling\n, etc.). Even the \ndocumentation for \nos.system\n recommends using \nsubprocess\n instead.\n\n\nOn Python 3.4 and earlier, use \nsubprocess.call\n instead of \n.run\n:\n\n\nsubprocess.call([\"ls\", \"-l\"])\n\n\n", "score": 5936}}
{"question": "How do I merge two dictionaries in a single expression in Python?", "tags": ["python", "dictionary", "merge"], "link": "https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python", "answer_count": 45, "answers": {"id": 39437, "body": "An alternative:\n\n\nz = x.copy()\nz.update(y)\n\n\n", "score": 762}}
{"question": "How do I merge two dictionaries in a single expression in Python?", "tags": ["python", "dictionary", "merge"], "link": "https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python", "answer_count": 45, "answers": {"id": 38990, "body": "In your case, you can do:\n\n\nz = dict(list(x.items()) + list(y.items()))\n\n\n\nThis will, as you want it, put the final dict in \nz\n, and make the value for key \nb\n be properly overridden by the second (\ny\n) dict's value:\n\n\n>>> x = {'a': 1, 'b': 2}\n>>> y = {'b': 10, 'c': 11}\n>>> z = dict(list(x.items()) + list(y.items()))\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n\n\n\n\nIf you use Python 2, you can even remove the \nlist()\n calls. To create z:\n\n\n>>> z = dict(x.items() + y.items())\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n\n\n\nIf you use Python version 3.9.0a4 or greater, you can directly use:\n\n\n>>> x = {'a': 1, 'b': 2}\n>>> y = {'b': 10, 'c': 11}\n>>> z = x | y\n>>> z\n{'a': 1, 'c': 11, 'b': 10}\n\n\n", "score": 1833}}
{"question": "How do I merge two dictionaries in a single expression in Python?", "tags": ["python", "dictionary", "merge"], "link": "https://stackoverflow.com/questions/38987/how-do-i-merge-two-dictionaries-in-a-single-expression-in-python", "answer_count": 45, "answers": {"id": 26853961, "body": "How can I merge two Python dictionaries in a single expression?\n\n\nFor dictionaries \nx\n and \ny\n, their shallowly-merged dictionary \nz\n takes values from \ny\n, replacing those from \nx\n.\n\n\n\n\nIn Python 3.9.0 or greater (released 17 October 2020, \nPEP-584\n, \ndiscussed here\n):\n\n\nz = x | y\n\n\n\n\n\nIn Python 3.5 or greater:\n\n\nz = {**x, **y}\n\n\n\n\n\nIn Python 2, (or 3.4 or lower) write a function:\n\n\ndef merge_two_dicts(x, y):\n    z = x.copy()   # start with keys and values of x\n    z.update(y)    # modifies z with keys and values of y\n    return z\n\n\n\nand now:\n\n\nz = merge_two_dicts(x, y)\n\n\n\n\n\n\n\nExplanation\n\n\nSay you have two dictionaries and you want to merge them into a new dictionary without altering the original dictionaries:\n\n\nx = {'a': 1, 'b': 2}\ny = {'b': 3, 'c': 4}\n\n\n\nThe desired result is to get a new dictionary (\nz\n) with the values merged, and the second dictionary's values overwriting those from the first.\n\n\n>>> z\n{'a': 1, 'b': 3, 'c': 4}\n\n\n\nA new syntax for this, proposed in \nPEP 448\n and \navailable as of Python 3.5\n, is\n\n\nz = {**x, **y}\n\n\n\nAnd it is indeed a single expression.\n\n\nNote that we can merge in with literal notation as well:\n\n\nz = {**x, 'foo': 1, 'bar': 2, **y}\n\n\n\nand now:\n\n\n>>> z\n{'a': 1, 'b': 3, 'foo': 1, 'bar': 2, 'c': 4}\n\n\n\nIt is now showing as implemented in the \nrelease schedule for 3.5, PEP 478\n, and it has now made its way into the \nWhat's New in Python 3.5\n document.\n\n\nHowever, since many organizations are still on Python 2, you may wish to do this in a backward-compatible way. The classically Pythonic way, available in Python 2 and Python 3.0-3.4, is to do this as a two-step process:\n\n\nz = x.copy()\nz.update(y) # which returns None since it mutates z\n\n\n\nIn both approaches, \ny\n will come second and its values will replace \nx\n's values, thus \nb\n will point to \n3\n in our final result.\n\n\nNot yet on Python 3.5, but want a \nsingle expression\n\n\nIf you are not yet on Python 3.5 or need to write backward-compatible code, and you want this in a \nsingle expression\n, the most performant while the correct approach is to put it in a function:\n\n\ndef merge_two_dicts(x, y):\n    \"\"\"Given two dictionaries, merge them into a new dict as a shallow copy.\"\"\"\n    z = x.copy()\n    z.update(y)\n    return z\n\n\n\nand then you have a single expression:\n\n\nz = merge_two_dicts(x, y)\n\n\n\nYou can also make a function to merge an arbitrary number of dictionaries, from zero to a very large number:\n\n\ndef merge_dicts(*dict_args):\n    \"\"\"\n    Given any number of dictionaries, shallow copy and merge into a new dict,\n    precedence goes to key-value pairs in latter dictionaries.\n    \"\"\"\n    result = {}\n    for dictionary in dict_args:\n        result.update(dictionary)\n    return result\n\n\n\nThis function will work in Python 2 and 3 for all dictionaries. e.g. given dictionaries \na\n to \ng\n:\n\n\nz = merge_dicts(a, b, c, d, e, f, g) \n\n\n\nand key-value pairs in \ng\n will take precedence over dictionaries \na\n to \nf\n, and so on.\n\n\nCritiques of Other Answers\n\n\nDon't use what you see in the formerly accepted answer:\n\n\nz = dict(x.items() + y.items())\n\n\n\nIn Python 2, you create two lists in memory for each dict, create a third list in memory with length equal to the length of the first two put together, and then discard all three lists to create the dict. \nIn Python 3, this will fail\n because you're adding two \ndict_items\n objects together, not two lists -\n\n\n>>> c = dict(a.items() + b.items())\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nTypeError: unsupported operand type(s) for +: 'dict_items' and 'dict_items'\n\n\n\nand you would have to explicitly create them as lists, e.g. \nz = dict(list(x.items()) + list(y.items()))\n. This is a waste of resources and computation power.\n\n\nSimilarly, taking the union of \nitems()\n in Python 3 (\nviewitems()\n in Python 2.7) will also fail when values are unhashable objects (like lists, for example). Even if your values are hashable, \nsince sets are semantically unordered, the behavior is undefined in regards to precedence. So don't do this:\n\n\n>>> c = dict(a.items() | b.items())\n\n\n\nThis example demonstrates what happens when values are unhashable:\n\n\n>>> x = {'a': []}\n>>> y = {'b': []}\n>>> dict(x.items() | y.items())\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nTypeError: unhashable type: 'list'\n\n\n\nHere's an example where \ny\n should have precedence, but instead the value from \nx\n is retained due to the arbitrary order of sets:\n\n\n>>> x = {'a': 2}\n>>> y = {'a': 1}\n>>> dict(x.items() | y.items())\n{'a': 2}\n\n\n\nAnother hack you should not use:\n\n\nz = dict(x, **y)\n\n\n\nThis uses the \ndict\n constructor and is very fast and memory-efficient (even slightly more so than our two-step process) but unless you know precisely what is happening here (that is, the second dict is being passed as keyword arguments to the dict constructor), it's difficult to read, it's not the intended usage, and so it is not Pythonic.\n\n\nHere's an example of the usage being \nremediated in django\n.\n\n\nDictionaries are intended to take hashable keys (e.g. \nfrozenset\ns or tuples), but \nthis method fails in Python 3 when keys are not strings.\n\n\n>>> c = dict(a, **b)\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nTypeError: keyword arguments must be strings\n\n\n\nFrom the \nmailing list\n, Guido van Rossum, the creator of the language, wrote:\n\n\n\n\nI am fine with\ndeclaring dict({}, **{1:3}) illegal, since after all it is abuse of\nthe ** mechanism.\n\n\n\n\nand\n\n\n\n\nApparently dict(x, **y) is going around as \"cool hack\" for \"call\nx.update(y) and return x\". Personally, I find it more despicable than\ncool.\n\n\n\n\nIt is my understanding (as well as the understanding of the \ncreator of the language\n) that the intended usage for \ndict(**y)\n is for creating dictionaries for readability purposes, e.g.:\n\n\ndict(a=1, b=10, c=11)\n\n\n\ninstead of\n\n\n{'a': 1, 'b': 10, 'c': 11}\n\n\n\nResponse to comments\n\n\n\n\nDespite what Guido says, \ndict(x, **y)\n is in line with the dict specification, which btw. works for both Python 2 and 3. The fact that this only works for string keys is a direct consequence of how keyword parameters work and not a short-coming of dict. Nor is using the ** operator in this place an abuse of the mechanism, in fact, ** was designed precisely to pass dictionaries as keywords.\n\n\n\n\nAgain, it doesn't work for 3 when keys are not strings. The implicit calling contract is that namespaces take ordinary dictionaries, while users must only pass keyword arguments that are strings. All other callables enforced it. \ndict\n broke this consistency in Python 2:\n\n\n>>> foo(**{('a', 'b'): None})\nTraceback (most recent call last):\n  File \"\n\", line 1, in \n\nTypeError: foo() keywords must be strings\n>>> dict(**{('a', 'b'): None})\n{('a', 'b'): None}\n\n\n\nThis inconsistency was bad given other implementations of Python (PyPy, Jython, IronPython). Thus it was fixed in Python 3, as this usage could be a breaking change.\n\n\nI submit to you that it is malicious incompetence to intentionally write code that only works in one version of a language or that only works given certain arbitrary constraints.\n\n\nMore comments:\n\n\n\n\ndict(x.items() + y.items())\n is still the most readable solution for Python 2. Readability counts.\n\n\n\n\nMy response: \nmerge_two_dicts(x, y)\n actually seems much clearer to me, if we're actually concerned about readability. And it is not forward compatible, as Python 2 is increasingly deprecated.\n\n\n\n\n{**x, **y}\n does not seem to handle nested dictionaries. the contents of nested keys are simply overwritten, not merged [...] I ended up being burnt by these answers that do not merge recursively and I was surprised no one mentioned it. In my interpretation of the word \"merging\" these answers describe \"updating one dict with another\", and not merging.\n\n\n\n\nYes. I must refer you back to the question, which is asking for a \nshallow\n merge of \ntwo\n dictionaries, with the first's values being overwritten by the second's - in a single expression.\n\n\nAssuming two dictionaries of dictionaries, one might recursively merge them in a single function, but you should be careful not to modify the dictionaries from either source, and the surest way to avoid that is to make a copy when assigning values. As keys must be hashable and are usually therefore immutable, it is pointless to copy them:\n\n\nfrom copy import deepcopy\n\ndef dict_of_dicts_merge(x, y):\n    z = {}\n    overlapping_keys = x.keys() & y.keys()\n    for key in overlapping_keys:\n        z[key] = dict_of_dicts_merge(x[key], y[key])\n    for key in x.keys() - overlapping_keys:\n        z[key] = deepcopy(x[key])\n    for key in y.keys() - overlapping_keys:\n        z[key] = deepcopy(y[key])\n    return z\n\n\n\nUsage:\n\n\n>>> x = {'a':{1:{}}, 'b': {2:{}}}\n>>> y = {'b':{10:{}}, 'c': {11:{}}}\n>>> dict_of_dicts_merge(x, y)\n{'b': {2: {}, 10: {}}, 'a': {1: {}}, 'c': {11: {}}}\n\n\n\nComing up with contingencies for other value types is far beyond the scope of this question, so I will point you at \nmy answer to the canonical question on a \"Dictionaries of dictionaries merge\"\n.\n\n\nLess Performant But Correct Ad-hocs\n\n\nThese approaches are less performant, but they will provide correct behavior.\nThey will be \nmuch less\n performant than \ncopy\n and \nupdate\n or the new unpacking because they iterate through each key-value pair at a higher level of abstraction, but they \ndo\n respect the order of precedence (latter dictionaries have precedence)\n\n\nYou can also chain the dictionaries manually inside a \ndict comprehension\n:\n\n\n{k: v for d in dicts for k, v in d.items()} # iteritems in Python 2.7\n\n\n\nor in Python 2.6 (and perhaps as early as 2.4 when generator expressions were introduced):\n\n\ndict((k, v) for d in dicts for k, v in d.items()) # iteritems in Python 2\n\n\n\nitertools.chain\n will chain the iterators over the key-value pairs in the correct order:\n\n\nfrom itertools import chain\nz = dict(chain(x.items(), y.items())) # iteritems in Python 2\n\n\n\nPerformance Analysis\n\n\nI'm only going to do the performance analysis of the usages known to behave correctly. (Self-contained so you can copy and paste yourself.)\n\n\nfrom timeit import repeat\nfrom itertools import chain\n\nx = dict.fromkeys('abcdefg')\ny = dict.fromkeys('efghijk')\n\ndef merge_two_dicts(x, y):\n    z = x.copy()\n    z.update(y)\n    return z\n\nmin(repeat(lambda: {**x, **y}))\nmin(repeat(lambda: merge_two_dicts(x, y)))\nmin(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\nmin(repeat(lambda: dict(chain(x.items(), y.items()))))\nmin(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n\n\n\nIn Python 3.8.1, NixOS:\n\n\n>>> min(repeat(lambda: {**x, **y}))\n1.0804965235292912\n>>> min(repeat(lambda: merge_two_dicts(x, y)))\n1.636518670246005\n>>> min(repeat(lambda: {k: v for d in (x, y) for k, v in d.items()}))\n3.1779992282390594\n>>> min(repeat(lambda: dict(chain(x.items(), y.items()))))\n2.740647904574871\n>>> min(repeat(lambda: dict(item for d in (x, y) for item in d.items())))\n4.266070580109954\n\n\n\n$ uname -a\nLinux nixos 4.19.113 #1-NixOS SMP Wed Mar 25 07:06:15 UTC 2020 x86_64 GNU/Linux\n\n\n\nResources on Dictionaries\n\n\n\n\nMy explanation of Python's \ndictionary implementation\n, updated for 3.6.\n\n\nAnswer on how to add new keys to a dictionary\n\n\nMapping two lists into a dictionary\n\n\nThe official Python docs on dictionaries\n\n\nThe Dictionary Even Mightier\n - talk by Brandon Rhodes at Pycon 2017\n\n\nModern Python Dictionaries, A Confluence of Great Ideas\n - talk by Raymond Hettinger at Pycon 2017\n\n\n\n", "score": 9324}}
{"question": "How do I check whether a file exists without exceptions?", "tags": ["python", "file", "file-exists"], "link": "https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions", "answer_count": 41, "answers": {"id": 84173, "body": "Unlike \nisfile()\n, \nexists()\n will return \nTrue\n for directories. So depending on if you want only plain files or also directories, you'll use \nisfile()\n or \nexists()\n. Here is some simple \nREPL\n output:\n\n\n>>> os.path.isfile(\"/etc/password.txt\")\nTrue\n>>> os.path.isfile(\"/etc\")\nFalse\n>>> os.path.isfile(\"/does/not/exist\")\nFalse\n>>> os.path.exists(\"/etc/password.txt\")\nTrue\n>>> os.path.exists(\"/etc\")\nTrue\n>>> os.path.exists(\"/does/not/exist\")\nFalse\n\n\n", "score": 1241}}
{"question": "How do I check whether a file exists without exceptions?", "tags": ["python", "file", "file-exists"], "link": "https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions", "answer_count": 41, "answers": {"id": 82846, "body": "Use \nos.path.exists\n to check both files and directories:\n\n\nimport os.path\nos.path.exists(file_path)\n\n\n\nUse \nos.path.isfile\n to check only files (note: follows \nsymbolic links\n):\n\n\nos.path.isfile(file_path)\n\n\n", "score": 2671}}
{"question": "How do I check whether a file exists without exceptions?", "tags": ["python", "file", "file-exists"], "link": "https://stackoverflow.com/questions/82831/how-do-i-check-whether-a-file-exists-without-exceptions", "answer_count": 41, "answers": {"id": 82852, "body": "If the reason you're checking is so you can do something like \nif file_exists: open_it()\n, it's safer to use a \ntry\n around the attempt to open it. Checking and then opening risks the file being deleted or moved or something between when you check and when you try to open it.\n\n\nIf you're not planning to open the file immediately, you can use \nos.path.isfile\n if you need to be sure it's a file.\n\n\n\n\nReturn \nTrue\n if path is an existing regular file. This follows symbolic links, so both \nislink()\n and \nisfile()\n can be true for the same path.\n\n\n\n\nimport os.path\nos.path.isfile(fname)\n\n\n\npathlib\n\n\nStarting with Python 3.4, the \npathlib\n module\n offers an object-oriented approach (backported to \npathlib2\n in Python 2.7):\n\n\nfrom pathlib import Path\n\nmy_file = Path(\"/path/to/file\")\nif my_file.is_file():\n    # file exists\n\n\n\nTo check a directory, do:\n\n\nif my_file.is_dir():\n    # directory exists\n\n\n\nTo check whether a \nPath\n object exists independently of whether is it a file or directory, use \nexists()\n:\n\n\nif my_file.exists():\n    # path exists\n\n\n\nYou can also use \nresolve(strict=True)\n in a \ntry\n block:\n\n\ntry:\n    my_abs_path = my_file.resolve(strict=True)\nexcept FileNotFoundError:\n    # doesn't exist\nelse:\n    # exists\n\n\n", "score": 6742}}
{"question": "What are metaclasses in Python?", "tags": ["python", "oop", "metaclass", "python-class", "python-datamodel"], "link": "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python", "answer_count": 26, "answers": {"id": 100037, "body": "Note, this answer is for Python 2.x as it was written in 2008, metaclasses are slightly different in 3.x.\n\n\nMetaclasses are the secret sauce that make 'class' work. The default metaclass for a new style object is called 'type'.\n\n\nclass type(object)\n  |  type(object) -> the object's type\n  |  type(name, bases, dict) -> a new type\n\n\n\nMetaclasses take 3 args. '\nname\n', '\nbases\n' and '\ndict\n'\n\n\nHere is where the secret starts. Look for where name, bases and the dict come from in this example class definition.\n\n\nclass ThisIsTheName(Bases, Are, Here):\n    All_the_code_here\n    def doesIs(create, a):\n        dict\n\n\n\nLets define a metaclass that will demonstrate how '\nclass:\n' calls it.\n\n\ndef test_metaclass(name, bases, dict):\n    print 'The Class Name is', name\n    print 'The Class Bases are', bases\n    print 'The dict has', len(dict), 'elems, the keys are', dict.keys()\n\n    return \"yellow\"\n\nclass TestName(object, None, int, 1):\n    __metaclass__ = test_metaclass\n    foo = 1\n    def baz(self, arr):\n        pass\n\nprint 'TestName = ', repr(TestName)\n\n# output => \nThe Class Name is TestName\nThe Class Bases are (\n, None, \n, 1)\nThe dict has 4 elems, the keys are ['baz', '__module__', 'foo', '__metaclass__']\nTestName =  'yellow'\n\n\n\nAnd now, an example that actually means something, this will automatically make the variables in the list \"attributes\" set on the class, and set to None.\n\n\ndef init_attributes(name, bases, dict):\n    if 'attributes' in dict:\n        for attr in dict['attributes']:\n            dict[attr] = None\n\n    return type(name, bases, dict)\n\nclass Initialised(object):\n    __metaclass__ = init_attributes\n    attributes = ['foo', 'bar', 'baz']\n\nprint 'foo =>', Initialised.foo\n# output=>\nfoo => None\n\n\n\nNote that the magic behaviour that \nInitialised\n gains by having the metaclass \ninit_attributes\n is not passed onto a subclass of \nInitialised\n.\n\n\nHere is an even more concrete example, showing how you can subclass 'type' to make a metaclass that performs an action when the class is created. This is quite tricky:\n\n\nclass MetaSingleton(type):\n    instance = None\n    def __call__(cls, *args, **kw):\n        if cls.instance is None:\n            cls.instance = super(MetaSingleton, cls).__call__(*args, **kw)\n        return cls.instance\n\nclass Foo(object):\n    __metaclass__ = MetaSingleton\n\na = Foo()\nb = Foo()\nassert a is b\n\n\n", "score": 492}}
{"question": "What are metaclasses in Python?", "tags": ["python", "oop", "metaclass", "python-class", "python-datamodel"], "link": "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python", "answer_count": 26, "answers": {"id": 100146, "body": "A metaclass is the class of a class. A class defines how an instance of the class (i.e. an object) behaves while a metaclass defines how a class behaves. A class is an instance of a metaclass.\n\n\nWhile in Python you can use arbitrary callables for metaclasses (like \nJerub\n shows), the better approach is to make it an actual class itself. \ntype\n is the usual metaclass in Python. \ntype\n is itself a class, and it is its own type. You won't be able to recreate something like \ntype\n purely in Python, but Python cheats a little. To create your own metaclass in Python you really just want to subclass \ntype\n.\n\n\nA metaclass is most commonly used as a class-factory. When you create an object by calling the class, Python creates a new class (when it executes the 'class' statement) by calling the metaclass. Combined with the normal \n__init__\n and \n__new__\n methods, metaclasses therefore allow you to do 'extra things' when creating a class, like registering the new class with some registry or replace the class with something else entirely.\n\n\nWhen the \nclass\n statement is executed, Python first executes the body of the \nclass\n statement as a normal block of code. The resulting namespace (a dict) holds the attributes of the class-to-be. The metaclass is determined by looking at the baseclasses of the class-to-be (metaclasses are inherited), at the \n__metaclass__\n attribute of the class-to-be (if any) or the \n__metaclass__\n global variable. The metaclass is then called with the name, bases and attributes of the class to instantiate it.\n\n\nHowever, metaclasses actually define the \ntype\n of a class, not just a factory for it, so you can do much more with them. You can, for instance, define normal methods on the metaclass. These metaclass-methods are like classmethods in that they can be called on the class without an instance, but they are also not like classmethods in that they cannot be called on an instance of the class. \ntype.__subclasses__()\n is an example of a method on the \ntype\n metaclass. You can also define the normal 'magic' methods, like \n__add__\n, \n__iter__\n and \n__getattr__\n, to implement or change how the class behaves.\n\n\nHere's an aggregated example of the bits and pieces:\n\n\ndef make_hook(f):\n    \"\"\"Decorator to turn 'foo' method into '__foo__'\"\"\"\n    f.is_hook = 1\n    return f\n\nclass MyType(type):\n    def __new__(mcls, name, bases, attrs):\n\n        if name.startswith('None'):\n            return None\n\n        # Go over attributes and see if they should be renamed.\n        newattrs = {}\n        for attrname, attrvalue in attrs.iteritems():\n            if getattr(attrvalue, 'is_hook', 0):\n                newattrs['__%s__' % attrname] = attrvalue\n            else:\n                newattrs[attrname] = attrvalue\n\n        return super(MyType, mcls).__new__(mcls, name, bases, newattrs)\n\n    def __init__(self, name, bases, attrs):\n        super(MyType, self).__init__(name, bases, attrs)\n\n        # classregistry.register(self, self.interfaces)\n        print \"Would register class %s now.\" % self\n\n    def __add__(self, other):\n        class AutoClass(self, other):\n            pass\n        return AutoClass\n        # Alternatively, to autogenerate the classname as well as the class:\n        # return type(self.__name__ + other.__name__, (self, other), {})\n\n    def unregister(self):\n        # classregistry.unregister(self)\n        print \"Would unregister class %s now.\" % self\n\nclass MyObject:\n    __metaclass__ = MyType\n\n\nclass NoneSample(MyObject):\n    pass\n\n# Will print \"NoneType None\"\nprint type(NoneSample), repr(NoneSample)\n\nclass Example(MyObject):\n    def __init__(self, value):\n        self.value = value\n    @make_hook\n    def add(self, other):\n        return self.__class__(self.value + other.value)\n\n# Will unregister the class\nExample.unregister()\n\ninst = Example(10)\n# Will fail with an AttributeError\n#inst.unregister()\n\nprint inst + inst\nclass Sibling(MyObject):\n    pass\n\nExampleSibling = Example + Sibling\n# ExampleSibling is now a subclass of both Example and Sibling (with no\n# content of its own) although it will believe it's called 'AutoClass'\nprint ExampleSibling\nprint ExampleSibling.__mro__\n\n\n", "score": 3438}}
{"question": "What are metaclasses in Python?", "tags": ["python", "oop", "metaclass", "python-class", "python-datamodel"], "link": "https://stackoverflow.com/questions/100003/what-are-metaclasses-in-python", "answer_count": 26, "answers": {"id": 6581949, "body": "Classes as objects\n\n\nPrior to delving into metaclasses, a solid grasp of Python classes is beneficial. Python holds a particularly distinctive concept of classes, a notion it adopts from the Smalltalk language.\n\n\nIn most languages, classes are just pieces of code that describe how to produce an object. That is somewhat true in Python too:\n\n\n>>> class ObjectCreator(object):\n...     pass\n\n>>> my_object = ObjectCreator()\n>>> print(my_object)\n    <__main__.ObjectCreator object at 0x8974f2c>\n\n\n\nBut classes are more than that in Python. \nClasses are objects too.\n\n\nYes, objects.\n\n\nWhen a Python script runs, every line of code is executed from top to bottom. When the Python interpreter encounters the \nclass\n keyword, Python creates an \nobject\n out of the \"description\" of the class that follows. Thus, the following instruction\n\n\n>>> class ObjectCreator(object):\n...     pass\n\n\n\n...creates an \nobject\n with the name \nObjectCreator\n!\n\n\nThis object (the class) is itself capable of creating objects (called \ninstances\n).\n\n\nBut still, it's an object. Therefore, like all objects:\n\n\n\n\nyou can assign it to a variable\n1\n\n\nJustAnotherVariable = ObjectCreator\n\n\n\n\n\nyou can attach attributes to it\n\nObjectCreator.class_attribute = 'foo'\n\n\n\n\n\nyou can pass it as a function parameter\n\nprint(ObjectCreator)\n\n\n\n\n\n\n\n1\n Note that merely assigning it to another variable doesn't change the class's \n__name__\n, i.e.,\n\n\n>>> print(JustAnotherVariable)\n    \n\n\n>>> print(JustAnotherVariable())\n    <__main__.ObjectCreator object at 0x8997b4c>\n\n\n\n\n\nCreating classes dynamically\n\n\nSince classes are objects, you can create them on the fly, like any object.\n\n\nFirst, you can create a class in a function using \nclass\n:\n\n\n>>> def choose_class(name):\n...     if name == 'foo':\n...         class Foo(object):\n...             pass\n...         return Foo # return the class, not an instance\n...     else:\n...         class Bar(object):\n...             pass\n...         return Bar\n\n>>> MyClass = choose_class('foo')\n\n>>> print(MyClass) # the function returns a class, not an instance\n    \n\n\n>>> print(MyClass()) # you can create an object from this class\n    <__main__.Foo object at 0x89c6d4c>\n\n\n\nBut it's not so dynamic, since you still have to write the whole class yourself.\n\n\nSince classes are objects, they must be generated by something.\n\n\nWhen you use the \nclass\n keyword, Python creates this object automatically. But as\nwith most things in Python, it gives you a way to do it manually.\n\n\nRemember the function \ntype\n? The good old function that lets you know what\ntype an object is:\n\n\n>>> print(type(1))\n    \n\n\n>>> print(type(\"1\"))\n    \n\n\n>>> print(type(ObjectCreator))\n    \n\n\n>>> print(type(ObjectCreator()))\n    \n\n\n\n\nWell, \ntype\n also has a completely different ability: it can create classes on the fly. \ntype\n can take the description of a class as parameters,\nand return a class.\n\n\n(I  know, it's silly that the same function can have two completely different uses according to the parameters you pass to it. It's an issue due to backward\ncompatibility in Python)\n\n\ntype\n works this way:\n\n\ntype(name, bases, attrs)\n\n\n\nWhere:\n\n\n\n\nname\n: name of the class\n\n\nbases\n: tuple of the parent class (for inheritance, can be empty)\n\n\nattrs\n: dictionary containing attributes names and values\n\n\n\n\ne.g.:\n\n\n>>> class MyShinyClass(object):\n...     pass\n\n\n\ncan be created manually this way:\n\n\n>>> MyShinyClass = type('MyShinyClass', (), {}) # returns a class object\n>>> print(MyShinyClass)\n    \n\n\n>>> print(MyShinyClass()) # create an instance with the class\n    <__main__.MyShinyClass object at 0x8997cec>\n\n\n\nYou'll notice that we use \nMyShinyClass\n as the name of the class\nand as the variable to hold the class reference. They can be different,\nbut there is no reason to complicate things.\n\n\ntype\n accepts a dictionary to define the attributes of the class. So:\n\n\n>>> class Foo(object):\n...     bar = True\n\n\n\nCan be translated to:\n\n\n>>> Foo = type('Foo', (), {'bar':True})\n\n\n\nAnd used as a normal class:\n\n\n>>> print(Foo)\n    \n\n\n>>> print(Foo.bar)\n    True\n\n>>> f = Foo()\n>>> print(f)\n    <__main__.Foo object at 0x8a9b84c>\n\n>>> print(f.bar)\n    True\n\n\n\nAnd of course, you can inherit from it, so:\n\n\n>>> class FooChild(Foo):\n...     pass\n\n\n\nwould be:\n\n\n>>> FooChild = type('FooChild', (Foo,), {})\n>>> print(FooChild)\n    \n\n\n>>> print(FooChild.bar) # bar is inherited from Foo\n    True\n\n\n\nEventually, you'll want to add methods to your class. Just define a function\nwith the proper signature and assign it as an attribute.\n\n\n>>> def echo_bar(self):\n...     print(self.bar)\n\n>>> FooChild = type('FooChild', (Foo,), {'echo_bar': echo_bar})\n\n>>> hasattr(Foo, 'echo_bar')\n    False\n\n>>> hasattr(FooChild, 'echo_bar')\n    True\n\n>>> my_foo = FooChild()\n>>> my_foo.echo_bar()\n    True\n\n\n\nAnd you can add even more methods after you dynamically create the class, just like adding methods to a normally created class object.\n\n\n>>> def echo_bar_more(self):\n...     print('yet another method')\n\n>>> FooChild.echo_bar_more = echo_bar_more\n>>> hasattr(FooChild, 'echo_bar_more')\n    True\n\n\n\nYou see where we are going: in Python, classes are objects, and you can create a class on the fly, dynamically.\n\n\nThis is what Python does when you use the keyword \nclass\n, and it does so by using a metaclass.\n\n\nWhat are metaclasses (finally)\n\n\nMetaclasses are the 'stuff' that creates classes.\n\n\nYou define classes in order to create objects, right?\n\n\nBut we learned that Python classes are objects.\n\n\nWell, metaclasses are what create these objects. They are the classes' classes,\nyou can picture them this way:\n\n\nMyClass = MetaClass()\nmy_object = MyClass()\n\n\n\nYou've seen that \ntype\n lets you do something like this:\n\n\nMyClass = type('MyClass', (), {})\n\n\n\nIt's because the function \ntype\n is in fact a metaclass. \ntype\n is the\nmetaclass Python uses to create all classes behind the scenes.\n\n\nNow you wonder \"why the heck is it written in lowercase, and not \nType\n?\"\n\n\nWell, I guess it's a matter of consistency with \nstr\n, the class that creates\nstrings objects, and \nint\n the class that creates integer objects. \ntype\n is\njust the class that creates class objects.\n\n\nYou see that by checking the \n__class__\n attribute.\n\n\nEverything, and I mean everything, is an object in Python. That includes integers,\nstrings, functions and classes. All of them are objects. And all of them have\nbeen created from a class:\n\n\n>>> age = 35\n>>> age.__class__\n    \n\n\n>>> name = 'bob'\n>>> name.__class__\n    \n\n\n>>> def foo(): pass\n>>> foo.__class__\n    \n\n\n>>> class Bar(object): pass\n>>> b = Bar()\n>>> b.__class__\n    \n\n\n\n\nNow, what is the \n__class__\n of any \n__class__\n ?\n\n\n>>> age.__class__.__class__\n    \n\n\n>>> name.__class__.__class__\n    \n\n\n>>> foo.__class__.__class__\n    \n\n\n>>> b.__class__.__class__\n    \n\n\n\n\nSo, a metaclass is just the stuff that creates class objects.\n\n\nYou can call it a 'class factory' if you wish.\n\n\ntype\n is the built-in metaclass Python uses, but of course, you can create your\nown metaclass.\n\n\nThe \n__metaclass__\n attribute\n\n\nIn Python 2, you can add a \n__metaclass__\n attribute when you write a class (see next section for the Python 3 syntax):\n\n\nclass Foo(object):\n    __metaclass__ = something...\n    [...]\n\n\n\nIf you do so, Python will use the metaclass to create the class \nFoo\n.\n\n\nCareful, it's tricky.\n\n\nYou write \nclass Foo(object)\n first, but the class object \nFoo\n is not created\nin memory yet.\n\n\nPython will look for \n__metaclass__\n in the class definition. If it finds it,\nit will use it to create the class object \nFoo\n. If it doesn't, it will use\n\ntype\n to create the class.\n\n\nRead that several times.\n\n\nWhen you do:\n\n\nclass Foo(Bar):\n    pass\n\n\n\nPython does the following:\n\n\nIs there a \n__metaclass__\n attribute in \nFoo\n?\n\n\nIf yes, create in-memory a class object (I said a class object, stay with me here), with the name \nFoo\n by using what is in \n__metaclass__\n.\n\n\nIf Python can't find \n__metaclass__\n, it will look for a \n__metaclass__\n at the MODULE level, and try to do the same (but only for classes that don't inherit anything, basically old-style classes).\n\n\nThen if it can't find any \n__metaclass__\n at all, it will use the \nBar\n's (the first parent) own metaclass (which might be the default \ntype\n) to create the class object.\n\n\nBe careful here that the \n__metaclass__\n attribute will not be inherited, the metaclass of the parent (\nBar.__class__\n) will be. If \nBar\n used a \n__metaclass__\n attribute that created \nBar\n with \ntype()\n (and not \ntype.__new__()\n), the subclasses will not inherit that behavior.\n\n\nNow the big question is, what can you put in \n__metaclass__\n?\n\n\nThe answer is something that can create a class.\n\n\nAnd what can create a class? \ntype\n, or anything that subclasses or uses it.\n\n\nMetaclasses in Python 3\n\n\nThe syntax to set the metaclass has been changed in Python 3:\n\n\nclass Foo(object, metaclass=something):\n    ...\n\n\n\ni.e. the \n__metaclass__\n attribute is no longer used, in favor of a keyword argument in the list of base classes.\n\n\nThe behavior of metaclasses however stays \nlargely the same\n.\n\n\nOne thing added to metaclasses in Python 3 is that you can also pass attributes as keyword-arguments into a metaclass, like so:\n\n\nclass Foo(object, metaclass=something, kwarg1=value1, kwarg2=value2):\n    ...\n\n\n\nRead the section below for how Python handles this.\n\n\nCustom metaclasses\n\n\nThe main purpose of a metaclass is to change the class automatically,\nwhen it's created.\n\n\nYou usually do this for APIs, where you want to create classes matching the\ncurrent context.\n\n\nImagine a stupid example, where you decide that all classes in your module\nshould have their attributes written in uppercase. There are several ways to\ndo this, but one way is to set \n__metaclass__\n at the module level.\n\n\nThis way, all classes of this module will be created using this metaclass,\nand we just have to tell the metaclass to turn all attributes to uppercase.\n\n\nLuckily, \n__metaclass__\n can actually be any callable, it doesn't need to be a\nformal class (I know, something with 'class' in its name doesn't need to be\na class, go figure... but it's helpful).\n\n\nSo we will start with a simple example, by using a function.\n\n\n# the metaclass will automatically get passed the same argument\n# that you usually pass to `type`\ndef upper_attr(future_class_name, future_class_parents, future_class_attrs):\n    \"\"\"\n      Return a class object, with the list of its attribute turned\n      into uppercase.\n    \"\"\"\n    # pick up any attribute that doesn't start with '__' and uppercase it\n    uppercase_attrs = {\n        attr if attr.startswith(\"__\") else attr.upper(): v\n        for attr, v in future_class_attrs.items()\n    }\n\n    # let `type` do the class creation\n    return type(future_class_name, future_class_parents, uppercase_attrs)\n\n__metaclass__ = upper_attr # this will affect all classes in the module\n\nclass Foo(): # global __metaclass__ won't work with \"object\" though\n    # but we can define __metaclass__ here instead to affect only this class\n    # and this will work with \"object\" children\n    bar = 'bip'\n\n\n\nLet's check:\n\n\n>>> hasattr(Foo, 'bar')\n    False\n\n>>> hasattr(Foo, 'BAR')\n    True\n\n>>> Foo.BAR\n    'bip'\n\n\n\nNow, let's do exactly the same, but using a real class for a metaclass:\n\n\n# remember that `type` is actually a class like `str` and `int`\n# so you can inherit from it\nclass UpperAttrMetaclass(type):\n    # __new__ is the method called before __init__\n    # it's the method that creates the object and returns it\n    # while __init__ just initializes the object passed as parameter\n    # you rarely use __new__, except when you want to control how the object\n    # is created.\n    # here the created object is the class, and we want to customize it\n    # so we override __new__\n    # you can do some stuff in __init__ too if you wish\n    # some advanced use involves overriding __call__ as well, but we won't\n    # see this\n    def __new__(\n        upperattr_metaclass,\n        future_class_name,\n        future_class_parents,\n        future_class_attrs\n    ):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in future_class_attrs.items()\n        }\n        return type(future_class_name, future_class_parents, uppercase_attrs)\n\n\n\nLet's rewrite the above, but with shorter and more realistic variable names now that we know what they mean:\n\n\nclass UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type(clsname, bases, uppercase_attrs)\n\n\n\nYou may have noticed the extra argument \ncls\n. There is\nnothing special about it: \n__new__\n always receives the class it's defined in, as the first parameter. Just like you have \nself\n for ordinary methods which receive the instance as the first parameter, or the defining class for class methods.\n\n\nBut this is not proper OOP. We are calling \ntype\n directly and we aren't overriding or calling the parent's \n__new__\n. Let's do that instead:\n\n\nclass UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n        return type.__new__(cls, clsname, bases, uppercase_attrs)\n\n\n\nWe can make it even cleaner by using \nsuper\n, which will ease inheritance (because yes, you can have metaclasses, inheriting from metaclasses, inheriting from type):\n\n\nclass UpperAttrMetaclass(type):\n    def __new__(cls, clsname, bases, attrs):\n        uppercase_attrs = {\n            attr if attr.startswith(\"__\") else attr.upper(): v\n            for attr, v in attrs.items()\n        }\n\n        # Python 2 requires passing arguments to super:\n        return super(UpperAttrMetaclass, cls).__new__(\n            cls, clsname, bases, uppercase_attrs)\n\n        # Python 3 can use no-arg super() which infers them:\n        return super().__new__(cls, clsname, bases, uppercase_attrs)\n\n\n\nOh, and in Python 3 if you do this call with keyword arguments, like this:\n\n\nclass Foo(object, metaclass=MyMetaclass, kwarg1=value1):\n    ...\n\n\n\nIt translates to this in the metaclass to use it:\n\n\nclass MyMetaclass(type):\n    def __new__(cls, clsname, bases, dct, kwargs1=default):\n        ...\n\n\n\nThat's it. There is really nothing more about metaclasses.\n\n\nThe reason behind the complexity of the code using metaclasses is not because\nof metaclasses, it's because you usually use metaclasses to do twisted stuff\nrelying on introspection, manipulating inheritance, vars such as \n__dict__\n, etc.\n\n\nIndeed, metaclasses are especially useful to do black magic, and therefore\ncomplicated stuff. But by themselves, they are simple:\n\n\n\n\nintercept a class creation\n\n\nmodify the class\n\n\nreturn the modified class\n\n\n\n\nWhy would you use metaclasses classes instead of functions?\n\n\nSince \n__metaclass__\n can accept any callable, why would you use a class\nsince it's obviously more complicated?\n\n\nThere are several reasons to do so:\n\n\n\n\nThe intention is clear. When you read \nUpperAttrMetaclass(type)\n, you know\nwhat's going to follow\n\n\nYou can use OOP. Metaclass can inherit from metaclass, override parent methods. Metaclasses can even use metaclasses.\n\n\nSubclasses of a class will be instances of its metaclass if you specified a metaclass-class, but not with a metaclass-function.\n\n\nYou can structure your code better. You never use metaclasses for something as trivial as the above example. It's usually for something complicated. Having the ability to make several methods and group them in one class is very useful to make the code easier to read.\n\n\nYou can hook on \n__new__\n, \n__init__\n and \n__call__\n. Which will allow you to do different stuff, Even if usually you can do it all in \n__new__\n,\nsome people are just more comfortable using \n__init__\n.\n\n\nThese are called metaclasses, damn it! It must mean something!\n\n\n\n\nWhy would you use metaclasses?\n\n\nNow the big question. Why would you use some obscure error-prone feature?\n\n\nWell, usually you don't:\n\n\n\n\nMetaclasses are deeper magic that\n99% of users should never worry about it.\nIf you wonder whether you need them,\nyou don't (the people who actually\nneed them know with certainty that\nthey need them, and don't need an\nexplanation about why).\n\n\n\n\nPython Guru Tim Peters\n\n\nThe main use case for a metaclass is creating an API. A typical example of this is the Django ORM. It allows you to define something like this:\n\n\nclass Person(models.Model):\n    name = models.CharField(max_length=30)\n    age = models.IntegerField()\n\n\n\nBut if you do this:\n\n\nperson = Person(name='bob', age='35')\nprint(person.age)\n\n\n\nIt won't return an \nIntegerField\n object. It will return an \nint\n, and can even take it directly from the database.\n\n\nThis is possible because \nmodels.Model\n defines \n__metaclass__\n and\nit uses some magic that will turn the \nPerson\n you just defined with simple statements\ninto a complex hook to a database field.\n\n\nDjango makes something complex look simple by exposing a simple API\nand using metaclasses, recreating code from this API to do the real job\nbehind the scenes.\n\n\nThe last word\n\n\nFirst, you know that classes are objects that can create instances.\n\n\nWell, in fact, classes are themselves instances. Of metaclasses.\n\n\n>>> class Foo(object): pass\n>>> id(Foo)\n    142630324\n\n\n\nEverything is an object in Python, and they are all either instance of classes\nor instances of metaclasses.\n\n\nExcept for \ntype\n.\n\n\ntype\n is actually its own metaclass. This is not something you could\nreproduce in pure Python, and is done by cheating a little bit at the implementation\nlevel.\n\n\nSecondly, metaclasses are complicated. You may not want to use them for\nvery simple class alterations. You can change classes by using two different techniques:\n\n\n\n\nmonkey patching\n\n\nclass decorators\n\n\n\n\n99% of the time you need class alteration, you are better off using these.\n\n\nBut 98% of the time, you don't need class alteration at all.\n\n", "score": 9265}}
{"question": "Does Python have a ternary conditional operator?", "tags": ["python", "operators", "conditional-operator"], "link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "answer_count": 33, "answers": {"id": 394887, "body": "For versions prior to 2.5, there's the trick:\n\n\n[expression] and [on_true] or [on_false]\n\n\n\nIt can give wrong results when \non_true\n has a false Boolean value.\n1\n\n\nAlthough it does have the benefit of evaluating expressions left to right, which is clearer in my opinion.\n\n\n1. \nIs there an equivalent of C\u2019s \u201d?:\u201d ternary operator?\n\n", "score": 445}}
{"question": "Does Python have a ternary conditional operator?", "tags": ["python", "operators", "conditional-operator"], "link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "answer_count": 33, "answers": {"id": 470376, "body": "You can index into a tuple:\n\n\n(falseValue, trueValue)[test]\n\n\n\ntest\n needs to return \nTrue\n or \nFalse\n.\n\nIt might be safer to always implement it as:\n\n\n(falseValue, trueValue)[test == True]\n\n\n\nor you can use the built-in \nbool()\n to assure a \nBoolean\n value:\n\n\n(falseValue, trueValue)[bool(\n)]\n\n\n", "score": 1020}}
{"question": "Does Python have a ternary conditional operator?", "tags": ["python", "operators", "conditional-operator"], "link": "https://stackoverflow.com/questions/394809/does-python-have-a-ternary-conditional-operator", "answer_count": 33, "answers": {"id": 394814, "body": "Yes, it was \nadded\n in version 2.5. The expression syntax is:\n\n\na if condition else b\n\n\n\nFirst \ncondition\n is evaluated, then exactly one of either \na\n or \nb\n is evaluated and returned based on the \nBoolean\n value of \ncondition\n. If \ncondition\n evaluates to \nTrue\n, then \na\n is evaluated and returned but \nb\n is ignored, or else when \nb\n is evaluated and returned but \na\n is ignored.\n\n\nThis allows short-circuiting because when \ncondition\n is true only \na\n is evaluated and \nb\n is not evaluated at all, but when \ncondition\n is false only \nb\n is evaluated and \na\n is not evaluated at all.\n\n\nFor example:\n\n\n>>> 'true' if True else 'false'\n'true'\n>>> 'true' if False else 'false'\n'false'\n\n\n\nNote that conditionals are an \nexpression\n, not a \nstatement\n. This means you can't use \nstatements\n such as \npass\n, or assignments with \n=\n (or \"augmented\" assignments like \n+=\n), within a conditional \nexpression\n:\n\n\n>>> pass if False else pass\n  File \"\n\", line 1\n    pass if False else pass\n         ^\nSyntaxError: invalid syntax\n\n>>> # Python parses this as `x = (1 if False else y) = 2`\n>>> # The `(1 if False else x)` part is actually valid, but\n>>> # it can't be on the left-hand side of `=`.\n>>> x = 1 if False else y = 2\n  File \"\n\", line 1\nSyntaxError: cannot assign to conditional expression\n\n>>> # If we parenthesize it instead...\n>>> (x = 1) if False else (y = 2)\n  File \"\n\", line 1\n    (x = 1) if False else (y = 2)\n       ^\nSyntaxError: invalid syntax\n\n\n\n(In 3.8 and above, the \n:=\n \"walrus\" operator allows simple assignment of values \nas an expression\n, which is then compatible with this syntax. But please don't write code like that; it will quickly become very difficult to understand.)\n\n\nSimilarly, because it is an expression, the \nelse\n part is \nmandatory\n:\n\n\n# Invalid syntax: we didn't specify what the value should be if the \n# condition isn't met. It doesn't matter if we can verify that\n# ahead of time.\na if True\n\n\n\nYou can, however, use conditional expressions to assign a variable like so:\n\n\nx = a if True else b\n\n\n\nOr for example to return a value:\n\n\n# Of course we should just use the standard library `max`;\n# this is just for demonstration purposes.\ndef my_max(a, b):\n    return a if a > b else b\n\n\n\nThink of the conditional expression as switching between two values. We can use it when we are in a 'one value or another' situation, where we will \ndo the same thing\n with the result, regardless of whether the condition is met. We use the expression to compute the value, and then do something with it. If you need to \ndo something different\n depending on the condition, then use a normal \nif\n \nstatement\n instead.\n\n\n\n\nKeep in mind that it's frowned upon by some Pythonistas for several reasons:\n\n\n\n\nThe order of the arguments is different from those of the classic \ncondition ? a : b\n ternary operator from many other languages (such as \nC\n, \nC++\n, \nGo\n, \nPerl\n, \nRuby\n, \nJava\n, \nJavaScript\n, etc.), which may lead to bugs when people unfamiliar with Python's \"surprising\" behaviour use it (they may reverse the argument order).\n\n\nSome find it \"unwieldy\", since it goes contrary to the normal flow of thought (thinking of the condition first and then the effects).\n\n\nStylistic reasons. (Although the 'inline \nif\n' can be \nreally\n useful, and make your script more concise, it really does complicate your code)\n\n\n\n\nIf you're having trouble remembering the order, then remember that when read aloud, you (almost) say what you mean. For example, \nx = 4 if b > 8 else 9\n is read aloud as \nx will be 4 if b is greater than 8 otherwise 9\n.\n\n\nOfficial documentation:\n\n\n\n\nConditional expressions\n\n\nIs there an equivalent of C\u2019s \u201d?:\u201d ternary operator?\n\n\n\n", "score": 9305}}
{"question": "What does if __name__ == &quot;__main__&quot;: do?", "tags": ["python", "namespaces", "program-entry-point", "python-module", "idioms"], "link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do", "answer_count": 40, "answers": {"id": 419986, "body": "Create the following two files:\n\n\n# a.py\n\nimport b\n\n\n\n# b.py\n\nprint(\"__name__ equals \" + __name__)\n\nif __name__ == '__main__':\n    print(\"if-statement was executed\")\n\n\n\nNow run each file individually.\n\n\n\n\nRunning \npython a.py\n:\n\n\n$ python a.py\n__name__ equals b\n\n\n\nWhen \na.py\n is executed, it imports the module \nb\n. This causes all the code inside \nb\n to run. Python sets \nglobals()['__name__']\n in the \nb\n module to the module's name, \nb\n.\n\n\n\n\nRunning \npython b.py\n:\n\n\n$ python b.py\n__name__ equals __main__\nif-statement was executed\n\n\n\nWhen only the file \nb.py\n is executed, Python sets \nglobals()['__name__']\n in this file to \n\"__main__\"\n. Therefore, the \nif\n statement evaluates to \nTrue\n this time.\n\n", "score": 896}}
{"question": "What does if __name__ == &quot;__main__&quot;: do?", "tags": ["python", "namespaces", "program-entry-point", "python-module", "idioms"], "link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do", "answer_count": 40, "answers": {"id": 419189, "body": "When your script is run by passing it as a command to the Python interpreter,\n\n\npython myscript.py\n\n\n\nall of the code that is at indentation level 0 gets executed.  Functions and classes that are defined are, well, defined, but none of their code gets run.  Unlike other languages, there's no \nmain()\n function that gets run automatically - the \nmain()\n function is implicitly all the code at the top level.\n\n\nIn this case, the top-level code is an \nif\n block.  \n__name__\n is a built-in variable which evaluates to the name of the current module.  However, if a module is being run directly (as in \nmyscript.py\n above), then \n__name__\n instead is set to the string \n\"__main__\"\n.  Thus, you can test whether your script is being run directly or being imported by something else by testing\n\n\nif __name__ == \"__main__\":\n    ...\n\n\n\nIf your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the \nif\n clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:\n\n\n# file one.py\ndef func():\n    print(\"func() in one.py\")\n\nprint(\"top-level in one.py\")\n\nif __name__ == \"__main__\":\n    print(\"one.py is being run directly\")\nelse:\n    print(\"one.py is being imported into another module\")\n\n\n\n# file two.py\nimport one\n\nprint(\"top-level in two.py\")\none.func()\n\nif __name__ == \"__main__\":\n    print(\"two.py is being run directly\")\nelse:\n    print(\"two.py is being imported into another module\")\n\n\n\nNow, if you invoke the interpreter as\n\n\npython one.py\n\n\n\nThe output will be\n\n\ntop-level in one.py\none.py is being run directly\n\n\n\nIf you run \ntwo.py\n instead:\n\n\npython two.py\n\n\n\nYou get\n\n\ntop-level in one.py\none.py is being imported into another module\ntop-level in two.py\nfunc() in one.py\ntwo.py is being run directly\n\n\n\nThus, when module \none\n gets loaded, its \n__name__\n equals \n\"one\"\n instead of \n\"__main__\"\n.\n\n", "score": 2204}}
{"question": "What does if __name__ == &quot;__main__&quot;: do?", "tags": ["python", "namespaces", "program-entry-point", "python-module", "idioms"], "link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do", "answer_count": 40, "answers": {"id": 419185, "body": "Short Answer\n\n\nIt's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:\n\n\n\n\nIf you import the guardless script in another script (e.g. \nimport my_script_without_a_name_eq_main_guard\n), then the latter script will trigger the former to run \nat import time\n and \nusing the second script's command line arguments\n. This is almost always a mistake.\n\n\n\n\nIf you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.\n\n\n\n\n\n\nLong Answer\n\n\nTo better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.\n\n\nWhenever the Python interpreter reads a source file, it does two things:\n\n\n\n\nit sets a few special variables like \n__name__\n, and then\n\n\n\n\nit executes all of the code found in the file.\n\n\n\n\n\n\nLet's see how this works and how it relates to your question about the \n__name__\n checks we always see in Python scripts.\n\n\nCode Sample\n\n\nLet's use a slightly different code sample to explore how imports and scripts work.  Suppose the following is in a file called \nfoo.py\n.\n\n\n# Suppose this is foo.py.\n\nprint(\"before import\")\nimport math\n\nprint(\"before function_a\")\ndef function_a():\n    print(\"Function A\")\n\nprint(\"before function_b\")\ndef function_b():\n    print(\"Function B {}\".format(math.sqrt(100)))\n\nprint(\"before __name__ guard\")\nif __name__ == '__main__':\n    function_a()\n    function_b()\nprint(\"after __name__ guard\")\n\n\n\nSpecial Variables\n\n\nWhen the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the \n__name__\n variable.\n\n\nWhen Your Module Is the Main Program\n\n\nIf you are running your module (the source file) as the main program, e.g.\n\n\npython foo.py\n\n\n\nthe interpreter will assign the hard-coded string \n\"__main__\"\n to the \n__name__\n variable, i.e.\n\n\n# It's as if the interpreter inserts this at the top\n# of your module when run as the main program.\n__name__ = \"__main__\" \n\n\n\nWhen Your Module Is Imported By Another\n\n\nOn the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:\n\n\n# Suppose this is in some other main program.\nimport foo\n\n\n\nThe interpreter will search for your \nfoo.py\n file (along with searching for a few other variants), and prior to executing that module, it will assign the name \n\"foo\"\n from the import statement to the \n__name__\n variable, i.e.\n\n\n# It's as if the interpreter inserts this at the top\n# of your module when it's imported from another module.\n__name__ = \"foo\"\n\n\n\nExecuting the Module's Code\n\n\nAfter the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.\n\n\nAlways\n\n\n\n\nIt prints the string \n\"before import\"\n (without quotes).\n\n\n\n\nIt loads the \nmath\n module and assigns it to a variable called \nmath\n. This is equivalent to replacing \nimport math\n with the following (note that \n__import__\n is a low-level function in Python that takes a string and triggers the actual import):\n\n\n\n\n\n\n# Find and load a module given its string name, \"math\",\n# then assign it to a local variable called math.\nmath = __import__(\"math\")\n\n\n\n\n\nIt prints the string \n\"before function_a\"\n.\n\n\n\n\nIt executes the \ndef\n block, creating a function object, then assigning that function object to a variable called \nfunction_a\n.\n\n\n\n\nIt prints the string \n\"before function_b\"\n.\n\n\n\n\nIt executes the second \ndef\n block, creating another function object, then assigning it to a variable called \nfunction_b\n.\n\n\n\n\nIt prints the string \n\"before __name__ guard\"\n.\n\n\n\n\n\n\nOnly When Your Module Is the Main Program\n\n\n\n\nIf your module is the main program, then it will see that \n__name__\n was indeed set to \n\"__main__\"\n and it calls the two functions, printing the strings \n\"Function A\"\n and \n\"Function B 10.0\"\n.\n\n\n\n\nOnly When Your Module Is Imported by Another\n\n\n\n\n(\ninstead\n) If your module is not the main program but was imported by another one, then \n__name__\n will be \n\"foo\"\n, not \n\"__main__\"\n, and it'll skip the body of the \nif\n statement.\n\n\n\n\nAlways\n\n\n\n\nIt will print the string \n\"after __name__ guard\"\n in both situations.\n\n\n\n\nSummary\n\n\nIn summary, here's what'd be printed in the two cases:\n\n\n# What gets printed if foo is the main program\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nFunction A\nFunction B 10.0\nafter __name__ guard\n\n\n\n# What gets printed if foo is imported as a regular module\nbefore import\nbefore function_a\nbefore function_b\nbefore __name__ guard\nafter __name__ guard\n\n\n\nWhy Does It Work This Way?\n\n\nYou might naturally wonder why anybody would want this.  Well, sometimes you want to write a \n.py\n file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself.  Examples:\n\n\n\n\nYour module is a library, but you want to have a script mode where it runs some unit tests or a demo.\n\n\n\n\nYour module is only used as a main program, but it has some unit tests, and the testing framework works by importing \n.py\n files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.\n\n\n\n\nYour module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.\n\n\n\n\n\n\nBeyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. \"Running\" the script is a side effect of importing the script's module.\n\n\nFood for Thought\n\n\n\n\nQuestion: Can I have multiple \n__name__\n checking blocks?  Answer: it's strange to do so, but the language won't stop you.\n\n\n\n\nSuppose the following is in \nfoo2.py\n.  What happens if you say \npython foo2.py\n on the command-line? Why?\n\n\n\n\n\n\n# Suppose this is foo2.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(\"a1\")\n    from foo2 import function_b\n    print(\"a2\")\n    function_b()\n    print(\"a3\")\n\ndef function_b():\n    print(\"b\")\n\nprint(\"t1\")\nif __name__ == \"__main__\":\n    print(\"m1\")\n    function_a()\n    print(\"m2\")\nprint(\"t2\")\n      \n\n\n\n\n\nNow, figure out what will happen in \nfoo3.py\n (having removed the \n__name__\n check):\n\n\n\n\n# Suppose this is foo3.py.\nimport os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters\n\ndef function_a():\n    print(\"a1\")\n    from foo3 import function_b\n    print(\"a2\")\n    function_b()\n    print(\"a3\")\n\ndef function_b():\n    print(\"b\")\n\nprint(\"t1\")\nprint(\"m1\")\nfunction_a()\nprint(\"m2\")\nprint(\"t2\")\n\n\n\n\n\nWhat will this do when used as a script?  When imported as a module?\n\n\n\n\n# Suppose this is in foo4.py\n__name__ = \"__main__\"\n\ndef bar():\n    print(\"bar\")\n    \nprint(\"before __name__ guard\")\nif __name__ == \"__main__\":\n    bar()\nprint(\"after __name__ guard\")\n\n\n", "score": 8980}}
{"question": "What does the &quot;yield&quot; keyword do in Python?", "tags": ["python", "iterator", "generator", "yield"], "link": "https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python", "answer_count": 52, "answers": {"id": 231801, "body": "Think of it this way:\n\n\nAn iterator is just a fancy sounding term for an object that has a \nnext()\n method.  So a yield-ed function ends up being something like this:\n\n\nOriginal version:\n\n\ndef some_function():\n    for i in xrange(4):\n        yield i\n\nfor i in some_function():\n    print i\n\n\n\nThis is basically what the Python interpreter does with the above code:\n\n\nclass it:\n    def __init__(self):\n        # Start at -1 so that we get 0 when we add 1 below.\n        self.count = -1\n\n    # The __iter__ method will be called once by the 'for' loop.\n    # The rest of the magic happens on the object returned by this method.\n    # In this case it is the object itself.\n    def __iter__(self):\n        return self\n\n    # The next method will be called repeatedly by the 'for' loop\n    # until it raises StopIteration.\n    def next(self):\n        self.count += 1\n        if self.count < 4:\n            return self.count\n        else:\n            # A StopIteration exception is raised\n            # to signal that the iterator is done.\n            # This is caught implicitly by the 'for' loop.\n            raise StopIteration\n\ndef some_func():\n    return it()\n\nfor i in some_func():\n    print i\n\n\n\nFor more insight as to what's happening behind the scenes, the \nfor\n loop can be rewritten to this:\n\n\niterator = some_func()\ntry:\n    while 1:\n        print iterator.next()\nexcept StopIteration:\n    pass\n\n\n\nDoes that make more sense or just confuse you more?  :)\n\n\nI should note that this \nis\n an oversimplification for illustrative purposes. :)\n\n", "score": 792}}
{"question": "What does the &quot;yield&quot; keyword do in Python?", "tags": ["python", "iterator", "generator", "yield"], "link": "https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python", "answer_count": 52, "answers": {"id": 237028, "body": "Shortcut to understanding \nyield\n\n\nWhen you see a function with \nyield\n statements, apply this easy trick to understand what will happen:\n\n\n\n\nInsert a line \nresult = []\n at the start of the function.\n\n\nReplace each \nyield expr\n with \nresult.append(expr)\n.\n\n\nInsert a line \nreturn result\n at the bottom of the function.\n\n\nYay - no more \nyield\n statements! Read and figure out the code.\n\n\nCompare the function to the original definition.\n\n\n\n\nThis trick may give you an idea of the logic behind the function, but what actually happens with \nyield\n is significantly different than what happens in the list-based approach. In many cases, the yield approach will be a lot more memory efficient and faster too. In other cases, this trick will get you stuck in an infinite loop, even though the original function works just fine. Read on to learn more...\n\n\nDon't confuse your iterables, iterators, and generators\n\n\nFirst, the \niterator protocol\n - when you write\n\n\nfor x in mylist:\n    ...loop body...\n\n\n\nPython performs the following two steps:\n\n\n\n\nGets an iterator for \nmylist\n:\n\n\nCall \niter(mylist)\n -> this returns an object with a \nnext()\n method (or \n__next__()\n in Python 3).\n\n\n[This is the step most people forget to tell you about]\n\n\n\n\nUses the iterator to loop over items:\n\n\nKeep calling the \nnext()\n method on the iterator returned from step 1. The return value from \nnext()\n is assigned to \nx\n and the loop body is executed. If an exception \nStopIteration\n is raised from within \nnext()\n, it means there are no more values in the iterator and the loop is exited.\n\n\n\n\n\n\nThe truth is Python performs the above two steps anytime it wants to \nloop over\n the contents of an object - so it could be a for loop, but it could also be code like \notherlist.extend(mylist)\n (where \notherlist\n is a Python list).\n\n\nHere \nmylist\n is an \niterable\n because it implements the iterator protocol. In a user-defined class, you can implement the \n__iter__()\n method to make instances of your class iterable. This method should return an \niterator\n. An iterator is an object with a \nnext()\n method. It is possible to implement both \n__iter__()\n and \nnext()\n on the same class, and have \n__iter__()\n return \nself\n. This will work for simple cases, but not when you want two iterators looping over the same object at the same time.\n\n\nSo that's the iterator protocol, many objects implement this protocol:\n\n\n\n\nBuilt-in lists, dictionaries, tuples, sets, and files.\n\n\nUser-defined classes that implement \n__iter__()\n.\n\n\nGenerators.\n\n\n\n\nNote that a \nfor\n loop doesn't know what kind of object it's dealing with - it just follows the iterator protocol, and is happy to get item after item as it calls \nnext()\n. Built-in lists return their items one by one, dictionaries return the \nkeys\n one by one, files return the \nlines\n one by one, etc. And generators return... well that's where \nyield\n comes in:\n\n\ndef f123():\n    yield 1\n    yield 2\n    yield 3\n\nfor item in f123():\n    print item\n\n\n\nInstead of \nyield\n statements, if you had three \nreturn\n statements in \nf123()\n only the first would get executed, and the function would exit. But \nf123()\n is no ordinary function. When \nf123()\n is called, it \ndoes not\n return any of the values in the yield statements! It returns a generator object. Also, the function does not really exit - it goes into a suspended state. When the \nfor\n loop tries to loop over the generator object, the function resumes from its suspended state at the very next line after the \nyield\n it previously returned from, executes the next line of code, in this case, a \nyield\n statement, and returns that as the next item. This happens until the function exits, at which point the generator raises \nStopIteration\n, and the loop exits.\n\n\nSo the generator object is sort of like an adapter - at one end it exhibits the iterator protocol, by exposing \n__iter__()\n and \nnext()\n methods to keep the \nfor\n loop happy. At the other end, however, it runs the function just enough to get the next value out of it and puts it back in suspended mode.\n\n\nWhy use generators?\n\n\nUsually, you can write code that doesn't use generators but implements the same logic. One option is to use the temporary list 'trick' I mentioned before. That will not work in all cases, for e.g. if you have infinite loops, or it may make inefficient use of memory when you have a really long list. The other approach is to implement a new iterable class \nSomethingIter\n that keeps the state in instance members and performs the next logical step in its \nnext()\n (or \n__next__()\n in Python 3) method. Depending on the logic, the code inside the \nnext()\n method may end up looking very complex and prone to bugs. Here generators provide a clean and easy solution.\n\n", "score": 2582}}
{"question": "What does the &quot;yield&quot; keyword do in Python?", "tags": ["python", "iterator", "generator", "yield"], "link": "https://stackoverflow.com/questions/231767/what-does-the-yield-keyword-do-in-python", "answer_count": 52, "answers": {"id": 231855, "body": "To understand what \nyield\n does, you must understand what \ngenerators\n are. And before you can understand generators, you must understand \niterables\n.\n\n\nIterables\n\n\nWhen you create a list, you can read its items one by one. Reading its items one by one is called iteration:\n\n\n>>> mylist = [1, 2, 3]\n>>> for i in mylist:\n...    print(i)\n1\n2\n3\n\n\n\nmylist\n is an \niterable\n. When you use a list comprehension, you create a list, and so an iterable:\n\n\n>>> mylist = [x*x for x in range(3)]\n>>> for i in mylist:\n...    print(i)\n0\n1\n4\n\n\n\nEverything you can use \"\nfor... in...\n\" on is an iterable; \nlists\n, \nstrings\n, files...\n\n\nThese iterables are handy because you can read them as much as you wish, but you store all the values in memory and this is not always what you want when you have a lot of values.\n\n\nGenerators\n\n\nGenerators are \niterators\n, a kind of iterable \nyou can only iterate over once\n. Generators do not store all the values in memory, \nthey generate the values on the fly\n:\n\n\n>>> mygenerator = (x*x for x in range(3))\n>>> for i in mygenerator:\n...    print(i)\n0\n1\n4\n\n\n\nIt is just the same except you used \n()\n instead of \n[]\n. BUT, you \ncannot\n perform \nfor i in mygenerator\n a second time since generators can only be used once: they calculate 0, then forget about it and calculate 1, and end after calculating 4, one by one.\n\n\nYield\n\n\nyield\n is a keyword that is used like \nreturn\n, except the function will return a generator.\n\n\n>>> def create_generator():\n...    mylist = range(3)\n...    for i in mylist:\n...        yield i*i\n...\n>>> mygenerator = create_generator() # create a generator\n>>> print(mygenerator) # mygenerator is an object!\n\n\n>>> for i in mygenerator:\n...     print(i)\n0\n1\n4\n\n\n\nHere it's a useless example, but it's handy when you know your function will return a huge set of values that you will only need to read once.\n\n\nTo master \nyield\n, you must understand that \nwhen you call the function, the code you have written in the function body does not run.\n The function only returns the generator object, this is a bit tricky.\n\n\nThen, your code will continue from where it left off each time \nfor\n uses the generator.\n\n\nNow the hard part:\n\n\nThe first time the \nfor\n calls the generator object created from your function, it will run the code in your function from the beginning until it hits \nyield\n, then it'll return the first value of the loop. Then, each subsequent call will run another iteration of the loop you have written in the function and return the next value. This will continue until the generator is considered empty, which happens when the function runs without hitting \nyield\n. That can be because the loop has come to an end, or because you no longer satisfy an \n\"if/else\"\n.\n\n\n\n\nYour code explained\n\n\nGenerator:\n\n\n# Here you create the method of the node object that will return the generator\ndef _get_child_candidates(self, distance, min_dist, max_dist):\n\n    # Here is the code that will be called each time you use the generator object:\n\n    # If there is still a child of the node object on its left\n    # AND if the distance is ok, return the next child\n    if self._leftchild and distance - max_dist < self._median:\n        yield self._leftchild\n\n    # If there is still a child of the node object on its right\n    # AND if the distance is ok, return the next child\n    if self._rightchild and distance + max_dist >= self._median:\n        yield self._rightchild\n\n    # If the function arrives here, the generator will be considered empty\n    # There are no more than two values: the left and the right children\n\n\n\nCaller:\n\n\n# Create an empty list and a list with the current object reference\nresult, candidates = list(), [self]\n\n# Loop on candidates (they contain only one element at the beginning)\nwhile candidates:\n\n    # Get the last candidate and remove it from the list\n    node = candidates.pop()\n\n    # Get the distance between obj and the candidate\n    distance = node._get_dist(obj)\n\n    # If the distance is ok, then you can fill in the result\n    if distance <= max_dist and distance >= min_dist:\n        result.extend(node._values)\n\n    # Add the children of the candidate to the candidate's list\n    # so the loop will keep running until it has looked\n    # at all the children of the children of the children, etc. of the candidate\n    candidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n\nreturn result\n\n\n\nThis code contains several smart parts:\n\n\n\n\nThe loop iterates on a list, but the list expands while the loop is being iterated. It's a concise way to go through all these nested data even if it's a bit dangerous since you can end up with an infinite loop. In this case, \ncandidates.extend(node._get_child_candidates(distance, min_dist, max_dist))\n exhausts all the values of the generator, but \nwhile\n keeps creating new generator objects which will produce different values from the previous ones since it's not applied on the same node.\n\n\n\n\nThe \nextend()\n method is a list object method that expects an iterable and adds its values to the list.\n\n\n\n\n\n\nUsually, we pass a list to it:\n\n\n>>> a = [1, 2]\n>>> b = [3, 4]\n>>> a.extend(b)\n>>> print(a)\n[1, 2, 3, 4]\n\n\n\nBut in your code, it gets a generator, which is good because:\n\n\n\n\nYou don't need to read the values twice.\n\n\nYou may have a lot of children and you don't want them all stored in memory.\n\n\n\n\nAnd it works because Python does not care if the argument of a method is a list or not. Python expects iterables so it will work with strings, lists, tuples, and generators! This is called duck typing and is one of the reasons why Python is so cool. But this is another story, for another question...\n\n\nYou can stop here, or read a little bit to see an advanced use of a generator:\n\n\nControlling a generator exhaustion\n\n\n>>> class Bank(): # Let's create a bank, building ATMs\n...    crisis = False\n...    def create_atm(self):\n...        while not self.crisis:\n...            yield \"$100\"\n>>> hsbc = Bank() # When everything's ok the ATM gives you as much as you want\n>>> corner_street_atm = hsbc.create_atm()\n>>> print(corner_street_atm.next())\n$100\n>>> print(corner_street_atm.next())\n$100\n>>> print([corner_street_atm.next() for cash in range(5)])\n['$100', '$100', '$100', '$100', '$100']\n>>> hsbc.crisis = True # Crisis is coming, no more money!\n>>> print(corner_street_atm.next())\n\n\n>>> wall_street_atm = hsbc.create_atm() # It's even true for new ATMs\n>>> print(wall_street_atm.next())\n\n\n>>> hsbc.crisis = False # The trouble is, even post-crisis the ATM remains empty\n>>> print(corner_street_atm.next())\n\n\n>>> brand_new_atm = hsbc.create_atm() # Build a new one to get back in business\n>>> for cash in brand_new_atm:\n...    print cash\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n$100\n...\n\n\n\nNote:\n For Python 3, use\nprint(corner_street_atm.__next__())\n or \nprint(next(corner_street_atm))\n\n\nIt can be useful for various things like controlling access to a resource.\n\n\nItertools, your best friend\n\n\nThe \nitertools\n module contains special functions to manipulate iterables. Ever wish to duplicate a generator?\nChain two generators? Group values in a nested list with a one-liner? \nMap / Zip\n without creating another list?\n\n\nThen just \nimport itertools\n.\n\n\nAn example? Let's see the possible orders of arrival for a four-horse race:\n\n\n>>> horses = [1, 2, 3, 4]\n>>> races = itertools.permutations(horses)\n>>> print(races)\n\n\n>>> print(list(itertools.permutations(horses)))\n[(1, 2, 3, 4),\n (1, 2, 4, 3),\n (1, 3, 2, 4),\n (1, 3, 4, 2),\n (1, 4, 2, 3),\n (1, 4, 3, 2),\n (2, 1, 3, 4),\n (2, 1, 4, 3),\n (2, 3, 1, 4),\n (2, 3, 4, 1),\n (2, 4, 1, 3),\n (2, 4, 3, 1),\n (3, 1, 2, 4),\n (3, 1, 4, 2),\n (3, 2, 1, 4),\n (3, 2, 4, 1),\n (3, 4, 1, 2),\n (3, 4, 2, 1),\n (4, 1, 2, 3),\n (4, 1, 3, 2),\n (4, 2, 1, 3),\n (4, 2, 3, 1),\n (4, 3, 1, 2),\n (4, 3, 2, 1)]\n\n\n\nUnderstanding the inner mechanisms of iteration\n\n\nIteration is a process implying iterables (implementing the \n__iter__()\n method) and iterators (implementing the \n__next__()\n method).\nIterables are any objects you can get an iterator from. Iterators are objects that let you iterate on iterables.\n\n\nThere is more about it in this article about \nhow \nfor\n loops work\n.\n\n", "score": 18217}}
